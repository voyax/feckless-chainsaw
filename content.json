{"meta":{"title":"voya","subtitle":"Reading Box","description":"Reading, Collecting, Thinking and Doing","author":"voya","url":"http://www.voyax.me"},"pages":[{"title":"","date":"2014-04-02T07:36:19.000Z","updated":"2018-08-16T11:04:04.224Z","comments":true,"path":"about/index.html","permalink":"http://www.voyax.me/about/index.html","excerpt":"","text":"所遇到的每一个人都是我的老师，对于各位的来访，我倍感荣幸 voya，人称罗老师，15年毕业于北航计算机学院 浮躁三年后，我希望可以成为值得各位信赖的程序员和真正的朋友 技术相关问题欢迎讨论 voyax3@gmail.com"},{"title":"CSS-Tutorial","date":"2017-07-26T06:59:51.000Z","updated":"2017-07-26T06:59:51.000Z","comments":true,"path":"CSS-Tutorial/index.html","permalink":"http://www.voyax.me/CSS-Tutorial/index.html","excerpt":"","text":""},{"title":"Tutorial","date":"2017-07-26T06:59:41.000Z","updated":"2017-07-26T06:59:41.000Z","comments":true,"path":"Tutorial/index.html","permalink":"http://www.voyax.me/Tutorial/index.html","excerpt":"","text":""},{"title":"about","date":"2018-08-10T07:37:36.000Z","updated":"2018-08-10T07:37:36.776Z","comments":true,"path":"about/index-1.html","permalink":"http://www.voyax.me/about/index-1.html","excerpt":"","text":""},{"title":"所有分类","date":"2018-08-10T11:03:58.000Z","updated":"2018-08-11T10:21:15.746Z","comments":true,"path":"categories/index.html","permalink":"http://www.voyax.me/categories/index.html","excerpt":"","text":""},{"title":"给我留言","date":"2014-05-10T03:36:16.000Z","updated":"2017-06-16T09:05:23.000Z","comments":true,"path":"在线留言/index.html","permalink":"http://www.voyax.me/在线留言/index.html","excerpt":"","text":""},{"title":"search","date":"2017-07-26T08:53:26.000Z","updated":"2015-08-14T10:58:26.000Z","comments":true,"path":"search/index.html","permalink":"http://www.voyax.me/search/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2015-04-26T00:17:17.000Z","updated":"2017-06-16T09:05:23.000Z","comments":true,"path":"文章归档/index.html","permalink":"http://www.voyax.me/文章归档/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-03T02:33:55.000Z","comments":true,"path":"ife2016_task/task7/README.html","permalink":"http://www.voyax.me/ife2016_task/task7/README.html","excerpt":"","text":""},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-19T06:56:51.000Z","comments":true,"path":"ife2016_task/task1/index.html","permalink":"http://www.voyax.me/ife2016_task/task1/index.html","excerpt":"","text":"task1-零基础HTML编码 网站一级标题 导航链接一 导航链接二 导航链接三 导航链接四 文章一级标题 文章二级标题 文章作者 文章发布时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 另一篇文章的一级标题 另一篇文章的二级标题 文章作者 文章发表时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 列表项目一 列表项目二 列表项目三 图片 好看的图片 好看的图片 好看的图片 最后一篇文章一级标题 文章二级标题 文章作者 文章发表时间 排名1 排名二 排名三 下面是一个表格，给表格加一个border=\"1\"好让你看出是一个表格 表头 表头 表头 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 总计 1000 这以后是一个侧栏，这是侧栏标题 侧栏注册窗口标题 请输入邮箱地址： 邮箱地址请按要求格式输入 请输入密码： 请重新输入密码： 密码请为6-16位英文数字 性别： 男 女 城市： 北京 重庆 湖北 深圳 爱好： 运动 艺术 科学 个人描述： 确认提交 版权所有&copy;"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-16T16:09:53.000Z","comments":true,"path":"ife2016_task/task10/README.html","permalink":"http://www.voyax.me/ife2016_task/task10/README.html","excerpt":"","text":"解析 题解 很简单，知道弹性框的基本用法就可以完成了 demo: 任务目的学习如何flex进行布局，学习如何根据屏幕宽度调整布局策略。 任务描述需要实现的效果如效果图（点击打开）所示，调整浏览器宽度查看响应式效果，红色的文字是说明，不需要写在 HTML 中。 任务注意事项只需要完成HTML，CSS代码编写，不需要写JavaScript屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。思考 Flexbox 布局和网格布局的异同，以及分别适用于什么样的场景。可以搜索一下别人的结论，不过要保持思辨的态度，不可直接接受别人的观点。HTML 及 CSS 代码结构清晰、规范 在线学习参考资料Flexbox详解：了解 Flexbox 属性的含义图解 CSS3 Flexbox 属性：看完这两篇，对 Flexbox 的了解就够了，多实践一下，理解会更深刻Flexbox——快速布局神器使用 CSS 弹性盒MDN flex属性"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-16T16:09:53.000Z","comments":true,"path":"ife2016_task/task10/index.html","permalink":"http://www.voyax.me/ife2016_task/task10/index.html","excerpt":"","text":"Flexbox布局练习 .flex-container{ display: flex; /*height: 600px;*/ flex-wrap: wrap; padding: 20px; justify-content: space-between; align-items: center; border: 1px solid #333; margin: 20px; } .flex-item{ width: 150px; box-sizing: border-box; border: 1px solid tomato; margin-bottom: 20px; } .box1{ height: 120px; } .box2{ height: 100px; } .box3{ height: 40px; } .box4{ height: 200px; border-color: blue; } @media all and (max-width: 640px) { .box4{ order: -1; } .flex-container{ align-items: flex-start; } }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-22T09:08:48.000Z","comments":true,"path":"ife2016_task/task5/index.html","permalink":"http://www.voyax.me/ife2016_task/task5/index.html","excerpt":"","text":"task5-零基础HTML及CSS编码(二) 导航链接一 导航链接二 导航链接三 导航链接四 这以后是一个侧栏，这是侧栏标题 请输入邮箱地址： 邮箱地址请按要求格式输入 请输入密码： 请重新输入密码： 密码请为6-16位英文数字 性别： 男 女 城市： 北京 重庆 湖北 深圳 爱好： 运动 艺术 科学 个人描述： 确认提交 文章一级标题 文章二级标题 文章作者 文章发布时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 另一篇文章的一级标题 另一篇文章的二级标题 文章作者 文章发表时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 列表项目一 列表项目二 列表项目三 图片 好看的图片 好看的图片 好看的图片 最后一篇文章一级标题 文章二级标题 文章作者 文章发表时间 1. 排名1 2. 排名二 3. 排名三 下面是一个表格，给表格加一个border=\"1\"好让你看出是一个表格 表头 表头 表头 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 总计 1000 版权所有&copy;"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-01T04:40:18.000Z","comments":true,"path":"ife2016_task/task6/index.html","permalink":"http://www.voyax.me/ife2016_task/task6/index.html","excerpt":"","text":"任务六：通过HTML及CSS模拟报纸排版 www.voyax.me 2016.03 What 前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端端前端前端前端前端前端前端端前端前端前端前端前端前端端前端前端前端前端前端前端 When 前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端端前端前端前端前端前端前端 How 前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端前端 What----------40% What----------30% What----------30% ABOUT TECHNOLOGE About technologe about technologe about technologe 700 3.2 CSS csscssscsscsscssc THE TECHNOLOGE OF FRONT 前端技术领域 妈妈说的，新帘子胡同像一把汤匙，我们家就住在靠近汤匙的底儿上，正是舀汤喝时碰到嘴唇的地方。于是爸爸就教训我，他绷着脸，瞪着眼说： “讲晤听！喝汤不要出声，（上“穴”，下“卒”）的，最不是女孩儿家相。舀汤时，汤匙也不要把碗碰得当当当地响。”我小心地拿着汤匙，轻慢轻慢地探进汤碗里，爸又发脾气了： “小人家要等大人先舀过了再舀，不能上一个菜，你就先下手，”他又转过脸向妈妈： “你平常对孩子全没教习也是不行的。” 我心急得很，只想赶快吃了饭去到门口看方德成和刘平踢球玩，所以我就喝汤出了声，舀汤碰了碗，菜来先下手。我已经吃饱了，只好还坐在饭桌旁，等着给爸爸盛第二碗饭。爸爸说，不能什么都让佣人做，他这么大的人，在老家时，也还是吃完了饭仍站在一旁，听着爷爷的教训。 我乘着给爸爸盛好饭，就溜开了饭桌，走向靠着窗前的书桌去，只听妈妈悄悄对爸爸说： “也别把她管得这么严吧，孩子才多大？去年惠安馆的疯子把她吓得那么一大场病，到现在还有胆小的毛病，听见你大声骂她，她就一声不言语，她原来不是这样的孩子呀！现在搬到这里来，换了一个地方，忘记以前的事，又上学了，好容易脸上长胖些” 妈妈啊！你为什么又提起那件奇怪的事呢？你们又常常说，哪个是疯子，哪个是傻子，哪个是骗子，哪个是贼子，我分也分不清。就像我现在抬头看见窗外蓝色的天空上，飘着白色的云朵，就要想到国文书上第二十六课的那篇《我们看海去》： 我们看海去！ 我们看海去！ 蓝色的大海上， 扬着白色的帆。 金红的太阳， 前端技术 前端技术前端技术 前端前端前端前端前端前端..................................前端 前端前端前端..........................................................前端 前端前端前端前端前端前端前端前端...................张秋 0 ONE TWO THREE FORE FIVE hello world hello world hello world hello world hello world hello world hello world hello world hello world hello world hello world hello world ife.baidu.com"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-03T03:45:34.000Z","comments":true,"path":"ife2016_task/task7/index.html","permalink":"http://www.voyax.me/ife2016_task/task7/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-20T13:15:11.000Z","comments":true,"path":"ife2016_task/task2/index.html","permalink":"http://www.voyax.me/ife2016_task/task2/index.html","excerpt":"","text":"task2-零基础HTML及CSS编码(一) 导航链接一 导航链接二 导航链接三 导航链接四 文章一级标题 文章二级标题 文章作者 文章发布时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 另一篇文章的一级标题 另一篇文章的二级标题 文章作者 文章发表时间 九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码，九歌之任务一——零基础HTML编码 列表项目一 列表项目二 列表项目三 图片 好看的图片 好看的图片 好看的图片 最后一篇文章一级标题 文章二级标题 文章作者 文章发表时间 1. 排名1 2. 排名二 3. 排名三 下面是一个表格，给表格加一个border=\"1\"好让你看出是一个表格 表头 表头 表头 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 表内容单元格 表内容单元格 操作 总计 1000 这以后是一个侧栏，这是侧栏标题 请输入邮箱地址： 邮箱地址请按要求格式输入 请输入密码： 请重新输入密码： 密码请为6-16位英文数字 性别： 男 女 城市： 北京 重庆 湖北 深圳 爱好： 运动 艺术 科学 个人描述： 确认提交 版权所有&copy;"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-14T14:04:47.000Z","comments":true,"path":"ife2016_task/task8/index.html","permalink":"http://www.voyax.me/ife2016_task/task8/index.html","excerpt":"","text":"栅格布局"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-21T15:29:35.000Z","comments":true,"path":"ife2016_task/task3/README.html","permalink":"http://www.voyax.me/ife2016_task/task3/README.html","excerpt":"","text":"任务描述 使用 HTML 与 CSS 按照 示例图（点击查看） 实现三栏式布局。 左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。任务注意事项 任务注意事项 尝试 position 和 float 的效果，思考它们的异同和应用场景。 注意测试不同情况，尤其是极端情况下的效果。 图片和文字内容请自行替换，尽可能体现团队的特色。 调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。 改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。 其他效果图中给出的标识均被正确地实现。"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-20T16:08:21.000Z","comments":true,"path":"ife2016_task/task4/README.html","permalink":"http://www.voyax.me/ife2016_task/task4/README.html","excerpt":"","text":"任务目标 实践HTML/CSS布局方式 深入了解position等CSS属性 任务描述实现如 示例图（点击打开） 的效果灰色元素水平垂直居中，有两个四分之一圆位于其左上角和右下角。任务注意事项 思考不同情况下（如灰色高度是根据内容动态变化的）水平垂直居中的解决方案。动手试一试各种情况的组合，父元素和子元素分别取不同的 position 值。思考 position 属性各种取值的真正含义，尤其是 absolute 究竟是相对谁而言的。注意测试不同情况，尤其是极端情况下的效果。调节浏览器宽度，灰色元素始终水平居中。调节浏览器高度，灰色元素始终垂直居中。调节浏览器高度和宽度，黄色扇形的定位始终准确。其他效果图中给出的标识均被正确地实现，错一项扣一分。任务协作建议 团队集中讨论，明确题目要求，保证队伍各自对题目要求认知一致各自完成任务实践交叉互相Review其他人的代码，建议每个人至少看一个同组队友的代码相互讨论，最后合成一份组内最佳代码进行提交 参考资料 HTML和CSS高级指南之二——定位详解：大漠老师手把手教你，这次彻底搞懂定位问题 Centering in CSS: A Complete Guide：完整讨论了不同情况下的居中方案，建议自己思考之后再看答案 Get HTML &amp; CSS Tips In Your Inbox：有人写了一个作弊工具生成居中代码，但是看着代码你明白为什么吗"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-17T14:24:08.000Z","comments":true,"path":"ife2016_task/task3/index-nmargin.html","permalink":"http://www.voyax.me/ife2016_task/task3/index-nmargin.html","excerpt":"","text":"三栏式布局 BFC 负边距 关于九歌 一张褪色的照片 好像带给我一点点怀念 巷尾老爷爷卖的热汤面 味道弥漫过旧旧的后院 流浪猫睡熟在摇晃秋千 夕阳照了一遍他咪着眼 那张同桌寄的明信片 安静的躺在课桌的里面 快要过完的春天 还有雕刻着图案的门帘 窄窄的长长的过道两边 老房子依然升起了炊烟 刚刚下完了小雨的季节 爸妈又一起走过的老街 记不得哪年的哪一天 很漫长又很短暂的岁月 现在已经回不去 早已流逝的光阴 手里的那一张渐渐模糊不清的车票 成了回忆的信号 忘不掉的是什么我也不知道 想不起当年模样 看也看不到 去也去不了的地方 也许那老街的腔调是属于我的忧伤 嘴角那点微笑越来越勉强 忘不掉的是什么我也不知道 放不下熟悉片段 回头望一眼 已经很多年的时间 九歌"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-17T14:23:48.000Z","comments":true,"path":"ife2016_task/task3/index.html","permalink":"http://www.voyax.me/ife2016_task/task3/index.html","excerpt":"","text":"三栏式布局 BFC 负边距 九歌 关于九歌 一张褪色的照片 好像带给我一点点怀念 巷尾老爷爷卖的热汤面 味道弥漫过旧旧的后院 流浪猫睡熟在摇晃秋千 夕阳照了一遍他咪着眼 那张同桌寄的明信片 安静的躺在课桌的里面 快要过完的春天 还有雕刻着图案的门帘 窄窄的长长的过道两边 老房子依然升起了炊烟 刚刚下完了小雨的季节 爸妈又一起走过的老街 记不得哪年的哪一天 很漫长又很短暂的岁月 现在已经回不去 早已流逝的光阴 手里的那一张渐渐模糊不清的车票 成了回忆的信号 忘不掉的是什么我也不知道 想不起当年模样 看也看不到 去也去不了的地方 也许那老街的腔调是属于我的忧伤 嘴角那点微笑越来越勉强 忘不掉的是什么我也不知道 放不下熟悉片段 回头望一眼 已经很多年的时间"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-20T15:51:37.000Z","comments":true,"path":"ife2016_task/task4/index.html","permalink":"http://www.voyax.me/ife2016_task/task4/index.html","excerpt":"","text":"任务四：定位和居中问题 绝对定位 + 负边距 适合元素宽度、高度确定情况 绝对定位 + transform 适应元素宽度、高度不确定 flexbo 适应元素宽度、高度不确定"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-16T16:09:53.000Z","comments":true,"path":"ife2016_task/task10/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task10/css/style.css","excerpt":"","text":""},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-16T16:09:53.000Z","comments":true,"path":"ife2016_task/task10/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task10/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-22T08:20:24.000Z","comments":true,"path":"ife2016_task/task5/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task5/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-22T09:07:45.000Z","comments":true,"path":"ife2016_task/task5/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task5/css/style.css","excerpt":"","text":"body { font-family: \"lucida grande\", \"lucida sans unicode\", lucida, helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; font-size: 12px; background: #dbdbdb; } .header { height: 50px; padding: 5px 25px 5px 25px; border-bottom: 2px solid #2f2f2f; background: #3f3f3f; } .container { min-width: 680px; min-height: 100%; margin-top: 25px; margin-right: 25px; margin-bottom: 60px; margin-left: 25px; overflow: hidden; } .header .nav-logo { float: left; } .nav-logo img { width: 50px; height: 50px; } .header .nav { float: right; margin-top: -5px; list-style: none; /*margin-right: -15px;*/ } .nav li { display: inline-block; height: 60px; padding-right: 10px; padding-left: 10px; } .nav li a { display: inline-block; height: 100%; line-height: 60px; text-decoration: none; color: #b1b1b1; } .nav li.active { border-bottom: 2px solid #555; } .nav li.active a { color: #eee; } .nav li:hover { background: #262626; } .nav li a:hover { color: #b1b1b1; } .contents { overflow: hidden; } .article { padding: 20px; margin-bottom: 25px; overflow: hidden; background: #fff; } .article h2, .article h3, .article h4 { margin-bottom: 10px; } .article h3, .article h3, .article h4, .article .adds-on { color: #555; } .article h2 { font-size: 2em; font-weight: 700; } .article h3 { font-size: 1.7em; } .article .adds-on { margin-bottom: 10px; } .article p, .article ol { margin-bottom: 10px; text-indent: 2em; } .article .img-box { display: inline-block; float: left; width: 250px; height: 250px; padding: 5px; margin-right: 15px; margin-bottom: 20px; text-align: center; border: 1px solid #333; } .article img, .article .img-box img { display: block; height: 200px; } .article .img-box img { margin: 0 auto; } .article ol li { font-size: 1.2em; font-weight: 700; } .article table { width: 100%; } table caption { font-weight: 700; } table tr td, table tr th { padding: 5px; } .article thead { color: #fff; background: #000; } .tr-sum { font-weight: 700; background: #ccc; } .tr-sum td { border: none; } /* aside */ .aside { float: right; width: 370; padding: 20px; margin-left: 20px; background: #fff; } .aside .title { padding-left: 8px; font-size: 1.4em; font-weight: 700; border-left: 4px solid #ccc; } form { width: 100%; } input, textarea { padding: 6px 12px; border: 1px solid #aaa; } .form-group { margin-bottom: 15px; } .form-group .form-label { display: inline-block; width: 120px; text-align: right; vertical-align: top; } .form-inline-control { display: inline-block; } .err-tip { margin-top: 5px; color: #ccc; } .btn { padding: 6px 12px; cursor: pointer; vertical-align: middle; border: 1px solid transparent; border-radius: 4px; } .btn-blue { color: #fff; background: blue; } .btn-big { width: 100%; padding: 12px; } /* footer */ .footer { height: 60px; padding: 25px; margin-top: -60px; text-align: center; color: #fff; background: #3f3f3f; }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-22T09:11:57.000Z","comments":true,"path":"ife2016_task/task6/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task6/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-01T04:38:59.000Z","comments":true,"path":"ife2016_task/task6/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task6/css/style.css","excerpt":"","text":".header, footer, .container{ width: 892px; margin: 0 auto; } .bottom-aligner{ display: inline-block; width: 0; height: 100%; vertical-align: bottom; } .bottom-section{ display: inline-block; } .header{ position: relative; width: 892px; height: 61px; border-bottom: 2px solid #938e8c; } .header .header-logo{ display: inline-block; width: 110px; height: 100%; color: #fff; background: #d45f5f; } .header .header-date{ position: absolute; right: 0; bottom: 0; font-family: \"黑体\"; font-size: 12px; color: #d45d5c; } /* global section begin */ .section{ margin-top: 38px; } .section p{ margin-bottom: 16px; } /* global section end */ /* section1 begin */ .section1{ overflow: hidden; } .section1-left{ float: left; width: 641px; overflow: hidden; } .section1-desc{ float: right; width: 203px; border-top: 2px solid #cc8091; } .focus-pic{ position: relative; width: 641px; height: 301px; } .focus-pic img{ width: 100%; height: auto; } .focus-pic:before, .focus-pic:after{ position: absolute; top: 0; /*z-index: 9;*/ width: 191px; height: 301px; content: \"\"; opacity: .4; background: #495a45; } .focus-pic:after{ right: 0; background: #d45f5f; } .section1-desc{ display: inline-block; } .section1-desc > p{ margin-top: 5px; /*margin-bottom: 10px;*/ font-family: \"楷体\"; font-size: 12px; color: #676767; } .section1-desc h2 p{ font-family: \"Microsoft YaHei\"; font-size: 24px; line-height: 40px; } .section1-desc h2 p{ display: inline-block; border-bottom: 2px solid #938e8c; } .section1-desc h2 p::first-letter{ font-size: 1.4em; } .section1-desc .big-num{ margin-left: -15px; font-family: \"Microsoft YaHei\"; font-size: 116px; font-style: oblique; line-height: 124px; color: #75b86b; } .medium-static{ overflow: hidden; font-family: \"Microsoft YaHei\"; color: #cc8091; } .medium-static .medium-static-num{ display: inline-block; font-size: 55px; } .medium-static .medium-static-desc{ display: inline-block; } .medium-static .medium-static-desc p{ font-size: 12px; color: #231815; } .medium-static-desc p.medium-static-sub-num{ margin-bottom: 0; font-size: 21px; color: #cc8091; } .col-3{ float: left; width: 30%; margin-top: 40px; margin-right: 3%; } .article{ font-family: \"宋体\"; font-size: 12px; line-height: 22px; color: #767777; } .green-title, .brown-title, .oringe-title{ display: inline-block; margin-bottom: 10px; font-family: \"Microsoft YaHei\"; font-size: 16px; border-bottom: 2px solid; } .green-title{ color: #418c59; } .brown-title{ color: #cc7680; } .oringe-title{ color: #d2994f; } .cat{ margin-top: 10px; font-family: \"Microsoft YaHei\"; line-height: 16px; opacity: .7; } .cat span{ color: #cd4a48; } /* section1 end */ /* section2 begin */ .section2{ overflow: hidden; } .section2-left{ float: left; width: 415px; margin-right: 19px; } .section2-title{ font-family: \"SimHei\"; font-size: 42px; line-height: 100%; color: #11456b; border-bottom: 2px solid #11456b; } .section2-title .sub-title{ font-size: 33px; font-weight: 700; } .big-yellow{ font-size: 72px; font-style: italic; color: #f5e327; } .section2-left .article p + p{ text-indent: 2em; } .section2-left .article:first-letter{ float: left; font-family: \"Microsoft YaHei\"; font-size: 70px; line-height: 1; color: #f5e327; } /* 文章中的图片 */ .section2-left .article img{ float: right; } /* section2 right */ .section2-right{ float: right; width: 458px; } /* 缩略图 */ .thumbnail{ position: relative; margin-bottom: 26px; } .thumbnail img{ width: 100%; height: 275px; } .thumbnail .caption{ position: absolute; bottom: 0; width: 100%; height: 44px; height: 61px; opacity: .8; background: #555; } .thumbnail .caption h3{ height: 36px; padding-left: 5px; margin: 12px 0 13px 25px; font-size: 26px; line-height: 36px; color: #fff; border-left: 3px solid #72b16a; } h3 small{ font-size: 12px; font-style: italic; color: #72b165; } .right-bottom{ height: 358px; /* 避免上边距合并 */ padding-top: 1px; margin-top: -1px; background: #eeeed8; } .cat2{ margin: 30px 30px 30px 40px; font-family: \"宋体\"; font-size: 16px; color: #5a5b5b; } .cat2 p{ position: relative; margin-bottom: 20px; } .cat2 p span{ font-size: 12px; font-style: italic; } .cat2 p:before{ position: absolute; top: 2px; left: -18px; content: \"\"; border: 8px solid transparent; border-bottom-color: #134768; } .card{ float: left; width: 260px; height: 160px; overflow: hidden; color: #fff; background: #d45f5f; } .card .left, .card .right{ height: 86px; margin-top: 37px; overflow: hidden; font-family: \"微软雅黑\"; } .card .left{ float: left; padding-right: 8px; padding-left: 10px; font-size: 110px; line-height: 86px; border-right: 2px solid; } .card .right{ display: inline-block; width: 160px; padding-left: 8px; overflow: hidden; } .card .right h3{ font-family: SimHei; font-size: 21px; font-style: italic; } .card .right h3 p{ margin-bottom: 6px; } .quote{ position: relative; padding-top: 10px; padding-left: 10px; margin-top: 10px; overflow: hidden; overflow: hidden; font-family: SimHei; font-size: 14px; font-style: italic; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\"; color: #5a5b5b; } .quote:before, .quote:after{ position: absolute; /*position: absolute;*/ font-size: 72px; /*line-height: 24px;*/ color: #d45f5f; } .quote:before{ top: -10px; left: -34px; content: open-quote; } .quote:after{ right: 0; bottom: 0; margin-bottom: -48px; content: close-quote; } .quote p{ display: inline-block; text-indent: 3em; } /* section2 end */ /* footer begin */ .footer{ height: 60px; overflow: auto; border-top: 1px solid #938e8c; } .footer a{ float: right; text-decoration: none; color: #d26061; } /* footer end */"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-14T16:07:40.000Z","comments":true,"path":"ife2016_task/task8/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task8/css/style.css","excerpt":"","text":".grid-container{ max-width: 1200px; padding: 10px; margin: 0 auto; } .row:after{ display: table; clear: both; content: \"\"; } [class^=\"col-\"]{ float: left; padding: 20px; margin: 10px; box-sizing: border-box; border: 1px solid #999; background: #eeeeef; } .col-md-1{ width: calc(8.333% - 20px); } .col-md-2{ width: calc(16.667% - 20px); } .col-md-3{ width: calc(25% - 20px); } .col-md-4{ width: calc(33.333% - 20px); } .col-md-5{ width: calc(41.667% - 20px); } .col-md-6{ width: calc(50% - 20px); } .col-md-7{ width: calc(58.333% - 20px); } .col-md-8{ width: calc(66.667% - 20px); } .col-md-9{ width: calc(.75 - 20px); } .col-md-10{ width: calc(83.333% - 20px); } .col-md-11{ width: calc(91.667%-20px); } .col-md-12{ width: calc(100% - 20px); } @media all and (max-width: 768px){ .col-sm-1{ width: calc(8.333% - 20px); } .col-sm-2{ width: calc(16.667% - 20px); } .col-sm-3{ width: calc(25% - 20px); } .col-sm-4{ width: calc(33.333% - 20px); } .col-sm-5{ width: calc(41.667% - 20px); } .col-sm-6{ width: calc(50% - 20px); } .col-sm-7{ width: calc(58.333% - 20px); } .col-sm-8{ width: calc(66.667% - 20px); } .col-sm-9{ width: calc(75% - 20px); } .col-sm-10{ width: calc(83.333% - 20px); } .col-sm-11{ width: calc(91.667% - 20px); } .col-sm-12{ width: calc(100% - 20px); } }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-05-08T03:27:21.000Z","comments":true,"path":"ife2016_task/task8/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task8/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-20T13:23:10.000Z","comments":true,"path":"ife2016_task/task2/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task2/css/style.css","excerpt":"","text":"body{ font-size: 12px; font-family: \"lucida grande\", \"lucida sans unicode\", lucida, helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; background: #DBDBDB; } .header{ height: 50px; padding: 5px 25px 5px 25px; background: #3F3F3F; border-bottom: 2px solid #2F2F2F; } .container{ min-height: 100%; margin-left: 25px; margin-right: 25px; margin-top: 25px; margin-bottom: 60px; } .header .nav-logo{ float: left; } .nav-logo img{ height: 50px; width: 50px; } .header .nav{ float: right; list-style: none; margin-top: -5px; /*margin-right: -15px;*/ } .nav li{ display: inline-block; padding-left: 10px; padding-right: 10px; height: 60px; } .nav li a{ display: inline-block; height: 100%; line-height: 60px; color:#b1b1b1; text-decoration: none; } .nav li.active{ border-bottom: 2px solid #555555; } .nav li.active a{ color: #eeeeee; } .nav li:hover{ background: #262626; } .nav li a:hover{ color:#b1b1b1; } .article{ margin-bottom: 25px; padding: 20px; background: #fff; } .article h2, .article h3, .article h4{ margin-bottom: 10px; } .article h3, .article h3, .article h4, .article .adds-on{ color:#555555; } .article h2{ font-size: 2em; font-weight: 700; } .article h3{ font-size: 1.7em; } .article .adds-on{ margin-bottom: 10px; } .article p,.article ol{ margin-bottom: 10px; text-indent: 2em; } .article .img-box{ text-align: center; height: 250px; width: 250px; border: 1px solid #333333; padding: 5px; margin-bottom: 20px; } .article img, .article .img-box img{ display: block; height: 200px; } .article .img-box img{ margin: 0 auto; } .article ol li{ font-size: 1.2em; font-weight: 700; } .article table{ width: 100%; } table caption{ font-weight: 700; } table tr td,table tr th{ padding: 5px; } .article thead{ background: #000; color:#fff; } .tr-sum{ background: #CCCCCC; font-weight: 700; } .tr-sum td{ border: none; } /* aside */ .aside{ background: #fff; padding: 20px; } .aside .title{ border-left: 4px solid #CCCCCC; padding-left: 8px; font-size: 1.4em; font-weight: 700; } form{ width: 100%; } input,textarea{ padding: 6px 12px; border: 1px solid #aaa; } .form-group{ margin-bottom: 15px; } .form-group .form-label{ display: inline-block; text-align: right; vertical-align: top; width: 300px; } .form-inline-control{ display: inline-block; } .err-tip{ margin-top: 5px; color: #CCCCCC; } .btn{ padding: 6px 12px; vertical-align: middle; cursor: pointer; border: 1px solid transparent; border-radius: 4px; } .btn-blue{ background: blue; color: #fff; } .btn-big{ width: 100%; padding: 12px; } /* footer */ .footer{ margin-top: -60px; background: #3F3F3F; text-align: center; height: 60px; padding: 25px; color:#fff; }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-20T02:50:54.000Z","comments":true,"path":"ife2016_task/task2/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task2/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-03-21T15:36:31.000Z","comments":true,"path":"ife2016_task/task3/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task3/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-27T10:17:15.000Z","comments":true,"path":"ife2016_task/task3/css/style-nmargin.css","permalink":"http://www.voyax.me/ife2016_task/task3/css/style-nmargin.css","excerpt":"","text":"html, body{ width: 100%; } header nav{ margin-left: 20px; } header nav li{ display: inline-block; margin-right: 20px; } nav li a.active{ color: red; } .container{ position: relative; height: 100%; min-width: 320px; padding: 20px; margin: 20px; overflow: hidden; border: #999; background: #eee; } img{ width: 80px; height: 80px; } .left-box, .center-box, .right-box{ padding: 20px; border: 1px solid #999; background: #fff; } .center-box{ float: left; margin-right: 140px; margin-left: 220px; } .left-box{ float: left; width: 158px; margin-left: -100%; } .left-box img{ float: left; } .left-box h2{ padding-left: 20px; overflow: hidden; } .right-box{ float: left; width: 78px; margin-left: -120px; }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-17T14:35:10.000Z","comments":true,"path":"ife2016_task/task3/css/style-bfc.css","permalink":"http://www.voyax.me/ife2016_task/task3/css/style-bfc.css","excerpt":"","text":"header nav{ margin-left: 20px; } header nav li{ display: inline-block; margin-right: 20px; } nav li a.active{ color: red; } .container{ margin:20px; border: #999; background: #eeeeee; overflow: hidden; padding: 20px; } img{ height: 80px; width: 80px; } .left-box,.center-box,.right-box{ border: 1px solid #999; padding: 20px; background: #fff; } .left-box{ float: left; width: 158px; margin-right: 20px; } .left-box img{ float: left; } .left-box h2{ overflow: hidden; padding-left: 20px; } .right-box{ float: right; width: 78px; margin-left: 20px; text-align: center; } .center-box{ overflow: hidden; }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-20T16:05:15.000Z","comments":true,"path":"ife2016_task/task4/css/style.css","permalink":"http://www.voyax.me/ife2016_task/task4/css/style.css","excerpt":"","text":"html,body,.container{ height: 100%; width: 100%; } .desc{ border-top: 1px dotted #aaa; padding: 20px; } .desc h2{ font-size: 24px; } .section{ /*height: 68%;*/ /*padding: 20%;*/ margin-bottom: 50px; } .box{ height: 400px; width: 80%; min-height: 200px; min-width: 400px; border: 1px solid #333; margin: 0 auto; } .center{ background: #cccccc; height: 200px; width: 400px; } .center:before, .center:after{ content: ''; position: absolute; border: 25px solid #ffcc00; } .center:before{ top: 0; left: 0px; border-bottom-right-radius: 100%; } .center:after{ bottom: 0px; right: 0px; border-top-left-radius: 100%; } /* 绝对定位 + 负边距 */ .box.position{ position: relative; } .position .center{ position: absolute; top: 50%; left: 50%; margin-left: -200px; margin-top: -100px; } /* 绝对定位 + translate(-50%,-50%) */ .box.transform{ position: relative; } .transform .center{ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); } /* flexbox */ .box.flexbox{ display: flex; justify-content: center; align-items: center; } .flexbox .center{ position: relative; }"},{"title":"","date":"2017-07-26T08:53:26.000Z","updated":"2016-04-20T09:53:55.000Z","comments":true,"path":"ife2016_task/task4/css/reset.css","permalink":"http://www.voyax.me/ife2016_task/task4/css/reset.css","excerpt":"","text":"/* YUI 3.18.1 (build f7e7bcb) Copyright 2014 Yahoo! Inc. All rights reserved. Licensed under the BSD License. http://yuilibrary.com/license/ */ html{color:#000;background:#FFF}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}legend{color:#000}#yui3-css-stamp.cssreset{display:none}"}],"posts":[{"title":"我的前端生涯第一阶段","slug":"我的前端生涯第一阶段","date":"2018-09-10T15:34:55.000Z","updated":"2018-09-10T16:24:41.885Z","comments":true,"path":"/posts/7263e5d3/","link":"","permalink":"http://www.voyax.meposts/7263e5d3/","excerpt":"最近一些朋友让我帮忙整理下前端的笔试和面试题目，我想了想，这些东西可能会派上用处，甚至拿到一个高薪高职，但是并不能让你内心踏实和平静。不知道大家有没有和我一样的感受，时常质疑自己目前的状态和学习路径；从15年毕业，我就开始做前端，除开创业的那一年多的时间，到现在，项目做了很多，但是深度和思考还是远远不够的。","text":"最近一些朋友让我帮忙整理下前端的笔试和面试题目，我想了想，这些东西可能会派上用处，甚至拿到一个高薪高职，但是并不能让你内心踏实和平静。不知道大家有没有和我一样的感受，时常质疑自己目前的状态和学习路径；从15年毕业，我就开始做前端，除开创业的那一年多的时间，到现在，项目做了很多，但是深度和思考还是远远不够的。 8月份的面试给了我一个很好的定位和发展规划，\b从毕业离开北京到深圳，很幸运几乎每一家面试的公司都成功拿到了 offer（例外是指百度，\b通过内推投了简历就没有了消息\b\b），但在今年之前，招聘岗位上凡是有“高级”、“资深”的，我都是没有胆量投的。我的成长速度很慢，到现在我才有勇气将自己前端的第一阶段做个了解，接下来一个多月总结完前端的基础知识后，要努力开始自己的第二阶段。 我的前端生涯第一阶段不会涉及框架内容，我本身也还停留在使用框架的表面上，没有对它的整体实现和难点做过系统的思考，这部分还是留到第二阶段比较恰当。第一阶段大致会总结\b以下内容： \b项目中如何优雅地组织 CSS \bJavaScript 语言的魅力（核心） 如果设计和管理 API 前端脚手架（其实想谈谈前端的架构） 其中 JavaScript 以《你不知道的 JavaScript》为参考，所以\b建议有时间的同学看原书不用看什么博客文章，看书其实能更快形成自己的知识体系。","categories":[{"name":"前端生涯","slug":"前端生涯","permalink":"http://www.voyax.me/categories/前端生涯/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"为众人抱薪者，不可使其扼于风霜","slug":"为众人抱薪者，不可使其扼于风霜","date":"2018-09-07T10:23:59.000Z","updated":"2018-09-09T15:50:18.606Z","comments":true,"path":"/posts/b8c62de9/","link":"","permalink":"http://www.voyax.meposts/b8c62de9/","excerpt":"标题与内容无关，“一切都是最好的安排”应该更符合内容，然而没关系的，文章标题或者说人生的终极意义，还是在于你我内心的感受。","text":"标题与内容无关，“一切都是最好的安排”应该更符合内容，然而没关系的，文章标题或者说人生的终极意义，还是在于你我内心的感受。 我喜欢阳光2018年7月13日到2018年8月25日，我始终没有胆量去面对已经发生的事情，以及一天一天迫近的生活；现在重新回到工作岗位，渴望着快速积淀，既要能保护自己也保护好自己的家人。 今年25了，3年前我曾说，争取25岁财富自由；如今却一贫如洗，还有一笔需要我去弥补的血汗钱。经历过这次事件，很难说心中还有光明，就像另外一个难有说的：“我现在想开了，踏踏实实活着吧，这个国家是没救了，但还得活着啊”，可能很悲观，但却都是无奈与心酸…… \b现在都还很清楚得记得，一位江西的老大爷，穿着老家干农活的衣服，背在一个大书包，在深圳的街头，和我们一起去报案，去请愿。我们问他，您书包里都是材料吗，他说，都是他一辈子的家当，现在，就剩这些纸了 一个多月的维权、上访，最后我心死了，政治和金融，不是我们普通老百姓所能触及以及预料的；很多所谓的为民服务的政策和保障，当你真正需要的一天，即使你像乞丐一样，卑躬屈膝，也遥不可及 也许，正如《我不是药神》结局程勇所说：“相信会越来越好的，希望这一天早一点到来”，在记住一些教训后，还是要保持善良的心对待身边的每一位辛苦工作的人，阳光积极地面对生活…… 工作的意义正好是暑假，我靠着信用卡把妈妈和妹妹从老家接到深圳；我爸从来没出过远门，无论忙还是闲，或者我给他说，我养得起我们家了你不用辛苦了，他总说着他出来玩家里生意就耽搁了。一年365天，都是起早贪黑，大年初一也从未\b休息 在异乡吃到\b妈妈做的饭菜是很幸福、满足的；\b有时候我在想，如果，如果我还有钱，她们本可以吃到老家没有的新鲜的海鲜，带妹妹去她一直想去的欢乐谷……后来妹妹告诉我，她们回到重庆的那天，妈和爸吵了一架，因为家里太忙，爸有时候脾气不太好。 那天后，我开始打起精神，准备面试开始找同学同事内推，当我足够优秀能够给家里足够的物质支持，这些问题都能解决了吧，爷爷奶奶也要保重好身体，我想带你们出来看看外面的生活 选择企业这次投的都是高级前端开发，很幸运，都拿到了 offer。最后我选择了一家发展更加稳健，规模更大，知名度更广，也不用拼命加班的公司；薪资其实比给的最高的那家差了很多，一年有接近 10w 的差距，当然在团队中的位置也有差距；只是他们16年成立，现在规模不算大，公司的产品生态我还是有一些忧虑，最后选择了放弃他们的信任和肯定。 每个公司都有自身的短板和优势，offer 的选择，其实每一个细节都可能改变自己的选择。如果从最后的结果来看，我希望我选择的企业应该至少满足下面的条件： 所在的行业合规，所研究的领域是目前或者未来3年内的热点而且是可以有产品落地的 不会在5年内倒闭，所以如果是创业公司，要慎重选择 技术团队很牛，适合自己扎根吸取养料和拓宽眼界 时薪有竞争力（中上），我不希望高工资是靠加班加出来的 存在感，无论你在哪，都需要相互信任和尊重，我渴望在一个相互信任的环境里竭尽全力","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"解剖 JavaScript 单线程","slug":"解剖-JavaScript-单线程","date":"2018-02-24T03:00:14.000Z","updated":"2018-03-05T16:29:57.222Z","comments":true,"path":"/posts/c28f3d08/","link":"","permalink":"http://www.voyax.meposts/c28f3d08/","excerpt":"\b\b人有九窍，\b窍窍缘心，九窍全通，遍体通泰，明心见性。 单线程是 JavaScript 的精髓之一，但是在初学以及\b大部分开发过程中，不懂单线程，貌似也不会遇到什么困难。这类原理性的东西，\b不懂也是能写代码的，但是懂了心里才有底，不至于写了上万行代码还是畏手畏脚。JavaScript 单线程涉及进程、线程的基本概念，浏览器架构、事件循环、异步机制…\b","text":"\b\b人有九窍，\b窍窍缘心，九窍全通，遍体通泰，明心见性。 单线程是 JavaScript 的精髓之一，但是在初学以及\b大部分开发过程中，不懂单线程，貌似也不会遇到什么困难。这类原理性的东西，\b不懂也是能写代码的，但是懂了心里才有底，不至于写了上万行代码还是畏手畏脚。JavaScript 单线程涉及进程、线程的基本概念，浏览器架构、事件循环、异步机制…\b 进程（process）和线程（thread）什么是进程 进程（process）是程序的一次执行，是系统进行资源分配和调度的一个独立单元。 理解进程的核心在于清楚进程所解决的问题： 操作系统是管理计算机硬件资源和软件资源的计算机软件，\b可以把操作系统想象为资源的统一抽象表示，资源包括内存、网络接口、文件系统等，可以被应用程序请求和访问，一旦操作系统为应用程序创建了这些资源的抽象表示，就必须管理它们的使用，例如一个操作系统可以允许资源共享和资源保护。 ——参考自《操作系统：精髓与设计原理》第3章 \b为有效地管理程序的执行，进程的概念被提出来，从而实现： 资源对多个应用程序是可用的 物理处理器在多个应用程序间切换以保证所有程序都在执行中 处理器和 I/O 设备能得到充分利用 进程的出现是为了解决程序执行中，资源的共享和充分利用。一个进程的组成包括了： 程序代码 和代码像关联的数据集 PC中的值，用来指示下一条将运行的指令 一组通用的寄存器的当前值，堆、栈；， 一组系统资源 一个 CPU 任何时间内仅能运营一个进程，但即使你是单核计算机你会发现你依然能同时跑多个程序，这就涉及到进程控制，进程控制的主要任务是创建、撤销进程，以及实现进程的状态转换，所以我们会说进程是动态的，因创建而生，因调度而执行，因无资源而暂停，因撤销而消亡。 线程 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 进程和线程都是 CPU 时间段的描述，只不过进程的颗粒读更大。\b 以一个音乐播放器为例，我们启动程序：加载上下文环境（资源分配）➡ 执行。这就是我们所说的创建-执行一个进程。但是这个程序里边，实际包含了多个模块：(a) read 从音频文件读取数据；(b) decompress 对数据进行压缩；(c) play 播放音频数据。这三者同样也是加载上下文 ➡ 执行 ➡ 保存上下文 ➡ 调入下一个任务的上下文，但是在执行过程中，共享包含它们的进程的上下文。 学术性的对比： 一个进程可以拥有多个线程，而一个线程同时只能被一个进程所拥有。 进程是资源分配的基本单位，线程是处理机调度的基本单位，所有的线程共享其所属进程的所有资源与代码。 线程执行过程之中很容易进行协作同步，而进程需要通过消息通信进行同步。 线程的划分尺度更小，并发性更高。 线程共享进程的数据的同时，有自己私有的的堆栈。 线程不能单独执行，但是每一个线程都有程序的入口 执行序列以及程序出口。它必须组成进程才能被执行。 JavaScript 单线程到底指什么JavaScript 单线程说白一点，是指在任一\b时间内只能执行一条指令，这个线程被称为 主线程， HTML5 提供的 web worker 虽然可以让浏览器新开一个线程，用于执行复杂耗时的计算任务，与主线程独立执行，通过 postMessage 和 onMessage 进行通信，但是它不能操作 DOM 节点。本质上来讲，JavaScript 仍是单线程的。 我们说多线程的出现是为了充分调度资源提升效率，然而你会\b发现不管 Node 还是浏览器都保持 JavaScript 单线程的特点。（个人认为 JavaScript 语言本身并不包含线程的机制，准确的表述是执行环境 Runtime 的机制，此处我如果理解有错误，希望大家不吝指证）\b。 采用单线程我认为最主要原因还是\b\b为了简单，对 DOM 节点的操作能保证不会存在歧义。 写到这儿，想到鸡生蛋和蛋生鸡的问题，JavaScript 和其宿主环境竟也是如此相似，JavaScript 最初随 Netscape Navigator 2.0 \b一起发布（当时还叫 LiveScript），伴随着浏览器的发展，JavaScript 也不断演进，\bv8 引擎的优化和 JavaScript 在事件处理上的成熟迎来了服务端的 Node。不禁让人感叹任何事物从低级到高级进化的耐心和伟大，人的可怕之处，可能正是这种不断吸取、发展的能力。（附上“Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系”。 ） 来源: 朴灵. 《深入浅出Node.js》 浏览器是多线程的浏览器一般有以下7个常驻线程： GUI 渲染线程 GUI渲染线程负责渲染浏览器界面HTML元素，当界面需要重绘(Repaint)或由于某种操作引发回流(Reflow)时，该线程就会执行。GUI 渲染线程与 JavaScript \b引擎线程互斥，在 JavaScript引擎运行脚本期间，GUI渲染线程被挂起，GUI 更新\b\b被保存在一个队列中等待JavaS\bcript 引擎线程空闲时立即被执行。正是这样，JavaScript 的运行会阻塞页面的加载。 \b试想，如果二者不是互斥的，当页面正在渲染时，JavaScript 恰巧\b更新了正在渲染的 DOM \b元素，那就存在冲突了。要么制定一个逻辑策略，要么采用目前这种更为单一和稳健的方式。（简单并不一定是为了偷懒，更\b多的\b情况是保证稳健，我们写代码也是一样，需要学会将复杂逻辑拆分成简单的逻辑） JavaScript 引擎线程 也称 JavaScript 内核，负责解析和执行 JavaScript 代码。例如我们熟悉的 V8 引擎。 定时触发器线程 浏览器定时计数器 (\bsetTimeout, setInterval, setImmediate) 并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。 这里可以理解为何我们的计数器\b会有延迟：当到达指定时间（通过事件循环不断检测事件实现），产生一个 timeout 事件， 定时器就会将相应的回调函数插入任务队列尾部，真正的执行需要等到所有同步任务完成且任务队列之前的任务都被执行。 (function testSetTimeout() { const label = &#39;setTimeout&#39;; console.time(label); setTimeout(() =&gt; { console.timeEnd(label); }, 10); for(let i = 0; i &lt; 100000000; i++) {} })(); 输出结果：setTimeout: 70.490966796875ms 异步 http 请求线程 XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到任务队列中等待处理。 \b事件触发线程 \b当一个事件被触发时该线程会把事件添加到事件队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。 此节内容参考自浏览器进程？线程？傻傻分不清楚！ 浏览器内核平时我们说的浏览器内核到底是指什么，JS 引擎还是视图渲染？ 网上关于浏览器内核的解释大多不严谨，需要理解透彻可能需要去看一本转本将 Webkit 之类的书，这先埋个坑，等读完再进行梳理。下面是一个目前我最为赞同的说法： 浏览器有一个重要的模块，它主要的作用是将页面变成可视（听）化的图形、音频结果，这就是浏览器内核。不同浏览器有不同内核，常用的有Trident（IE）、Gecko（Firefox）、Blink（Chrome）、Webkit（Safari） 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指 渲染引擎。 JavaScript Runtime 和 EventLoop JavaScript 是通过 Event loop （事件循环）实现异步。主线程一运行就会创建 Stack、Heap、Queue（Stack 中是主线程正在执行的任务，后进先出 LIFO。Queue 是等待处理的任务队列，先入先出FIFO），依次执行 stack 中的任务，遇到异步任务，就丢到任务队列中，当 stack 为空，就从 Queue 中读取任务执行。这是一个不断循环的过程，而且我们的任务队列实际是一个事件队列；对于一个事件驱动的系统，一切事物都被抽象为事件，代码的执行、鼠标的操作、网络请求状态的变化以及定时器到达指定事件等等都是事件，理解了这些你就懂了为什么叫 Event loop。 整个代码执行的机制和流程推荐观看 Philip Roberts: Help, I’m stuck in an event-loop. 最后简单说下 watcher 观察者，watcher 是事件驱动系统中很重要的概念，我们刚一直所有个事件队列 Queue，然而并不是说所有的事件都放在一个队列中。不同的事件放在不同的队列中，并设置相应的 watcher，对于没有的事件，自然就不会有watcher。事件循环实际上就是调用 watcher，检查每个 watcher 的事件队列，处理完相应事件后，再进入下一个 watcher。盗图一张： 参考资料 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop 【转向Javascript系列】从setTimeout说事件循环模型 chrome浏览器页面渲染工作原理浅析 Concurrency model and Event Loop","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.voyax.me/tags/JavaScript/"}]},{"title":"2017.11 前端阅读清单","slug":"2017-11-阅读清单","date":"2017-11-08T01:16:59.000Z","updated":"2017-11-23T06:38:55.193Z","comments":true,"path":"/posts/c7f12724/","link":"","permalink":"http://www.voyax.meposts/c7f12724/","excerpt":"","text":"Front-End-Checklist 在前端的实际开发中，我们除了完成业务逻辑，还需要注意注意的一些规范和技巧，大致瞄了一眼，内容不难，却是一份很好的帮助很多开发者完善前端基础知识体系的指南 Essential Image Optimization 对前端来说，图片优化是个老生常谈的问题，但是我见过的绝大部分前端对这个问题深入的很少（这个图片好像太大了哦，找个压缩工具压缩一下吧……），这篇文章非常全面的讲解了图片优化的问题，包括 seo 的处理，干货很多 ​","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"Git ignorecase in Case-sensitive system","slug":"Git-ignore-case","date":"2017-10-14T16:23:00.000Z","updated":"2017-11-08T01:53:03.530Z","comments":true,"path":"/posts/c43b2a26/","link":"","permalink":"http://www.voyax.meposts/c43b2a26/","excerpt":"","text":"晚上10点多公司的妹子发了张截图给我（妹子这么刻苦让我汗颜。。。），在我们的 git 仓库中，存在几对仅文件名大小写有区别，内容完全一样的文件。原因很容易想到——重命名。这个问题比较小一般也不容易出现，不过其实花时间想想也蛮有意思。 case-insensitive file system 不同的文件系统对大小写是否敏感策略是不同的，以 macOS 为例, 最新的 HFS+ 和 APFS 默认大小写不敏感： APFS accepts only valid UTF-8 encoded filenames for creation, and preserves both case and normalization of the filename on disk in all variants. APFS, like HFS+, is case-sensitive on iOS and is available in case-sensitive and case-insensitive variants on macOS, with case-insensitive being the default. In macOS High Sierra, APFS is normalization-insensitive in both the case-insensitive and case-sensitive variants, using a hash-based native normalization scheme. In iOS 11, APFS is normalization-insensitive as well, using either a native normalization scheme (erase restores only) or runtime normalization scheme (upgrades from previous versions). Runtime normalization will also be available in iOS 10.3.3 and macOS Sierra 10.12.6. Being normalization-insensitive ensures that normalization variants of a filename cannot be created in the same directory, and that a filename can be found with any of its normalization variants. This means that developers don’t need to do any additional work to ensure correct normalization behavior in these versions of macOS and iOS. How does Apple File System handle filenames? 默认情况下，windows 和 mac 的文件系统都是大小写不敏感的。需要说明的是，我们的大小写敏感实际关系到的是所使用的 文件系统。 core.ignorecase If true, this option enables various workarounds to enable git to work better on filesystems that are not case sensitive, like FAT. For example, if a directory listing finds makefile when git expects Makefile, git will assume it is really the same file, and continue to remember it as Makefile. git config documentation","categories":[],"tags":[]},{"title":"React 学习路径推荐","slug":"React 学习路径","date":"2017-09-25T11:28:49.000Z","updated":"2017-10-14T16:39:58.941Z","comments":true,"path":"/posts/45ab96e1/","link":"","permalink":"http://www.voyax.meposts/45ab96e1/","excerpt":"如果一门技术久了不用，等再回头学的时候，有可能比学习新技术更难受。 前端变化很快，除了快速跟上新的技术栈，还需要避免重复学习的浪费。最近因公司业务重学 React，还是有不少教训需要谨记：","text":"如果一门技术久了不用，等再回头学的时候，有可能比学习新技术更难受。 前端变化很快，除了快速跟上新的技术栈，还需要避免重复学习的浪费。最近因公司业务重学 React，还是有不少教训需要谨记： 耐心看懂原理以及官方文档 原理这东西需要花大量时间去扣，你不用着急和畏惧，硬着头皮看完文档比你到处去网上看一知半解的教程来得更快。而且回报很值得，这是个滚雪球的过程。 一定要从头写一个完整 demo 去年我用 react native 写了个创业的小 demo，但是项目比较小也比较简单，更不用说后期优化，所以对现在帮助几乎为零。如果没有完整走完一个企业级的项目，我不觉得真的掌握这个技术栈的方方面面（只是单纯了解或者喜欢某个技术不用在意），所以学完一定要能熟练写个项目。 怎么写 demo 在 github 找一个 star 比较多的项目，然后看他的效果，自己从头写，遇到问题了再去看别人的代码 上边这些其实是个伪理论，不同人学习方式不同。下边推荐 React 的学习路径： React 学习路径推荐 React 小书 除了官网文档，你的第一份阅读材料，相比于很多教程要么解释文档要么上代码，这个教程可以帮你解决初学者的疑问和困惑，而且实战也不错 在 2017 年学习 React + Redux 的一些建议 一共有上、中、下三节内容，帮你对 react 生态圈有比较全面的了解，在看完小书后，提升对项目的整体把控 写个 demo github 上有不少实战，你可以随意挑，注意选目前最新版本的","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://www.voyax.me/tags/React/"}]},{"title":"反向代理","slug":"反向代理","date":"2017-09-20T13:11:35.000Z","updated":"2017-09-25T12:00:24.000Z","comments":true,"path":"/posts/26b440f2/","link":"","permalink":"http://www.voyax.meposts/26b440f2/","excerpt":"代理（Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。——维基百科","text":"代理（Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。——维基百科 为了能快速理解反向代理，我先简单说下服务器中的负载均衡： 负载均衡是一种网络服务，要解决的是计算机资源最优化使用的问题。最常见的应用是利用多台服务器提供单一服务，这样就可以避免过载，实现快速响应。 而这里我们的单一服务就是所谓的 “反向代理”。它本身不提供服务，真正的服务是由背后的许多服务器来提供，但对用户而言，他们只知道这个“单一服务”的存在，而不知道背后具体提供服务的是谁，像不像总统背后藏了个智囊团…… 反向代理举例 访问 example.com，但是很可惜 example.com 没有资源。example.com 说没关系啊，我去 找真的web server 把数据拿下来，返回给你。 这里 example.com 就是一个反向代理。用户只知道我访问的是 example.com，是它提供的数据，并不知道 web server 的存在。 正向代理举例 如果是正向代理（或者叫前向代理），就稍微有些不同了： 在国内我们无法访问 google.com，这时候你就买了一个美国的服务器做梯子并在本地做好相应配置。当你访问 google.com ，发现就可以访问了。这时候你的那个美国服务器就是正向代理，它帮你把 google 的内容下载下来，返回给你，让你以为是你访问的 google。 Caddy 配置反向代理对 Caddy 不了解的同学，出门左转看 Caddy 快速实践。 我们起多个 node 服务，使用 Caddy 作为反向代理： voyax.me { proxy /app localhost:8000 { without /app log ../log/proxy-port-8000.log } proxy /api localhost:8080 { without /api log ../log/proxy-port-8080.log } }","categories":[],"tags":[]},{"title":"Caddy 快速实践","slug":"Caddy 快速实践","date":"2017-09-20T12:10:23.000Z","updated":"2017-09-20T12:46:07.000Z","comments":true,"path":"/posts/e38a6063/","link":"","permalink":"http://www.voyax.meposts/e38a6063/","excerpt":"Caddy 是一个可以真的非常方便安装、配置以及运行的 web 服务器，相比 Nginx 或者 Apache，Caddy 更适合我们快速搭建 web 服务器，可适合绝大大数项目需求。","text":"Caddy 是一个可以真的非常方便安装、配置以及运行的 web 服务器，相比 Nginx 或者 Apache，Caddy 更适合我们快速搭建 web 服务器，可适合绝大大数项目需求。 本地只用 Caddy作为开发人员，我更关心开发效率，服务器等环境的部署确实不是擅长的，经常配置一个 Nginx 即使照着教程操作还是会出现各种莫名其妙的问题，或者一段时间后，发现 Nginx 竟然起不起来，网上还是各种不靠谱的 “解决方案”…… 相对于 Nginx 和 Apache，Caddy 简单很多，而且没有任何外部依赖，一个配置文件搞定。这是在开发中最为关注的点： 简单，无需花多余经历 无依赖 反向代理 支持虚拟主机 使用 HTTP/2 自动生成和更新 ssl 证书 支持各平台，安装简单 具体还有哪些特性移步官网文档，Gaddy 还支持插件扩展，github 上也很活跃，前景看好，可以放心使用😉 安装# mac brew install caddy 可以直接从官网下载安装，下载的文件中还有一个 init 文件夹，里边有基本的配置 demo 现在在任意一个目录下新建一个 index.html 文件，运行 caddy： mkdir temp touch index.html vim index.html 保存，然后运行 caddy： caddy 访问 localhost:2015 你可以看到服务器已经正常启动了 caddy 服务器配置caddy 可以通过命令行传参也可通过 Caddyfile 进行配置，比如我们指定域名和端口： caddy -host localhost:8000 通过 Caddyfile 配置： touch Caddyfile vim Caddyfile Caddyfile 文件内容： localhost:8000 Caddyfile 文件caddy 默认将当前目录下的 Caddyfile 作为配置文件，通过 -conf 指定配置文件路径： caddy -conf ../path/to/Caddyfile 文件格式Caddyfile 是一个纯文本文件，由 地址 和指令 组成，看个复杂点的例子： localhost gzip tls self_signed # 自签发证书 proxy /api 127.0.0.1:7005 # 反向代理 log /var/log/caddy/access.log header /api { Access-Control-Allow-Origin * Access-Control-Allow-Methods &quot;GET, POST, OPTIONS&quot; -Server } 第一行是地址，之后就是指令了，如果一条指令有多个参数需要换行，用 {} 括起来就好，完整指令及解释请查看 文档 多站点配置如果需要在一个 caddy 服务中启动多个站点，需要在域名后边加上 {}，将指令写到 {} 中： mysite.com { root /www/mysite.com } sub.mysite.com { root /www/sub.mysite.com gzip log ../access.log } 如果这两个站点有通用的配置： mysite.com, sub.mysite.com { gzip … } 很简单是吧，另外，Caddyfile 中使用环境变量也是可以的。 Mac 环境配置先去 下载 .plist 文件，这是 mac 下的定时任务配置文件（未防口误，说明一下，是一个具体事件对应一个 .plist） 开机启动cp ~/Download/com.caddyserver.web.plist /usr/local/opt/caddy/ ln -sfv /usr/local/opt/caddy/*.plist ~/Library/LaunchAgents 基本配置mkdir -p /usr/local/etc/caddy /usr/local/etc/ssl/caddy /var/log/caddy touch /usr/local/opt/caddy/Caddyfile sudo chown -R _www:_www /usr/local/etc/caddy /var/log/caddy sudo chmod 0750 /usr/local/etc/ssl/caddy 自定义配置文件修改 Caddyfile： sudo vim /usr/local/etc/caddy/Caddyfile http://localhost { root /var/www } 修改 .plist 文件 因为是用 brew 安装，和官网上的配置有所差异，修改 .plist 文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;Caddy&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/caddy&lt;/string&gt; &lt;string&gt;-agree&lt;/string&gt; &lt;string&gt;-conf&lt;/string&gt; &lt;string&gt;/usr/local/etc/caddy/Caddyfile&lt;/string&gt; &lt;string&gt;-root&lt;/string&gt; &lt;string&gt;/var/www&lt;/string&gt; &lt;/array&gt; &lt;key&gt;EnvironmentVariables&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CADDYPATH&lt;/key&gt; &lt;string&gt;/usr/local/etc/ssl/caddy&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;root&lt;/string&gt; &lt;key&gt;GroupName&lt;/key&gt; &lt;string&gt;wheel&lt;/string&gt; &lt;key&gt;InitGroups&lt;/key&gt; &lt;true/&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Crashed&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;SoftResourceLimits&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NumberOfFiles&lt;/key&gt; &lt;integer&gt;8192&lt;/integer&gt; &lt;/dict&gt; &lt;key&gt;HardResourceLimits&lt;/key&gt; &lt;dict/&gt; &lt;key&gt;WorkingDirectory&lt;/key&gt; &lt;string&gt;/usr/local/etc/ssl/caddy&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/var/log/caddy/error.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/var/log/caddy/info.log&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; 启动、停止、重启服务用 brew 安装的一个极大便利就是可以直接使用 brew services： # start brew services start caddy # stop brew services stop caddy # restart brew services restart caddy 上线项目还请换回 nginxcaddy 虽然简单，但也还是有自身的问题。 商业项目需要支付授权 资源占用多，高并非下表现和nginx还是存在较大差距 具体可参考：Caddy HTTP/2 server &amp; benchmarks：","categories":[],"tags":[]},{"title":"CSS 小白知识点－布局","slug":"CSS-小白知识点－布局","date":"2017-07-26T07:37:56.000Z","updated":"2017-09-18T06:07:48.000Z","comments":true,"path":"/posts/5a12aef0/","link":"","permalink":"http://www.voyax.meposts/5a12aef0/","excerpt":"过年那天写的，写了一半出去玩了，没写完，啦啦啦 display**在去Google 块级元素、行内元素有什么区别之前，先搞明白CSS中的display，display是控制布局的关键，所有元素以什么样的角色展现，都是由display来控制的。","text":"过年那天写的，写了一半出去玩了，没写完，啦啦啦 display**在去Google 块级元素、行内元素有什么区别之前，先搞明白CSS中的display，display是控制布局的关键，所有元素以什么样的角色展现，都是由display来控制的。 The display CSS property specifies the type of rendering box used for an element. In HTML, default display property values are taken from behaviors described in the HTML specifications or from the browser/user default stylesheet. The default value in XML is inline.——MDN/CSS/display 我们说过，页面中的每个元素都是一个盒子，但盒子也分不同的类型，block、inline，就是大多数元素的默认类型。元素以什么样的方式展现出来，不是根据它是什么元素，而是由display属性决定。 举例说明——块级元素、行内元素常说的块级元素和行内元素实际包含两个方面： HTML的嵌套规则 一般块级元素可以包含行内元素和其他块级元素，而行内元素内不可嵌套块级元素 用户代理默认display属性值 W3C为元素指定了默认的display值，用户代理（浏览器）根据W3C的标准，实现默认的样式规则。 W3C标准： 浏览器默认样式 注： HTML5中已经没有行内元素和块级元素的概念，详细参见Content categories，块级元素大致相当于HTML5中的Flow Elements，行内元素相当于Phrasing Elements 总结 元素以什么样的盒子渲染，是通过display属性控制，而非元素类型 浏览器默认样式为每个元素设置了display默认值 display默认值是inline（比如，某些浏览器不认识HTML5中的标签，这些元素的display属性值就很悲剧都成inline了） 通过display仅仅是改变元素的显示方式，并非改变元素类型 display还有很多属性值，感兴趣的参看MDN display章节 Block, inline, inline-block这三个属性值是布局中无论如何你都避免不了的，看看它们的区别，分别看看一个p标签display属性值为block，inline，inline-block的区别： HTML &lt;body&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签：&lt;p&gt;display: block&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签，display设置为inline：&lt;p class=&quot;inline&quot;&gt;display: inline;&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签，display设置为inline-block：&lt;p class=&quot;inline-block&quot;&gt;display: inline-block&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;/body&gt; CSS div{ margin-bottom: 3em; border: 1px dotted #77C2D4; } p{ height: 2em; width: 50%; margin-top: 1em; padding: 0 1em; border: 1px dotted #F9454E; } .inline{ display: inline; } .inline-block{ display: inline-block; } 效果图 第一个p标签，默认是block。height，width，margin-top，padding-left均有效，单独占一行，注意它的margin-left/right和width的关系！ 第二个p标签，dislplay: inline。height，width，margin-top都无效了 第三个p标签，display: inline-block。一切正常，而且不换行 block, inline, inline-block 总结block （默认）宽度：等于父元素content的宽度 （默认）高度：由子元素高度确定 width、height 可设置 单独占一行 inline 设置width和height无效 margin和padding 垂直方向上设置无效 只要宽度足够，从左往右（对于从左往右阅读的语言）挨个排列 inline-block inline-block继承了inline和block的特点，W3chools的总结简直完美： An inline-block element is placed as an inline element (on the same line as adjacent content), but it behaves as a block element. 可设置width和height margin和padding垂直方向上有效 不换行 The Display Declaration这篇文章有更多的display属性的演示和说明","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"CSS 小白知识点－盒模型","slug":"CSS-小白知识点－盒模型","date":"2017-07-26T07:37:43.000Z","updated":"2017-07-26T07:56:10.000Z","comments":true,"path":"/posts/d875308f/","link":"","permalink":"http://www.voyax.meposts/d875308f/","excerpt":"CSS假定每个元素都会生成一个或者多个矩形框，这称为元素框（规范的将来版本可能允许非矩形框，不过对现在来说，框都是矩形的）。各元素框中心有一个内容区（content area）。这个内容区周围有可选的内边框、边框和外边框。——《CSS权威指南》 任何一个页面，都是由一个一个的盒子构成；而每个元素，其实都是一个矩形盒子，也就是所谓的盒模型；所以，写一个页面，无非就是把这些盒子按照一定方式进行排列，是不很简单——凡是都是盒子 以Google的开发者网站来展示：","text":"CSS假定每个元素都会生成一个或者多个矩形框，这称为元素框（规范的将来版本可能允许非矩形框，不过对现在来说，框都是矩形的）。各元素框中心有一个内容区（content area）。这个内容区周围有可选的内边框、边框和外边框。——《CSS权威指南》 任何一个页面，都是由一个一个的盒子构成；而每个元素，其实都是一个矩形盒子，也就是所谓的盒模型；所以，写一个页面，无非就是把这些盒子按照一定方式进行排列，是不很简单——凡是都是盒子 以Google的开发者网站来展示： 先拆分成两个大盒子（红色虚线标准），然后在每个大盒子中又包括很多小盒子（你看，文字也是由矩形框包围起来的），把这些盒子进行布局排版，再加上视觉效果，这个页面就可以写出来了。 盒模型基本结构扯了这么多，具体看看一个盒子是怎么样的： 一个盒子，从内到外，分别是content(内容区域)、padding内边距、border(边框)、margin(外边距)； 而 padding , border , margin 都可以对 top, right,bottom,left4个方向单独进行设置。 .box{ height: 300px; /* content 高度 */ width: 300px; /* content 宽度 */ border: 1px solid #333; /* 上下左右都是1px的边框，颜色为#333的实线 */ margin-top: 80px; /* 仅设置 margin top */ padding: 40px; /* 上下左右都是 40px padding */ } 具体说下padding,margin四个方向的设置： .box{ margin-top: 25px; margin-bottom: 25px; margin-left: 40px; margin-right: 40px; } 等同于 .box{ margin: 25px 40px; } 等同于 .box{ margin: 25px 40px 25px 40px; } 看明白了呗，设置padding或者margin的上下左右四个值，你可以单独用 padding/margin-top,padding/margin-bottom,padding/margin-left,padding/margin-right 有时候也可以直接为padding/margin设置4个值（顺序固定），从top顺时针绕一圈： padding/margin: top right bottom left 还可以为padding, margin指定少于4个值，规则如下 如果缺少左外边距，则使用右外边距如果缺少下外边距，则使用上外边距如果缺少右外边距，则使用上外边距 padding和margin的区别为了便于理解，你可以认为，margin是不属于这个盒子的，仅仅是为了占据空间；而padding是作为盒子的一部分。 从视觉上来讲padding的颜色是跟背景色一样的，所以你给元素设置了背景色，padding也会受影响；而margin永远都透明的。 从实践来看 margin和padding都可以用来把盒子和盒子分开 但是padding还可以把内容和border分开 margin存在Margin Collapse的特点，padding不会存在 Margin Collapse`深入的内容，参看透析Margin Collapsing 建议：实际开发看着办就好，只要保持用margin和padding使用习惯上的统一就OK 更多关于margin和padding的讨论，参见 When to use margin vs padding in CSS Box Sizing写 CSS 的时候，在 margin、padding、border存在的情况下，盒子实际占据的空间可能和预期不同，我们需要确定在 CSS 中 width，height 到底是包含哪些部分（content, padding, margin, border），具体的计算规则由 box-sizing 指定。 已知一个盒子的规则如下： .box{ width: 300px; height: 200px; padding: 5px; border: 2px solid; } 问：这个盒子实际占据空间多大？ 正确的计算如下：实际占据空间宽度 = width(300) + padding-left(5) + padding-right(5) + border-left(2) + border-right(2) = 314px content-box我们的盒子的box-sizing默认值是content-box：height和width仅仅是content的高度和宽度，并不包括padding和border。所以你在考虑这个盒子占用的空间时，需要手动算上padding和border。 有时候莫名其妙水平方向有了滚动条、或则父元素宽度不够，都是因为忽略了padding和border的宽度。 下边的这个列子会因为border的存在而出现滚动条： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html, body{ width: 100%; height: 100%; } .box{ border-left: 2px; width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;Content Box&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; border-box如果将box-sizing设置为border-box，高度和宽度就会包含padding和border，这样才符合我们的习惯。 修改上面的例子，避免出现滚动条，设置成border-box就好了： .box{ box-sizing: border-box; } box-sizing 实战应用为了避免不必要的麻烦，建议将所有元素都设置成border-box，推荐写法： html { box-sizing: border-box; } *, *:before, *:after{ box-sizing: inherit; } 注意，是通过为根元素html设置border-box，其他元素继承实现的，而不是像这样： * { box-sizing: border-box; } 想想区别在哪，有啥好处 解释在这：box-sizing best practices display不管是 div 也好， a 标签也好，在页面中都是一个盒模型的实例，但每个盒子因为 display属性不同，又可以分为不同的类别（inline, block, inline-block, table 等），在排版上有各自的特点。 The display CSS property specifies the type of rendering box used for an element. In HTML, default display property values are taken from behaviors described in the HTML specifications or from the browser/user default stylesheet. The default value in XML is inline.——MDN/CSS/display 我们说过，页面中的每个元素都是一个盒子，block、inline 是大多数元素的默认类型。元素以什么样的方式展现出来，不是根据它是什么元素，而是由display属性决定。 举例说明——块级元素、行内元素 常说的块级元素和行内元素实际包含两个方面： HTML的嵌套规则 一般块级元素可以包含行内元素和其他块级元素，而行内元素内不可嵌套块级元素 用户代理默认display属性值 W3C为元素指定了默认的display值，用户代理（浏览器）根据W3C的标准，实现默认的样式规则。 W3C标准： 浏览器默认样式 注： HTML5中已经没有行内元素和块级元素的概念，详细参见Content categories，块级元素大致相当于HTML5中的Flow Elements，行内元素相当于Phrasing Elements display 总结 元素以什么样的盒子渲染，是通过display属性控制，而非标签类型 浏览器默认样式为每个元素设置了display默认值 display默认值是inline（比如，某些浏览器不认识HTML5中的标签，这些元素的display属性值就很悲剧都成inline了） 通过display仅仅是改变元素的显示方式，并未改变标签类型 display还有很多属性值，感兴趣的参看MDN display章节 block, inline, inline-block 区别display 明白后，再看下 block, inline, inline-block 各自特点。 我们为 p 标签设置不同的 display 属性： HTML &lt;body&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签：&lt;p&gt;display: block&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签，display设置为inline：&lt;p class=&quot;inline&quot;&gt;display: inline;&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;div&gt; block, inline, inline-block举例：接下来是一个p标签，display设置为inline-block：&lt;p class=&quot;inline-block&quot;&gt;display: inline-block&lt;/p&gt;，这是p标签之后的内容。 &lt;/div&gt; &lt;/body&gt; CSS div{ margin-bottom: 3em; border: 1px dotted #77C2D4; } p{ height: 2em; width: 50%; margin-top: 1em; padding: 0 1em; border: 1px dotted #F9454E; } .inline{ display: inline; } .inline-block{ display: inline-block; } 效果图 第一个p标签，默认是block。height，width，margin-top，padding-left均有效，单独占一行，注意它的margin-left/right和width的关系！ 第二个p标签，dislplay: inline。height，width，margin-top都无效了 第三个p标签，display: inline-block。一切正常，而且不换行 block, inline, inline-block 总结 block （默认）宽度：等于父元素content的宽度 （默认）高度：由子元素高度确定 width、height 可设置 单独占一行 inline 设置width和height无效 margin和padding 垂直方向上设置无效 只要宽度足够，从左往右（对于从左往右阅读的语言）挨个排列 inline-block inline-block继承了inline和block的特点，W3chools的总结简直完美： An inline-block element is placed as an inline element (on the same line as adjacent content), but it behaves as a block element. 可设置width和height margin和padding垂直方向上有效 不换行 The Display Declaration这篇文章有更多的display属性的演示和说明 挑战一下搞懂 display 和 block, inline, inline-block 后，很多页面你都可以完成了。实现Google开发者网站我们的截图部分： 建议你拿我们最开始举例的Google开发者网站练手，要求如下： 不允许用浮动 你要解决 inline-block 可能出现的空白问题 我这不直接贴代码了，如果实现有问题或者需要参考的，直接联系我就好了","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"CSS第三课 栅格系统","slug":"CSS第三课-栅格系统","date":"2017-07-26T07:30:57.000Z","updated":"2017-07-26T07:56:15.000Z","comments":true,"path":"/posts/9e545f56/","link":"","permalink":"http://www.voyax.meposts/9e545f56/","excerpt":"这一节内容我自己都觉得比较鸡肋，就当捧个场$_$，感兴趣的完全可以自行参考 uikit 和 bootstrap 的实现，以及二者的差异。 实现自己的栅格系统，实现响应式布局 利用栅格系统，完成设计稿的第二块区域。学有余力的同学，可以尝试再用inline-block实现。","text":"这一节内容我自己都觉得比较鸡肋，就当捧个场$_$，感兴趣的完全可以自行参考 uikit 和 bootstrap 的实现，以及二者的差异。 实现自己的栅格系统，实现响应式布局 利用栅格系统，完成设计稿的第二块区域。学有余力的同学，可以尝试再用inline-block实现。 编写HTML&lt;section&gt; &lt;div class = &quot;container text-center&quot;&gt; &lt;header class = &quot;section__header&quot;&gt; &lt;h2&gt;WHY USE OUR PLATFORM&lt;/h2&gt; &lt;/header&gt; &lt;ul class = &quot;list-nostyle row&quot;&gt; &lt;li class = &quot;media--left col-md-4&quot;&gt; &lt;img src = &quot;&quot;&gt; &lt;div class = &quot;media__body&quot;&gt; &lt;h3 class = &quot;media__heading&quot;&gt;……&lt;/h3&gt; &lt;p&gt;……&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; …… &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; 栅格系统 栅格系统的作用在于： 快速布局 可重用 响应式设计 如果用过Bootstrap，你就知道，Bootstrap采用了12列的栅格。其实你完全可以自由设计栅格的列数，12、16、24等等都是可以。 但是，你可能需要关注，960这个数字，很多网站默认的宽度都是960px： 之所以选择960是因为绝大多数显示器都是1024宽，那为了避免出现水平方向的滚动条，那就会采用一个比1024窄一点的宽度，而960正可以被很多数整除： 1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 16, 20, 24, 30, 32, 40, 48, 60, 64, 80, 96, 120, 160, 192, 240, 320, 480, 960 对于布局来说，你可以选择更多的比例。 如果我们选择1000，相对就不是那么方便了： 1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000 现在我们来写一个栅格系统： 栅格系统的基本结构在进行排版时，需要对水平轴划分，将相应的内容放到之前规划的位置。这就是我们看到的row（行）和column（列），column作为row的子元素； html结构： &lt;div class = &quot;row&quot;&gt; &lt;div class = &quot;col-x&quot;&gt; &lt;/div&gt; &lt;/div&gt; 有的栅格系统还会用一个container将row包裹起来，这不是必须的，如果你没有特殊的需求，放心大胆的直接用row和column。在bootstrap中，row需要被container包裹，看下源码，想想为什么Bootstrap这么设计： .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } .row { margin-right: -15px; margin-left: -15px; } 定义列Column我们这里采用12列的栅格系统，行用.row来控制，列column我们参考Bootstrap的命名，col-md-x。 其中，x代表1~12的数字，xs,sm,md,lg匹配不同屏幕大小： 采用float： [class ^= &quot;col-&quot;]{ float: left; list-style: none; } .col-md-12{ width: 100%; } .col-md-11{ width: 91.66666667%; } .col-md-10{ width: 83.33333333%; } .col-md-9{ width: 75%; } .col-md-8{ width: 66.66666667%; } .col-md-7{ width: 58.33333333%; } .col-md-6{ width: 50%; } .col-md-5{ width: 41.66666667%; } .col-md-4{ width: 33.33333333%; } .col-md-3{ width: 25%; } .col-md-2{ width: 16.66666667%; } .col-md-1{ width: .083333333%; } 对所有的col都添加了list-style: none，兼容&lt;li&gt;的情况。 清除浮动这次我们采用clearfix实现： .row:before, .row:after{ content: &#39;&#39;; display: block; } .row:after{ clear: both; } 完善栅格现在你已经可以使用栅格系统完成布局了： 但是还有两点需要处理： 在栅格之间增加间隔：我们很多时候都需要栅格之间要有一定间隔，而不是两个紧挨着。 移动适配：我们的布局应该能适应不同屏幕的大小 增加间隔 并不是所有的栅格之间都需要间隔，所以没有间隔的栅格也是需要保留的。那就新增一个类来控制有间隔的栅格： .row-divider &gt; *{ padding-right: 1.6%; padding-left: 1.6%; } 为了避免重新计算宽度所占的百分比，这里我们使用了padding。 移动适配 可以采用两种实现方案，一种是根据屏幕大小来调整col-的宽度，另外一种是根据屏幕大小应用不同的class。两种方法其实都很简单，直接上代码： 1. 调整col-宽度 .col-6{ width: 50%; } @media all and (max-width: 750px){ width: 100%; } 这里只是给出了最简单的演示，很多时候，我们需要设置多个阈值，并且还要考虑最后一个元素是否会溢出的问题，这些需要提前计算好。 2. 应用不同的class /* 小屏幕（平板，大于等于 768px） */ @media (min-width: @screen-sm-min) { ... } /* 中等屏幕（桌面显示器，大于等于 992px） */ @media (min-width: @screen-md-min) { ... } /* 大屏幕（大桌面显示器，大于等于 1200px） */ @media (min-width: @screen-lg-min) { ... } &lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;/div&gt; 这里直接粘贴了Bootstrap的代码，很简单是吧，相比第一个解决方案，这样更好控制。 完成剩下的工作 这是我们最后的效果，尝试下自己完成： 图片、文字左右布局 图片和文字垂直居中 当文字过多时，用...表示","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"CSS第二课 优雅","slug":"CSS第二课-优雅","date":"2017-07-26T07:30:07.000Z","updated":"2017-09-26T06:13:03.000Z","comments":true,"path":"/posts/3bcac801/","link":"","permalink":"http://www.voyax.meposts/3bcac801/","excerpt":"设定一个通用的排版样式 完成第一个模块","text":"设定一个通用的排版样式 完成第一个模块 上一课为了通过一个导航栏，尽可能多得给大家看到CSS中一些需要注意的问题；没有讲解在项目中如何从头开始组织自己的代码，这节课我们把这部分内容补上，然后完成第一个模块。 初始化你的CSS虽然加载了normalize.css，但是我们还是要手动处理一些问题： /** * init css * 1. change to border-box * 2. avoid horizontal width overflow * 3. define base font */ html{ box-sizing: border-box; font-family: &quot;Helvetica Neue&quot;,Helvetica, Arial, &quot;HanHei SC&quot;, &quot;PingFang SC&quot;, SimSun,&quot;Source Han Sans CN&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Microhei&quot;,sans-serif; font-size: 16px; font-weight: 300; color: #9cafc3; } html, body{ max-width: 100%; overflow-x: hidden; } *, *:before, *:after{ box-sizing: inherit; } box-sizing在上一课我们已经讲过，box-sizing默认是content-box，现在改成更方便的border-box。想一想下边这两种写法有和差异： 写法1： html{ box-sizing: border-box; } *, *:before, *:after{ box-sizing: inherit; } 写法2 *{ box-sizing: border-box; } 保持页面宽度不会溢出 html, body{ max-width: 100%; overflow-x: hidden; } 这里有一个小点，有时候你还会看到很多混乱的height html,body{ height: 100%; } 或者 html{ height: 100%; } body{ min-heigth: 100%; } 或者 html{ min-height: 100%; } 等等之类的排列组合，你只要理解height的默认值是auto，像设置min-height或者max-height之类的，反正又不是设置了height，超出了控制范围，height该怎么样还是怎样。要是没明白，看下这篇文章 See the Pen HTML &amp; Body Height tests by absolutholz (@absolutholz) on CodePen. 设置字体 关于字体的选择，请参看Web中文字体排版指南 确定基本的排版h1,h2,h3,h4,h5,h6{ margin-top: .7em; margin-bottom: .2em; line-height: 1.1em; font-weight: 300; } h1{ font-size: 2.25em; } h2{ font-size: 2em; } h3{ font-size: 1.7em; } h4{ font-size: 1.4em; } h5, h6{ font-size: 1.2em; } p{ line-height: 1.8em; margin-bottom: 1.8em; } a{ color: inherit; text-decoration: none; } img, video{ max-width: 100%; } 我们设定了标题、段落的字体大小、行间距、margin；去掉了&lt;a&gt;标签的的下划线；同时，给&lt;img&gt;,&lt;video&gt;这样的替换元素设置最大宽度。 完成导航先调整下头部的HTML结构，为了保证在宽屏上的效果，我们添加一个容器来包裹页面内容，设置max-width。 &lt;header class=&quot;site__header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;nav class=&quot;navbar&quot;&gt; &lt;a class=&quot;navbar__brand&quot; href=&quot;#&quot;&gt;Company Logo&lt;/a&gt; &lt;ul class=&quot;navbar__nav list-nostyle&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PlatForm&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#&quot;&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; /* container ========================================================================== */ .container{ max-width: 960px; margin: 0 auto; padding: 0 20px; } 这里使用margin:0 auto进行水平居中。其背后的原理在于：一个块元素的宽度默认会充满父元素的content-width，设定了width后，如果margin-left/right为auto，那么左右margin会平分剩余空间。 设置左右padding是为了防止内容部分直接贴到container，当宽度小于960px，你肯定不会希望内容紧贴着屏幕边缘的。 现在你的页面应该长这样： 现在请自己修改导航的样式，并激活其中一个导航链接（添加一个active类），最后的结果应该这样： 第一个模块html结构如下： &lt;section&gt; &lt;div class=&quot;container text-center&quot;&gt; &lt;header class = &quot;section__header&quot;&gt; &lt;h1 class = &quot;section__title&quot;&gt;BEST HEADLINE IN THE WORLD&lt;/h1&gt; &lt;p class = &quot;section--center__desc&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum rutrum urna felis, dictum dictum erat condimentum sit amet. Cras vel est bibendum, Cras vel est bibendum, posuere orci quis, consequat nisl.&lt;/p&gt; &lt;/header&gt; &lt;button class=&quot;btn&quot;&gt;CTA BUTTON&lt;/button&gt; &lt;div class=&quot;section--center__img--bottom&quot;&gt; &lt;img src=&quot;./img/rectangle1.svg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- section one --&gt; 现在来修改css： 内容水平居中 /* text-center ========================================================================== */ .text-center{ text-align: center; } 我们用了text-align: center进行水平居中，text-align实际是让行内元素进行居中。 将section__header往下挪一点 .section__header{ margin-top: 78px; margin-bottom: 49px; } .section__title{ margin-bottom: 28px; } 用margin-top来调整下元素的位置。 控制下文字宽度参看设计稿，打开栅格，你会发现文字描述部分的宽度占用了8/12： .section--center__desc{ max-width: 66.667%; margin: 0 auto; } 现在我们来写按钮 /* button ========================================================================== */ .btn{ padding: .3em .8em; border: 2px solid #9CAFC3; background: #9CAFC3; border-radius: .2em; color: #fff; font-size: 125%; line-height: 1.5; opacity: 1; cursor: pointer; } .btn:focus{ opacity: 0.7; outline: 0; } 这里我们采用相对单位em根据字体大小来控制自动改变按钮大小。 底部图片 现在底部图片已经居中，调整下间距： .section--center__img--bottom{ margin-top: 62px; } 看看最终的效果如何： 很简单不是吗；下一课我们将会讲解“响应式栅格系统”","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"CSS第一课 你热了么","slug":"CSS第一课-你热了么","date":"2017-07-26T07:28:52.000Z","updated":"2017-07-26T07:56:23.000Z","comments":true,"path":"/posts/44828b7f/","link":"","permalink":"http://www.voyax.meposts/44828b7f/","excerpt":"按照Sketch设计稿，实现一个完整的页面： 希望你学完这一些列课程后，能够系统地掌握CSS，真正把CSS玩转","text":"按照Sketch设计稿，实现一个完整的页面： 希望你学完这一些列课程后，能够系统地掌握CSS，真正把CSS玩转 Let’s Go Go Go首先下载素材文件（Windows用户可以下载pdf版） 设计稿 用Sketch打开文件后（可能会出现找不到字体的问题，字体下载），你可以通过commad + 1 将Artboard缩放至视口大小。 按住control + L可以显示出栅格系统，栅格系统可以帮你快速排版。 如果你不熟悉sketch，想了解更多，同时不占用你写代码的时间，可以看看这篇用Sketch制作登录页面的教程。 我们之后会单独推送一期sketch的教程，现在还是主要关注代码。 准备工作新建一个html文件和css文件├── css│ └── style.css└── index.html 页面模版还记得在HTML的课程中，为了保持代码的一致性并节省时间，保存的html模板么 大多数编辑器都允许你按照自己的风格定制模板 如果你用的atom，参考atom代码补全snippets配置。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;head&gt; &lt;title&gt;CSS Lesson 1&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt; &lt;link href=&quot;css/normalize.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 利用browser-sync实时刷新页面为了省去每次修改代码后都要手动刷新页面，我习惯使用browser-sync监听文件，自动刷新浏览器 安装Browsersync npm install -g browser-sync 运行Browsersync browser-sync start --server --files index.html --files &quot;css/*.css&quot; 引入normalize.cssNormalize.css，保证默认元素在不同浏览器上变现一致。 Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。——来，让我们谈一谈 Normalize.css 导航页面根据设计稿，我们把整个页面分为三个部分，头部、内容区域、页脚 &lt;header class = &quot;site__header&quot;&gt; &lt;/header&gt; &lt;main class = &quot;site__main&quot;&gt; &lt;/main&gt; &lt;footer class = &quot;site__footer&quot;&gt; &lt;/footer&gt; 用BEM作为CSS的命名规范，虽然site__header丑了点，但是在你代码越来越多的时候，这个东西可以让你的代码没那么混乱 BEMBEM 其实很简单，有点面向对象编程的意思，不过比OOP还简单直接。只要记住，BEM是由Block(块)，Element(元素)，Modifier(修饰符)组成，__连接Element，--连接Modifier；你把代码按照模块来组织。举个例子： .person{} .person__avatar{} .person__avatar--round{} 我们有一个person的Block，每个人都有头像、名字、描述之类的，所以我们用到.person__element；头像我们可能需要方的、圆的……都需要对这些进行单独设置，所以这时候对每个元素就用到Modifier。代码非常扁平是不是，如果按照我们以前的写法，可能就是这样： .person{} .person .avatar{} .round{} 好像除了长一点，没什么区别呀！那现在加一个动物，加个狗吧： .dog{} .dog .avatar{} .round{} 现在有个人养了一条狗，我们的HTML是这样： &lt;div class = &quot;person&quot;&gt; &lt;div class = &quot;avatar&quot;&gt;&lt;/div&gt; &lt;!-- 人头 --&gt; … &lt;!-- dog --&gt; &lt;div class = &quot;dog&quot;&gt; &lt;div class = &quot;avatar round&quot;&gt; &lt;!-- 狗脑 --&gt; &lt;/div&gt; &lt;/div&gt; 有没有晕乎乎的感觉，这两个avatar是一样的还是不一样的，到底应用了哪条样式，还有没有公共的样式+_+？（模块这个东西看起来很悬，不同人理解可能也有偏差，但是你只要用着舒服就行了，写多了，你就知道到底怎么按模块化来写代码了） 完成导航HTML结构 &lt;header class=&quot;site__header&quot;&gt; &lt;nav class=&quot;navbar&quot;&gt; &lt;a class=&quot;navbar__brand&quot; href=&quot;#&quot;&gt;Company Logo&lt;/a&gt; &lt;ul class=&quot;navbar__nav list-nostyle&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Platform&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#&quot;&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; 运行browser-sync start --server --files &#39;index.html&#39; --files &quot;css/*.css&quot; 好了，改点样式让它看来好看点 给导航设置一个固定高度 去掉li默认的样式 左右布局 /* list with no style ========================================================================== */ /** * 1. remove the margin and padding * 2. remove list style */ .list-nostyle{ margin: 0; padding: 0; } .list-nostyle li{ list-style: none; } /* site header ========================================================================== */ .site__header{ height: 70px; } .navbar{ padding: 15px 20px; } .navbar__brand{ float: left; } .navbar__nav{ float: right; } .navbar__nav li{ display: inline-block; } 首先，我们为页眉设置了一个70px的高度 通过浮动来实现Logo左对齐，导航右对齐 因为&lt;li&gt;是块级元素，所以会产生换行，我们把li设置成inline-block，在同一行显示 &lt;a&gt;标签我们一般更习惯不要下划线，而是通过颜色来突出是链接，所以我们把&lt;a&gt;标签的下划线统一去掉： a{ text-decoration: none; } 现在你看到的应该是这样： inline-block空格的问题 现在回去看看，有个问题需要处理一下： PlatForm，About，Sign Up之间为什么会有间隙？** 使用了inline-block，inline-block会表现得像文字排版一样，&lt;li&gt;和&lt;li&gt;之间存在空白符，所以最后产生了一个空格 有各种奇奇怪怪的方法可以解决这个问题，这里我只给出我平常用得最多的两个方法： 设置font-size: 0;（如果浏览器设置了最小字体大小要跪。。。） ul{ font-size: 0; } li{ display: inline-block; font-size: 1rem; } 去掉标签之间的空白符 &lt;li&gt;…&lt;/li&gt;&lt;li&gt;…&lt;/li&gt;&lt;li&gt;…&lt;/li&gt; 喜欢哪个方法就用哪个，快自己把这个bug修复了 美化导航样式 .navbar__brand, .navbar__nav li a{ display: inline-block; box-sizing: border-box; height: 40px; padding: 8px 24px 8px 24px; border: 1px solid #ccc; line-height: 22px; } 这里加了边框方便调试： 为了能够设置在垂直方向上的高度(padding-top/bottom, margin-top/bottom, height)：我们设置行内元素&lt;a&gt; display为inline-block 行内元素是就像水一样，垂直方向上设置高度都没用，所以有时候需要设置为inline-block或block。 有个形象的比喻，inline=&gt;水，inline-block=&gt;果冻，block=&gt;石头 设置box-sizing为border-box 默认情况下，元素的height只包括内容区域。但是我们经常需要加入border或者padding，元素的高度的实际高度是padding + border + height，每次你都需要减去padding和border。除了计算麻烦之外，用百分比设置高度的时候，你经常会遇到内容区域溢出的问题： &lt;style&gt; html,body{ height: 100%; width:100%; } .container{ padding: 0 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; Hello World &lt;/div&gt; &lt;/body&gt; 通过line-height进行垂直居中： css中水平居中很简单，但是垂直居中就不好做了。通过设置line-height等于height可以让文字垂直居中。关于居中的问题，参考[译]CSS居中完全指南：http://www.voyax.me/2016/04/19/译-CSS居中完全指南/ 最后还有一个大坑！！！ 为啥navbar高度没有撑开！！！好吧，都是float的错，float导致元素溢出了文档流，从而父元素的高度不会随着float元素高度的变化而适应。单从float的角度说，有两个思路： 将父元素变成BFC 清除浮动 代码如下： 通过overflow触发BFC .navbar::after{ overflow: hidden; } clearfix（关于clearfix的讨论，看看stackoverflow上的这个讨论） .clearfix:after { content: &quot; &quot;; /* Older browser do not support empty content */ visibility: hidden; display: block; height: 0; clear: both; } 总结这一章主要带着你踩踩坑，介绍了几个开发中经常遇到的问题。下一张我们看看在实际开发中，如果从零开始组织你的代码，同时逐步完成这个页面。","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"CSS 入门指南","slug":"CSS-入门指南","date":"2017-07-26T07:02:10.000Z","updated":"2017-07-26T07:56:26.000Z","comments":true,"path":"/posts/4972c060/","link":"","permalink":"http://www.voyax.meposts/4972c060/","excerpt":"CSS的基本知识很简单，你只要知道有哪些基本样式属性、CSS的选择器，怎么在页面应用CSS，就可以随便倒腾试试手了。 这篇文章属于最最基础的CSS大白教程，只涉及语法；介绍CSS基本语法、常用属性、选择器参考手册，最后会推荐三本分别适合不同阶段的CSS参考书，一本作为新手学习的，一本作为参考手册，还有本属于深入的技巧。 如果你对HTML还不熟，建议先去W3school补充下HTML的知识，觉得OK了，看看我们的HTML专题检测下自己的水平。","text":"CSS的基本知识很简单，你只要知道有哪些基本样式属性、CSS的选择器，怎么在页面应用CSS，就可以随便倒腾试试手了。 这篇文章属于最最基础的CSS大白教程，只涉及语法；介绍CSS基本语法、常用属性、选择器参考手册，最后会推荐三本分别适合不同阶段的CSS参考书，一本作为新手学习的，一本作为参考手册，还有本属于深入的技巧。 如果你对HTML还不熟，建议先去W3school补充下HTML的知识，觉得OK了，看看我们的HTML专题检测下自己的水平。 CSS如何改变页面样式我们在页面看到的各种排版、颜色、字体等等都是由CSS来控制的，比如现在我想改变所有段落的颜色为蓝色： 原始index.html如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;head&gt; &lt;title&gt;CSS基础知识-四光年&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;如何学好CSS&lt;/h1&gt; &lt;p&gt;代码不贪多，理解清楚&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 第一种方法：内部样式表在head标中加入style标签 &lt;head&gt; &lt;title&gt;CSS基础知识-四光年&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--内部样式表--&gt; &lt;style&gt; p{ color: blue; } &lt;/style&gt; &lt;/head&gt; 第二种方法：内联样式在标签内部添加style属性 &lt;p style=&quot;color: blue;&quot;&gt;代码不贪多，理解清楚&lt;/p&gt; 不过，这仅仅修改了这一段落的颜色哈哈哈，要是还有很多p标签，继续加style属性会不会疯了…… 第三种方法：外部样式表新建一个CSS文件（后缀.css），然后在HTML中引入这个文件： 比如我在index.html的同级目录创建一个style.css style.css文件内容： p{ color: blue; } 然后在我们的index.html的head中添加link标签，引入style.css &lt;head&gt; &lt;title&gt;CSS基础知识-四光年&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--外部样式表--&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; 极小概率你会看到@import，它也是引入外部样式表，语法不同，不过并不推荐。 关于link和import的详细讨论，参见Difference between @import and link in CSS 总结我们大多数时候都是通过外部样式表引入样式，方便代码组织，也不会破坏HTML的整洁。另外两种方法，根据实际情况灵活使用就好了。 基本语法具体看CSS怎么写，有哪些属性： 我们的样式是由一些列CSS规则共同组成，CSS规则由选择器 + 声明构成，用大括号{}来包裹声明语句。 借用w3chool的一张图： h1{ color: red; font-size: 14px; } .primary-nav{ background-color: #333; } 所有h1元素字体颜色设置为红色，字体大小14px； class为primary-nav的所有元素背景颜色设置为#333。 CSS的属性有很多，后边实际运用中我们会介绍重要而且容易出错的属性，其他的需要你自己去查看手册CSS属性参考手册。 CSS的属性除了包括视觉上的样式，还有听觉样式，不过你工作中几乎不会用到，知道还有听觉呈现这个东西就可以了 CSS的属性，其基础是单位，下面专门把颜色和尺寸讲解清楚，颜色和长度单位的选择对你后边写CSS非常重要，需要额外注意。 颜色 在CSS中我们有4种表示颜色的方式：颜色名、16进制、RGB、HSL 比如红色： color: red; /* 颜色名 */ color: #ff0000; /* 16进制 */ color: rgb(255,0,0); /* rgb */ color: hsl(0, 100%, 50%); /* hsl */ 颜色关键字CSS定义了16个基本的颜色关键字：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow 比如设置重要警告内容为黄色： .warning{ color: yellow; } 使用颜色名简单，但是可选颜色太少，书写也不方便，一般只是用来做一些简单的测试。 RGB和RGBArgb分别代表红、绿、蓝，通过组合红绿蓝表示不同的颜色，比如表示红色： color: rgb(255, 0, 0); rgb()接收三个参数，分别表述红、绿、蓝，取值区间[0,255]： 0表示没有这个颜色，所以rgb(0, 0, 0)是黑色 255分别表示纯色的红、绿、蓝，如果三个值都是255，那就是白色了；三个值一样，介于0~255之间，就是不同程度的灰色 rgb(255, 0, 0); /* red */ rgb(0, 255, 0); /* green */ rgb(0, 0, 255); /* blue */ rgb(255, 255, 255); /* white */ rgb()除了接受三个整数外，还可以接收三个百分数 rgb(100%, 0%, 0%); /* red */ 在工作中，基本都是采用整数的表示方式，百分数表示极少见。 RGBA RGBA在RGB的基础上增加Alpha通道，设置透明度，Alpha取值区间为[0,1] 0是完全透明，1是完全不透明 rgba(255, 0, 0, 1); /* red */ rgba(255, 0, 0, .5); /* 50% opacity red */ 这个最常用的用处就是建立一个半透明的背景遮罩 下面的例子我们在一张图片上加上一个灰色半透明的遮罩： See the Pen MbMLax by voya (@voyax) on CodePen. 十六进制十六进制是RGB色彩空间的另一种表示，和上边的rgb()可以完全转换，语法如下： #RRGGBB 用三个介于00-FF的十六进制数分别表示红、绿、蓝 #FF0000; /* red */ #00FF00; /* green */ #0000FF; /* blue */ #000000; /* black */ 如果组成的十六进制的3组数各自都是成对的，可以简写为3位，比如#F00等同于FF0000 HSL和HSLaHSL是不同于RGB的色彩模式，HSL分别表示色调、饱和度、亮度，通过这三个通道来表示不同颜色。 H(Hue色调)：表示一个色相环，从0到360度取值，0(或360)是红色，120是绿色，240是蓝色 S(Saturation饱和度)：表示颜色的纯度，取值从 0.0% 到 100.0%，数值越大，颜色中的灰色越少，颜色越接近纯色 L(Lightness亮度)：表示颜色的明暗，取值也是 0.0%——100.0%，0%是彻底变暗（黑），100%彻底变亮（白），50%正常亮度 下面的图比较直观（图片来自维基百科）： HSLA也是在HSL的基础上添加了透明度 hsl(0, 100%,50%) /* red */ hsl(120,100%,50%) /* green */ hsl(240,100%,50%) /* blue */ hsla(0,100%,50%,0.05) /* 5% opaque red */ 颜色表示的选择一般我们都使用十六进制的表示法，书写简单而且和其他软件通用，在需要透明颜色的时候用rgba，hsl在设计上对颜色的变化更好控制，但是这个东西对于大多数程序员来说不像rgb那么只管，用得并不多，不过hsl有可能今后会成为主流。 长度 px, em, rem这三个都是表示长度的单位，px作为绝对单位（在web页面上），em、rem则是相对单位。 px本身是一个相对单位，一个像素就是显示器上看到的一个点，每个点的大小，取决于显示器的分辨率； 但是CSS规范做了一个规范：将96ppi作为参考像素，浏览器会根据这个标准进行缩放，保证在所有显示器上显示的长度是确定的 px在网页中，1 px = 1 / 96 in。对于高度、宽度固定的页面，用px非常方便直观，但是考虑到移动端适配，绝对尺寸就很难办。 html{ font-size: 16px; } body{ max-width: 960px; } 浏览器默认会设置一个字体大小：16px；也会限制字体大小的范围：9px ~ 72px。 通过设置根元素(html)字体大小，可以改变浏览器默认字体大小的设置： /* 为了方便计算，我们把html字体大小设置为10px */ html{ font-size: 10px; } font-size具有继承性，如果未设置字体大小，元素的font-size将继承父元素font-size大小 注意下面两个p标签的字体大小： html{ font-size: 16px; } .title{ font-size: 32px } &lt;p&gt;这是一个常规段落&lt;/p&gt; &lt;div class=&quot;title&quot;&gt; &lt;p&gt;这是在h2中的段落&lt;/p&gt; &lt;/div&gt; emem是一个相对长度单位，1em = 使用em单位的元素的字体大小（注意不是参考的它的父元素，而是它自己，很多博客和文档这在有问题） button{ font-size: 16px; padding: .3em .8em; } padding的实际大小为： 上下padding 16*0.3 = 4.8 = 5px 左右padding 16 * 0.8 = 12.8 = 13px 对于带小数点的px，现在的浏览器（IE8+、Chrome、Firefox、Safari）都会采用四舍五入的方法取整 remrem与em相似，仅参考对象不同，rem始终参考根元素的字体大小 看下面的例子 px, rem, rem： See the Pen aBeaQM by voya (@voyax) on CodePen. px, em ,rem的选择 完全明确、不需要缩放的布局，才使用px em慎重考虑，一般只用在组件内部，不然会导致很麻烦的嵌套计算…… 优先考虑rem 分别看一个可缩放的按钮和响应式页面： 可缩放按钮：在组件内使用em button{ padding: .3em .8em; border: 1px solid #333; border-radius: .2em; line-height: 1.5; } 在button内使用em来进行缩放，只要改变字体，就能创建不同尺寸的按钮！是不很方便！ 响应式设计：rem rem结合媒体查询，改变根元素字体大小，适应不同的设备。 See the Pen rem responsive by voya (@voyax) on CodePen. 推荐阅读：综合指南: 何时使用Em与Rem CSS选择器选择器用于标识是哪些元素需要被应用样式规则。 最简单直接通过标签名，就只可以选择文档中所有的该标签；也通过为HTML标签定义class或者id属性，使用类选择器、id选择器；还有什么属性选择器、伪类选择器…… 其实道理都一样，反正就是让被选择的元素应用相应的规则，仅仅是写法不同而已。 看几个例子： 标签选择器： /* 设置所有p标签字体为16px */ p{ font-size: 16px; } 类选择器： &lt;!-- html --&gt; &lt;div class=&quot;info&quot;&gt; … &lt;/div&gt; &lt;!-- css --&gt; /* 设置所有class为info的元素颜色为绿色 */ .info{ color: green; } 类选择器.class-name和后代选择器ancestor-selector descendant-selector会是你工作中用到最多的两个选择器。 CSS选择器参考基础选择器 组合选择器 CSS 2.1 属性选择器 注：CSS 2.1 属性选择器还有一个特点就是使用多个选择器，同事满足这多个选择器：blockquote[class=quote][cite] { color:#f00; } CSS 2.1 中的伪类 CSS 2.1 中的伪元素 CSS 3 的同级元素通用选择器 CSS 3 属性选择器 CSS 3 中与用户界面有关的伪类 CSS3 中的结构性伪类 CSS 3 反选伪类 CSS 3 :target伪类 挑战一下上边的内容学完后，你觉得可以模仿写一个谷歌商务合作的页面么，不需要考虑什么规范、规则，尽量按照自己想的，看看能做到什么程度。实在写不出来了，再继续学习下一课，这样才会明白下节课的内容到底有什么用。 附上你可能需要的CSS属性参考手册， CSS推荐书单 入门自学——《精通CSS 高级Web标准解决方案》 不要看这本书有点老了，但是目前为止，我仍然觉得它是入门的最佳选择，里边的知识点都有结合实际应用，不会枯燥的。 参考手册——《CSS权威指南》 这本书适合慢慢啃，讲了很多原理、细节，第一遍看可能有很多看不明白或者觉得没用，但是建议你坚持看，到最后你会觉得，原来如此，有道理（很多时候一些疑难杂症的根源都可以从这本书找到） 使用技巧——《CSS 揭秘》 今年（2016）才出的一本书，广受追捧，里边有很多CSS难点和实用技巧，看完它你CSS提升应该算立竿见影了","categories":[{"name":"css-tutorial","slug":"css-tutorial","permalink":"http://www.voyax.me/categories/css-tutorial/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"全基因组测序是什么东西","slug":"全基因组测序是什么东西","date":"2017-06-15T10:59:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/61527/","link":"","permalink":"http://www.voyax.meposts/61527/","excerpt":"","text":"很久没更新，在新环境中懒了不少，毕竟和最开始的打算一样，来这调理身体。2017年还剩半年，开始准备准备出国刷题，整理前端、网络的知识了。接下来半个月优化 BWA 或者叫重新一套流程，这个感觉还蛮有意思，顺便了解下生信的东西。 基本概念全基因组测序 正常人有 22 对常染色体 加上 X， Y 这两条性染色体。因为存在碱基互补，只需要知道生物体所携带的一套完整的单倍体序列就可以了。所以人类全基因组实际是 22 条常染色体加上 X 或者 X、Y。（总共有 30 亿个碱基） 全基因组测序就是检测出这30亿对碱基对从第1个到第30亿个到底是如何排列的。 “全基因组测序30X” 是什么意思 这是一个数据的要求： 平均把 30 亿个碱基测30次，但因为是随机的，所有的多有的少，这个在他们生物上不叫“多”和“少”，而叫“深”和“浅”。 测序越深，成本自然越高，所以有人做了一个梯度模拟，来计算深度和发现变异的能力的关系，最后的结论是：“平均深度达到 30X 的时候，可以覆盖基因组的 95%” 二代测序和三代测序 目前三代测序还不成熟，主要还是采用二代测序。看了下文章，没看懂ㄟ( ▔, ▔ )ㄏ，我理解的两点区别： 二代读长较短，需要后续进行拼接；三代直接对一条 DNA 分子单独测序 二代需要采用 PCR， 三代不需要 其实很好奇，三代不用 PCR 是不就是因为二代把 DNA 打断成很小的片段了，而三代测一条就不要了；请教了一个生信的同学，他说，这是一部分原因，用 PCR 主要是复制很多次，方便检测，不然可能检测不到。蒙圈…… 分析流程 QC（数据质量控制：测序质量、接头、污染序列） alignment variation calling annotation statistic/visualization 首先是拿到基因组测序数据， 然后 进入 对比 找variation 是很重要的部分，包括 snv, indel, cnv, sv 找到变异基因后，进入临床分析流程：参考一些公共数据库（OMIN, clinVAR, HGMD, GWAS） 和 公司的私有数据，对变异位点进行注释，从而评估个体患疾病的风险，用药建议可以参考 PharmaGKB","categories":[],"tags":[]},{"title":"突然有一天，发现爷爷、奶奶真的老了","slug":"突然有一天，发现爷爷、奶奶真的老了","date":"2017-04-09T12:39:05.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/3216/","link":"","permalink":"http://www.voyax.meposts/3216/","excerpt":"","text":"在外，很容易忘了家的感觉很珍惜这种感觉，健忘和麻木是需要打败的家里边有个活蹦乱跳、童言无忌的二妹，放心了好多很早前，姑姑跟我说，每次接到我电话，爷爷心情就会好很多只是，从小学3年级到现在工作，在家呆的时间越来越短，从一周回家一次，到一个月，再到半年，一年……2017年2月10号，早上5点半从家出发往车站走，我穿了个厚大衣，不记得爷爷穿的什么，很冷爷爷、妈妈还有二妹，打着手电筒，慢慢地离家越来越远想让爷爷回去，年龄大了，天也还冷但是，其实这样陪着可能爷爷会更开心吧 走到火车的桥下边，碰到爸爸骑着摩托车过来接我不知道为什么那个时候才发现爷爷好像真的头发都白完了一直以为自己没长大，爷爷奶奶，爸爸妈妈还是像以前一样但是，好像真的不是的我还有很多时间，但是，什么时候可以，好好陪着他们，他们不再操劳担心 16年过得很失败，创业什么都丢了，连过年回去，什么都没买什么都没带 每一次，回到家，或是接到二妹打来的视频电脑，看见爸妈，看见爷爷奶奶，都会觉得很踏实，不害怕，很有动力 记得，很多时候，你要记得，自己在外边吃好的玩得不亦乐乎，爷爷奶奶爸爸妈妈还有二妹在家还在省吃俭用，七十多岁的两老，还在下地种菜 你要快速成长，时间是个很恐怖的东西 离开家那天就好想写，但不知道怎么写，今天（2017.04.09）接到二妹电脑，看到爷爷奶奶吃的饭，思绪难断 2017.04.09于深圳华大公寓7栋609","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"TED 一个简单的方式戒掉坏习惯","slug":"ted-一个简单的方式戒掉坏习惯","date":"2016-11-01T05:08:56.000Z","updated":"2017-07-10T15:47:54.000Z","comments":true,"path":"/posts/24157/","link":"","permalink":"http://www.voyax.meposts/24157/","excerpt":"安静、思考、放松，是一个非常享受的过程 幸对清风皓月，苔茵展、云幕高张","text":"安静、思考、放松，是一个非常享受的过程 幸对清风皓月，苔茵展、云幕高张 Can we break bad habits by being more curious about them? Psychiatrist Judson Brewer studies the relationship between mindfulness and addiction — from smoking to overeating to all those other things we do even though we know they’re bad for us. Learn more about the mechanism of habit development and discover a simple but profound tactic that might help you beat your next urge to smoke, snack or check a text while driving. When I was first learning to meditate, the instruction was to simply pay attention to my breath, and when my mind wandered, to bring it back.0:19Sounded simple enough. Yet I’d sit on these silent retreats, sweating through T-shirts in the middle of winter. I’d take naps every chance I got because it was really hard work. Actually, it was exhausting. The instruction was simple enough but I was missing something really important.0:39So why is it so hard to pay attention? Well, studies show that even when we’re really trying to pay attention to something – like maybe this talk – at some point, about half of us will drift off into a daydream, or have this urge to check our Twitter feed.0:55So what’s going on here? It turns out that we’re fighting one of the most evolutionarily-conserved learning processes currently known in science, one that’s conserved back to the most basic nervous systems known to man.1:08This reward-based learning process is called positive and negative reinforcement, and basically goes like this. We see some food that looks good, our brain says, “Calories! … Survival!” We eat the food, we taste it – it tastes good. And especially with sugar, our bodies send a signal to our brain that says, “Remember what you’re eating and where you found it.” We lay down this context-dependent memory and learn to repeat the process next time. See food, eat food, feel good, repeat. Trigger, behavior, reward.1:42Simple, right? Well, after a while, our creative brains say, “You know what? You can use this for more than just remembering where food is. You know, next time you feel bad, why don’t you try eating something good so you’ll feel better?” We thank our brains for the great idea, try this and quickly learn that if we eat chocolate or ice cream when we’re mad or sad, we feel better.2:07Same process, just a different trigger. Instead of this hunger signal coming from our stomach, this emotional signal – feeling sad – triggers that urge to eat.2:18Maybe in our teenage years, we were a nerd at school, and we see those rebel kids outside smoking and we think, “Hey, I want to be cool.” So we start smoking. The Marlboro Man wasn’t a dork, and that was no accident. See cool, smoke to be cool, feel good. Repeat. Trigger, behavior, reward. And each time we do this, we learn to repeat the process and it becomes a habit. So later, feeling stressed out triggers that urge to smoke a cigarette or to eat something sweet.2:52Now, with these same brain processes, we’ve gone from learning to survive to literally killing ourselves with these habits. Obesity and smoking are among the leading preventable causes of morbidity and mortality in the world.3:06So back to my breath. What if instead of fighting our brains, or trying to force ourselves to pay attention, we instead tapped into this natural, reward-based learning process … but added a twist? What if instead we just got really curious about what was happening in our momentary experience?3:24I’ll give you an example. In my lab, we studied whether mindfulness training could help people quit smoking. Now, just like trying to force myself to pay attention to my breath, they could try to force themselves to quit smoking. And the majority of them had tried this before and failed – on average, six times.3:42Now, with mindfulness training, we dropped the bit about forcing and instead focused on being curious. In fact, we even told them to smoke. What? Yeah, we said, “Go ahead and smoke, just be really curious about what it’s like when you do.”3:57And what did they notice? Well here’s an example from one of our smokers. She said, “Mindful smoking: smells like stinky cheese and tastes like chemicals, YUCK!” Now, she knew, cognitively that smoking was bad for her, that’s why she joined our program. What she discovered just by being curiously aware when she smoked was that smoking tastes like shit.4:22(Laughter)4:25Now, she moved from knowledge to wisdom. She moved from knowing in her head that smoking was bad for her to knowing it in her bones, and the spell of smoking was broken. She started to become disenchanted with her behavior.4:41Now, the prefrontal cortex, that youngest part of our brain from an evolutionary perspective, it understands on an intellectual level that we shouldn’t smoke. And it tries its hardest to help us change our behavior, to help us stop smoking, to help us stop eating that second, that third, that fourth cookie. We call this cognitive control. We’re using cognition to control our behavior. Unfortunately, this is also the first part of our brain that goes offline when we get stressed out, which isn’t that helpful.5:13Now, we can all relate to this in our own experience. We’re much more likely to do things like yell at our spouse or kids when we’re stressed out or tired, even though we know it’s not going to be helpful. We just can’t help ourselves.5:26When the prefrontal cortex goes offline, we fall back into our old habits, which is why this disenchantment is so important. Seeing what we get from our habits helps us understand them at a deeper level – to know it in our bones so we don’t have to force ourselves to hold back or restrain ourselves from behavior. We’re just less interested in doing it in the first place.5:45And this is what mindfulness is all about: Seeing really clearly what we get when we get caught up in our behaviors, becoming disenchanted on a visceral level and from this disenchanted stance, naturally letting go.5:59This isn’t to say that, poof, magically we quit smoking. But over time, as we learn to see more and more clearly the results of our actions, we let go of old habits and form new ones.6:11The paradox here is that mindfulness is just about being really interested in getting close and personal with what’s actually happening in our bodies and minds from moment to moment. This willingness to turn toward our experience rather than trying to make unpleasant cravings go away as quickly as possible. And this willingness to turn toward our experience is supported by curiosity, which is naturally rewarding.6:34What does curiosity feel like? It feels good. And what happens when we get curious? We start to notice that cravings are simply made up of body sensations – oh, there’s tightness, there’s tension, there’s restlessness – and that these body sensations come and go. These are bite-size pieces of experiences that we can manage from moment to moment rather than getting clobbered by this huge, scary craving that we choke on.7:01In other words, when we get curious, we step out of our old, fear-based, reactive habit patterns, and we step into being. We become this inner scientist where we’re eagerly awaiting that next data point.7:17Now, this might sound too simplistic to affect behavior. But in one study, we found that mindfulness training was twice as good as gold standard therapy at helping people quit smoking. So it actually works.7:30And when we studied the brains of experienced meditators, we found that parts of a neural network of self-referential processing called the default mode network were at play. Now, one current hypothesis is that a region of this network, called the posterior cingulate cortex, is activated not necessarily by craving itself but when we get caught up in it, when we get sucked in, and it takes us for a ride.7:52In contrast, when we let go – step out of the process just by being curiously aware of what’s happening – this same brain region quiets down.8:02Now we’re testing app and online-based mindfulness training programs that target these core mechanisms and, ironically, use the same technology that’s driving us to distraction to help us step out of our unhealthy habit patterns of smoking, of stress eating and other addictive behaviors.8:20Now, remember that bit about context-dependent memory? We can deliver these tools to peoples’ fingertips in the contexts that matter most. So we can help them tap into their inherent capacity to be curiously aware right when that urge to smoke or stress eat or whatever arises.8:37So if you don’t smoke or stress eat, maybe the next time you feel this urge to check your email when you’re bored, or you’re trying to distract yourself from work, or maybe to compulsively respond to that text message when you’re driving, see if you can tap into this natural capacity, just be curiously aware of what’s happening in your body and mind in that moment. It will just be another chance to perpetuate one of our endless and exhaustive habit loops … or step out of it.9:05Instead of see text message, compulsively text back, feel a little bit better – notice the urge, get curious, feel the joy of letting go and repeat.9:16Thank you.","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"近期书单","slug":"近期书单","date":"2016-10-22T02:46:20.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/25802/","link":"","permalink":"http://www.voyax.meposts/25802/","excerpt":"","text":"CSS Module:https://github.com/css-modules/css-modules 9月遗留产物，花点时间读、翻译、做案例 《Pro React》：http://www.pro-react.com 重看React；除官方文档，目前唯一推荐，可参考作为我们自己的教程大纲；已下载，在本地 月底前翻译完《CSS高级指南》 调研Paper.js","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"TED 说话的艺术","slug":"吃饭行动说话的艺术","date":"2016-10-21T07:11:54.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/34811/","link":"","permalink":"http://www.voyax.meposts/34811/","excerpt":"","text":"Julian Treasure《How to speak so that people want to listen》，从上小学开始，我们就被教导怎么在大家面前说话，怎么上台演讲，但理论上的东西对经验不足的我们很难有实质影响，这个演讲的内容你可以认为是老生常谈，但是回头看看却是金玉良言 大学语文课现在还拥有的记忆之一：反复强调，上台演讲你要是紧张，说话就会不自觉地快，要控制语速，慢下来；这个小技巧帮我面试、做报告提升了不少 Julian Treasure 谈到说话时的一些不好习惯以及好的方式，总结起来，分软和硬两个方面： 软: 学会尊重你的听众，换位思考；己所不欲勿施于人 硬：学会发音、控制说话节奏，把说话当成一门艺术来修炼 说话七宗罪 流言蜚语：在背后说某些人的坏话。 这不是一个好习惯，我们都很明白 那个说闲话的人在五分钟以后 就会在别人跟前说我们的闲话。 评判：我们知道有些人在谈话中是这样的， 这让人很难听进别人的话， 如果你知道你被人评判 且被认为不合格。 消极：你能陷入这个泥潭。 我的母亲，在她生命的最后几年里， 变得非常非常消极，很难让人听她说话。 我记得有一天，我对她说， “今天是十月一号，” 她说，“我知道，这不可怕吗？” （笑声） 当某人那么消极的时候是很难让人听进去的。 抱怨：这是英国的全国性艺术。 是我们的全国性运动。我们抱怨天气， 体育和政治，几乎每件事， 但实际上抱怨是病毒性的悲催， 它不会在这个世界上传播太阳和光明。 借口：我们都遇上过这个家伙。 也许我们都曾经是这个家伙。 有些人有指责癖好。 他们怪罪任何人 而不是对自己的行为负责任， 所以，这又是让人难以聆听的一种。 浮夸，吹牛：它有时贬低了我们的语言，事实上。 比如，如果我看见 什么真的很神奇的事情， 那我该说什么呢？ （笑声） 当然这种夸大后来就变成了说谎。 彻头彻尾的说谎，我们就不想听 这种我们知道会说谎的人。 固执己见：把事实和意见混淆。 当这两件事混为一谈， 你就像在听风一样。 你知道，有人用他们自己的意见来强迫你。 这很难让我们听讲。 HAIL 这一部分直接引用原文，无歧义更有意思 Honesty: be clear and straight Authenticity: be yourself Integrity: be your word Love: wish them well 说话技巧 音域 音色 韵律（抑扬顿挫） 语速 音量 Julian Treasure特别强调了“沉默”，好像留白，说得俗点，学会“装B”，在适当的时候沉默，可以帮你提升境界 预热视频最后，演示了开讲前预热准备，蛮好玩的，看视频模仿下，试了下，蛮提升精神的","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"小白翻墙（shadowsocks篇）","slug":"小白翻墙（shadowsocks篇）","date":"2016-10-17T07:54:21.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/27305/","link":"","permalink":"http://www.voyax.meposts/27305/","excerpt":"这篇文章只会告诉你怎么用shadowsocks翻墙，不提供账号 shadowsocks个版本下载地址： Windows Mac OS X Android IOS 如果我们很熟，我可以给你共享我自己搭建的服务；其他，还请自己购买","text":"这篇文章只会告诉你怎么用shadowsocks翻墙，不提供账号 shadowsocks个版本下载地址： Windows Mac OS X Android IOS 如果我们很熟，我可以给你共享我自己搭建的服务；其他，还请自己购买 shadowsocks简单配置下其实就可以了，所以接下来的教程其实很水的…… 下载相应的客户端，安装，启动（windows如果提示安装.net framework，安装系统对应的版本） 打开服务器设定（Windows上也一样） 输入shadowsocks账号 配置项说明如下： * **地址:** 远程服务器的**ip**以及**端口** 比如：45.90.55.201:6363 加密：下拉你会看到很多加密方式，选择你的账号提供者给你的加密方式 密码：账号对应的密码 备注：这个就随意填 输入完后，点击确认，完成配置 你可以添加多个账号，在某个账号不稳定时随时切到其他账号 到现在，基本搞定，如果你的账号没问题，那现在就可以了 查看日志 如果出现了问题，点击显示日志，查找原因 PAC和全局代理 自动代理模式对应一个规则文件，只有里边的域名才会走代理模式；而全局代理是所有请求都是通过代理； 在自动代理模式下，你可以从giflist更新规则规则，也可以自己添加或者删除域名：","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[]},{"title":"透析Margin Collapsing","slug":"CSS-margin-collapse-解惑","date":"2016-09-21T02:15:18.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/39401/","link":"","permalink":"http://www.voyax.meposts/39401/","excerpt":"如果不是太粗犷，margin collapsing会是CSS中出现频率很高的一个问题。读完这篇文章，应该彻底明白： 什么情况下会触发margin collapsing 有哪些解决方法 这篇文章同时是《CSS内功心法》补充资料，感兴趣的同学可以查看完整的CSS课程","text":"如果不是太粗犷，margin collapsing会是CSS中出现频率很高的一个问题。读完这篇文章，应该彻底明白： 什么情况下会触发margin collapsing 有哪些解决方法 这篇文章同时是《CSS内功心法》补充资料，感兴趣的同学可以查看完整的CSS课程 来自W3C的描述： In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin. Adjoining vertical margins collapse, except: Margins of the root element’s box do not collapse.If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins of following siblings but that resulting margin does not collapse with the bottom margin of the parent block. 也就是说，只有margin毗邻的两个或者多个元素(既可以是相邻节点，也可以是父子节点)才会发生外边距折叠。 margin collapsing 条件 margin毗邻（可以是兄弟节点之间也可以是父子节点之间） 两个或两个以上 什么是毗邻？ adjoining margin具体说明如下： Two margins are adjoining if and only if: both belong to in-flow block-level boxes that participate in the same block formatting context no line boxes, no clearance, no padding and no border separate them (Note that certain zero-height line boxes (see 9.4.2) are ignored for this purpose.) both belong to vertically-adjacent box edges, i.e. form one of the following pairs: top margin of a box and top margin of its first in-flow child bottom margin of box and top margin of its next in-flow following sibling bottom margin of a last in-flow child and bottom margin of its parent if the parent has ‘auto’ computed height top and bottom margins of a box that does not establish a new block formatting context and that has zero computed ‘min-height’, zero or ‘auto’ computed ‘height’, and no in-flow children 两个margin adjoining有且仅满足： 属于同一个BFC 相邻margin之间没有行盒、clearance、padding、border分隔（注意看加粗的文字） 这里我的理解是，相邻的兄弟元素的bottom margin和top margin之间不可能有clearance、padding、border的 注意，行盒是可行的，只需要将它们设置成inline-block 垂直方向margin相邻，满足如下四种情况中的一个： 一个元素的top margin和它的第一个子元素的top margin 一个元素的bottom margin和其相邻的兄弟元素的top margin 父元素高度必须是auto，那么父元素的bottom margin和其最后一个子元素的bottom margin 一个元素自己的top margin和bottom margin也可以发生折叠：没有创建BFC、min-height为0（默认值）、height为0或者auto，并且没有子元素。 阻止margin collapsing的方法按照上述条件，想想有哪些可行的方法阻止margin collapsing。我的基本思路是： 脱离正常文档流 增加line box, padding，border 设置高度（仅适合父元素的bottom margin和最后一个子元素的bottom margin折叠的情况）。 为了方便区分，这里按照相邻的兄弟元素和父子元素简单说明一下： 相邻的兄弟元素目前考虑到的能应用于实际的方法有两个： 脱离文档流： position设置为absolute(fixed)或者float line box：display设置inline-block 额外补充，行盒是什么： The rectangular area that contains the boxes that form a line is called a line box.…When several inline-level boxes cannot fit horizontally within a single line box, they are distributed among two or more vertically-stacked line boxes. Thus, a paragraph is a vertical stack of line boxes.…When an inline box exceeds the width of a line box, it is split into several boxes and these boxes are distributed across several line boxes. If an inline box cannot be split (e.g., if the inline box contains a single character, or language specific word breaking rules disallow a break within the inline box, or if the inline box is affected by a white-space value of nowrap or pre), then the inline box overflows the line box. 父元素和子元素父元素和子元素的问题相对简单： 为父元素创建BFC 关于BFC的详细内容，出门右拐谈谈BFC 设置padding 或者 border 当然也可以为子元素设置inline-block，但是这样会阻止子元素的margin collapsing，也会产生其他副作用，不推荐。很多前辈已经强调过margin collapsing并非bug，它的设计是为了纠正元素之间因为粗心同时设置了margin而偏离预期的错误 指定高度：局限性太大，而且只能解决bottom margin的问题，不推荐 所以其实用得最多的还是BFC和设置padding。举两个经典的例子： clearfix .cf:before, .cf:after { content: &quot; &quot;; display: table; } .cf:after { clear: both; } /** * For IE 6/7 only * Include this rule to trigger hasLayout and contain floats. */ .cf { *zoom: 1; } 你可能见过这样的写法（打开bootstrap的源码看看），其中的妙处在于display: table。 个人不推荐这种写法，推荐display: block，我们很多时候并不希望去掉margin collapsing 再看另外一个例子： .parent{ margin-top: -1px; padding-top: 1px; } 这个也是经常用到的 保持一个方向的margin最后一个建议：尽量统一仅按照margin-top或者margin-bottom来写 延伸阅读The very latest clearfix reloaded","categories":[{"name":"CSS课程补充","slug":"CSS课程补充","permalink":"http://www.voyax.me/categories/CSS课程补充/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"《程序员修炼之道》读书笔记——注重实效的哲学","slug":"《程序员修炼之道》读书笔记——注重实效的哲学","date":"2016-09-18T17:10:16.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/16440/","link":"","permalink":"http://www.voyax.meposts/16440/","excerpt":"","text":"“实效”实在是一个非常完美的词，本打算在加上一个批注，叫“如何成为一个高效率的程序员”，仔细想了想，高效率似乎和能出色完成工作还是有很大差距。读完这章，感慨颇深，好比只讲情怀不谈实际的人与喷子只是一念之差，一个好的程序员是该既保持高效，也要为整个项目负责的。 提供解决方案，而不是找借口 在所有弱点中，最大的弱点就是害怕暴露弱点。——J.B.Bossuet.Politics 如果你接受了一个任务，那就应切实负起责任。无论因为什么原因（所有人都会犯错或者叫失误），都应该诚实地承认，并快速给出弥补方案；而不是抱怨你的同事，或者其他各种各样的问题，他们可能确实在其中扮演了不好的角色，但是你可以提前做出解决方案，而不是等到最后才开始抱怨。 抱怨除了惹得别个和你一样生气，啥都没用。 如果你觉得你不需要为这个事情负责，或者超出了你的能力，那么无须为这些事情负责。及时提出来，让你的团队能有充足时间进行调整。 如果是你的责任，那么想想还可以如何力缆狂澜，你还需要哪些帮助，下一步如何进行。 想起去年刚毕业工作，一个人负责APP的开发和公司所有前端的东西，时不时处理下运营反馈的问题；经常是整个一天很难集中精力开发APP。一次开会，向老板反馈事情太杂效率太低，希望能把部分工作交给xxx后，老板很通情地让我专心开发APP。每个人都很聪明，你的难处别人自然理解；而借口，谁也看得明白。 不要成为第一个弄脏代码的人“破窗理论”在代码中似乎更加明显，给你一份格式混乱、变量随意声明、到处都是全局变量、毫无设计的代码时，你会咋办。好吧，我接手前公司广告系统时，我是这么干的 反正都已经这么乱了，要是动了代码出bug了调都没法调，算了，算了，不管了，反正不是我写的。有什么新的需求，就看情况怎么填塞进去，随便写写就好。 坚持了段时间，最后还是放弃了，老老实实花时间进行重构。糟糕的代码才真的会让你花费很多时间。 但是如果最开始，代码就十分漂亮——编写整洁、设计良好、并且很优雅，你就很可能会格外注意不去把它弄脏，而且你也不会想成为第一个弄脏代码的人。所以，为了提高自己以及团队的效率： 不要成为第一个弄脏代码的人（其他人自然也不会） 不要容忍不好的代码，及时重构（珍爱生命） 仰望星空有时候，你也许确切地知道需要做什么，以及怎么去做。但是请求许可去处理整个事情，你会遇到拖延和漠然，需要成立一个讨论组，然后大家开会发表意见，每个人都会去护卫自己的资源，事情越来越复杂。有个专门的名字形容这种情形“启动杂役”。这个时候，你需要设计出你可以合理要求的东西，好好开发它，一旦完成，就拿给大家看，让他们大吃一惊，然后说：“要是我们增加……可能就会更好”。那个时候，他们会主动找到你开始合作。 让人们瞥见未来，你就能让他们聚集在你周围 同时，你还需要保持敏感，多观察新的趋势、周围的环境、新技术等等，温水煮青蛙就完蛋了！ 我航校歌《仰望星空》确是真理~ 敏捷开发，不要过度修饰 欲求更好，常把好事变糟——李尔王 一个无视用户需求，一味地增加新疼醒、一次又一次润饰代码的程序员，不是一个有职业素养的程序员。所有的功能以及代码都是以产品为中心，而不是比谁写的代码炫酷。非常抱歉，本月在开发微信公众号时，我花了大量时间去写看起来很酷的动画、用尽可能新的技术，但是三天的开发期限一到，连基本功能都是还有问题的——以此为戒不要因为过度修饰和过于求精而毁损完好的程序，继续前进，让你的代码凭自己的质量站一会，它也许不完美，但不用担心：它不可能完美。 尽快完成基本功能，敏捷开发，快速迭代 预留充足的时间，而不是为了赶上最后期限而削减基本功能 持续学习，并保持多元化既然选择了程序员这一行业，那就学会享受活到老学到老。 程序员是一个人神奇的职业，技术变化很快，你需要及时更上或者创造新技术，同时你还需要眼观六路耳听八方，要知道互联网的趋势，也要关注各种新科技，哦，可能还要会运营、设计什么的。。。 当然，代码写不好其他都是浮云。 这里有一些学习建议： 每年至少学习一种语言：不同语言以不同方式解决相同的问题。通过学习若干不同的方法，可以帮你拓宽思维，避免墨守成规。 每个季度阅读一本技术书籍： 读书时让你升华为高手的捷径，在你技术掌握后，阅读一些与项目无关的书籍，扩宽眼界。 也要阅读非技术书籍：计算机是由人——你在设法满足其需要的人——使用的，不要忘了人这一边。每一次去书店，都会很舒服，那是我最好的放松。 听一听讲座或者沙龙：看一看那些高手在做什么（并非他们说的就是对的或者合适，但是你要自己去发现合适或者不合适的才知道自己如何选择），去认识不同的人，程序员也要有社交。 程序员其实是很容易交流的网上有很多调侃程序员的段子，大致都是说程序员木讷之类的，程序员要是真的难以交流，那些段子手哪能这么（好像）熟悉程序员的生活……程序员大多专注，老实，所以大家印象还是比较好，这应该算是程序员的优势了但是，表达能力可能却是稍差一些。我见过一个程序员，做工作汇报时，说了两句话，结束了，不知道老板有没有反应过来。。。 学会理解你的听众的水平 你的东西要让他们听懂，而不是自己一个人在那自言自语。其实没有什么特定要求，努力让自己多去说，不用怕说错，说得多了，自然就好了。 及时回复 如果你看到了邮件、微信、QQ的消息，希望能及时回复，即使内容只是“我稍后回复你”。你的时间很宝贵，别人的时间一样很宝贵， 随时通知别人，会让他们更容易原谅你偶然的疏忽，并让他们觉得你没有忘记他们。学会感恩，而对于某些不会尊重别人时间的人，你可以考虑移除了。 总结我相信每一个优秀的程序员都是追求完美的极客，尝试新的东西很好、深挖技术也对，只是时间有限，有了基础版本，才有可能不断去完善细节满足你的情怀。淘宝非一日之功，除了你技术，你还要对产品负责，学会敏捷快发。平时要保持学习的习惯，多看看新的东西，放宽眼界，程序员不要那么死板。 最后推荐一个github上Java程序员Shekhar Gulati的一个项目，《52-technologies-in-2016》，作者每周挑战并学习实践一项新技术，在写这篇文章的时候，作者已经完成了37个任务，你也可以尝试一下。 程序员的时间很宝贵，每个人的时间都很宝贵，节约生命，注重实效。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://www.voyax.me/tags/读书/"}]},{"title":"Web中文字体排版指南","slug":"Web中文字体排版指南","date":"2016-09-12T12:52:35.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/59710/","link":"","permalink":"http://www.voyax.meposts/59710/","excerpt":"前几年有一种说法，网页95%都是排版。这种说法，即使是现在，作为Web开发人员，我们也应该足够重视排版。有时候看到一个网页，就是觉得别扭，不好看，但是作为程序员真的不知道到底哪出了问题！要是有时间，你一定要读一下《写给大家看的设计书》，这本书里边讲了很多简单适用的设计原则，包括亲密性，对齐，重复，对比，颜色等简单适用的原则） 在没有设计师帮助下，排版和颜色经常是最让我头疼的事，怎么放怎么挑都觉得没有人家专业学设计的好看，但是后来发现，有一些规则，可以快速地让设计看起来更加专业。","text":"前几年有一种说法，网页95%都是排版。这种说法，即使是现在，作为Web开发人员，我们也应该足够重视排版。有时候看到一个网页，就是觉得别扭，不好看，但是作为程序员真的不知道到底哪出了问题！要是有时间，你一定要读一下《写给大家看的设计书》，这本书里边讲了很多简单适用的设计原则，包括亲密性，对齐，重复，对比，颜色等简单适用的原则） 在没有设计师帮助下，排版和颜色经常是最让我头疼的事，怎么放怎么挑都觉得没有人家专业学设计的好看，但是后来发现，有一些规则，可以快速地让设计看起来更加专业。 简单文字排版：http://www.lhyum.com/demo/lesson_1/ 字体选择好的字体，会帮助你的网页看起来更加输入自然。在网页中，中文字体的选择一直都是一个麻烦事，选择中文字体时，你需要考虑到： 用户本地的字体有限，你需要兼容不同的操作系统。对于Windows而言，可能就只有预装的宋体、黑体、楷体、仿宋、微软雅黑，如果你网页用了OS X的Helvetica，在Windows，用户实际看到的是Arial。 中文字体体积太大，使用Web Font好像不划算。英文就只有26个字母，但是中文常用汉字就有几千呀，为了看个几百K的网页，要下载几兆的字体，你觉得真的合适么？ 不同浏览器对字体的支持也不一样，还没有一种通吃所有浏览器的字体格式（这算是Web Font难做的原因） 解决方法基本有三个： 最简单的方法，老老实实制定安全的字体，利用好fallback。 寻找相似字体，你可以在CSS Font Stack，查找Windows和Mac上相似的字体 还是利用Web Font，推荐font spider，能够解决大小和兼容性的问题。 字蛛通过分析本地 CSS 与 HTML 文件获取 WebFont 中没有使用的字符，并将这些字符数据从字体中删除以实现压缩，同时生成跨浏览器使用的格式。 字体fallbackfont-family:&quot;Hiragino Sans GB&quot;,&quot;华文细黑&quot;,&quot;STHeiti&quot;,&quot;微软雅黑&quot;, &quot;Microsoft YaHei&quot;,SimHei,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; fallback俗称备胎，前边的字体没有（或者不包括要渲染的文字），就用后边的，如果所有列出的字体都没有，那么系统会自动匹配类似的字体（同一系列，网页上可以把字体划分为5类，具体请参见W3C）。注意：先指定英文字体，再指定中文字体。不然，渲染出来的是中文的英文和中文的中文(⊙﹏⊙)b（我们要的应该是英文的英文和中文的中文） 参考了苹果、小米、魅族、typebeauty后，整理如下：OS X上：HanHei SC，苹方(PingFang SC)Windows：中易宋体（SimSun），微软雅黑（Microsoft YaHei）Linux：思源黑体（Source Han Sans CN），文泉驿米黑（WenQuanYi Microhei）写成font-family：font-family: &quot;Helvetica Neue&quot;,Helvetica, Arial, &quot;HanHei SC&quot;, &quot;PingFang SC&quot;, SimSun,&quot;Source Han Sans CN&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Microhei&quot;, sans-serif; 字号我们先定一个基础字号16px（大部分浏览器默认的也是16px），16~24px之间的字号作为阅读都很舒服，都可以作为正文内容的大小。 不同等级的标题，需要用到不同的字号和粗细，反映出文章结构的变化。 h1{ font-size: 2.25em; } h2{ font-size: 2em; } h3{ font-size: 1.7em; } h4{ font-size: 1.4em; } h5, h6{ font-size: 1.2em; } 每行35-60个汉子一行中，如果字数太多，会给读者压迫感。字数太少，视线跳动太频繁，很容易让人疲倦。英文一般控制在40-90个单词，中文30-60个字。 行高1.5倍的行高目前是采用最广泛的，但是不同字体，给人感觉不一样，所以我一般采用1.8倍的行高，你可以根据自己的需要进行调整。需要注意的是，标题由于字体很大，如果再设置1.8的行高，换行会出现中间间距过大的问题，标题的行高要记得小一些： h1,h2,h3,h4,h5,h6{ line-height: 1.1em; font-weight: 300; } p{ line-height: 1.8em; } 段间距离h1, h2, h3, h4, h5, h6{ margin-bottom: .2em; margin-top: .7em; } p{ margin-bottom: 1.8em; } 颜色颜色和背景、字体、大小都息息相关。以最常见的白色背景为例，如果我们页面的字体比较粗，相对不那么深的黑色会让人更舒服，#555,#666都是不错的选择，如果你的字体很细，比如你采用PingFang SC，font-weight: 100，为了让你的网页更清楚，字体颜色不要超过#333。 待更新 rem 断字处理 扩展资料：Windows预装字体MAC OS X预装字体英文文字排版指南中英字体搭配寻找OS X和Windows下相似的字体计算字体缩放网页排版统计","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"《程序员修炼之道》读书笔记——如何靠自己成为高手","slug":"《从小工到专家》感","date":"2016-09-06T17:26:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/32156/","link":"","permalink":"http://www.voyax.meposts/32156/","excerpt":"","text":"成为高手需要条件“衣带渐宽终不悔，为伊消得人憔悴”，一个中手，没有码过几十万行代码，或者长期在一个高手的团队里打磨锤炼，无论理论多熟悉多能说，都只算是中手。而若是有高人点拨，很快就能蓦然回首。 但现实是，高手太少，能指导你的高手更少；读书和实践是弥补没有高手最好的方法。 在实践中主动回顾你大脑中的那些编程原则、技巧在大学你就该知道什么是面向对象，什么是软件工程，但是不经过实际项目的锤炼，很难真正理解面向对象的优雅所在。内化是一个非常复杂的认知过程，本身涉及大脑中mind set 和 paradign的切换，所以必然不是一个简单的隔夜就能完成的过程。但一旦切换完成，事件中自然会流漏出这种新的认识，也就是到了一个新的境界。（如果真的理解了，你会发现更多精妙有趣的技巧，已经可以主动输出知识了）。 学会将理论内化我们常常会“忘了”应该怎么正确地做一件事情（这里的忘了，指我们之前从书或者其他渠道看到的正确的原则或方法，但是在那一刻脑子里根本没有考虑过这个原则或方法，因为根本没有亲自实践过，所以根本不是自己的一部分，不属于自己）。但如果有人在恰当的时候讲这些原则或在方法给你指点出来，你会恍然大悟， 但是，当没有人指点的时候，要学会自己提醒自己。在阅读很多书的时候，不要想当然地以为，“啊，这个我知道了，啊，那个我了解了，嗯，这个以后要注意”，这样的阅读方式只会强化原有的自己已经知道的部分，而不大可能把“以后要注意”这东西全部内化。所以，自负的读者读完之后必然觉得“哈哈，高手不过如此，大部分我也知道嘛”，而不是“是的，我还有不少要注意”，这两种态度，就把高手和易于满足的中手永恒的分开了。 想要内化这些小声音，还是要靠事实践，即使你把这些小声音写在100块钱的高档笔记本上也没有用。 正确的做法是，先大致理解和记住里边的Tip，然后每周争取实践2-3个Tip，你需要 自动频繁地测试 别手动做繁琐的工作 保持良好的作息习惯其实再多的道理，如果没有实践都是纸上谈兵；而只是埋头写代码，看别人的博客，也很难以形成自己的知识体系。之所以很多企业不喜欢培训班出来的学院，不是因为他们不能干活，而是主动学习能力和即使没有太多项目经验的科班学生是不能比的，当扔给他们一个新的技术栈，很多人就和白纸一样，而你的leader需要看到的是有自己的知识体系和学习方法，能够快速利用现有的认知能力解剖这个新知识。而这种能力是建立在长期以来形成的良好思考习惯而非死记硬背下的。拿前端来说，你可以不会Angular，也可以不会React，但是你会的，需要看到你的深入和自己的东西。 所以呢，学代码，要实战+看书，两者都很重要。 现在创业中，还是要保持良好的作息习惯，白天工作写代码，觉得一知半解的，先解决问题，再放到专门整理的问题集中，晚上10点以后，就是解决问题，可能一个问题需要花好几天晚上，但是每天必须保持至少半个小时的读书时间。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://www.voyax.me/tags/读书/"}]},{"title":"《程序员修炼之道》读书笔记——如何靠自己成为高手","slug":"《程序员修炼之道》读书笔记——如何靠自己成为高手","date":"2016-09-06T17:26:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/32157/","link":"","permalink":"http://www.voyax.meposts/32157/","excerpt":"成为高手需要条件“衣带渐宽终不悔，为伊消得人憔悴”，一个中手，没有码过几十万行代码，或者长期在一个高手的团队里打磨锤炼，无论理论多熟悉多能说，都只算是中手。而若是有高人点拨，很快就能蓦然回首。但现实是，高手太少，能指导你的高手更少；读书和实践是弥补没有高手最好的方法。 在实践中主动回顾你大脑中的那些编程原则、技巧在大学你就该知道什么是面向对象，什么是软件工程，但是不经过实际项目的锤炼，很难真正理解面向对象的优雅所在。内化是一个非常复杂的认知过程，本身涉及大脑中mind set 和 paradign的切换，所以必然不是一个简单的隔夜就能完成的过程。但一旦切换完成，事件中自然会流漏出这种新的认识，也就是到了一个新的境界。（如果真的理解了，你会发现更多精妙有趣的技巧，已经可以主动输出知识了）。","text":"成为高手需要条件“衣带渐宽终不悔，为伊消得人憔悴”，一个中手，没有码过几十万行代码，或者长期在一个高手的团队里打磨锤炼，无论理论多熟悉多能说，都只算是中手。而若是有高人点拨，很快就能蓦然回首。但现实是，高手太少，能指导你的高手更少；读书和实践是弥补没有高手最好的方法。 在实践中主动回顾你大脑中的那些编程原则、技巧在大学你就该知道什么是面向对象，什么是软件工程，但是不经过实际项目的锤炼，很难真正理解面向对象的优雅所在。内化是一个非常复杂的认知过程，本身涉及大脑中mind set 和 paradign的切换，所以必然不是一个简单的隔夜就能完成的过程。但一旦切换完成，事件中自然会流漏出这种新的认识，也就是到了一个新的境界。（如果真的理解了，你会发现更多精妙有趣的技巧，已经可以主动输出知识了）。 如何实践我们常常会“忘了”应该怎么正确地做一件事情（这里的忘了，指我们之前从书或者其他渠道看到的正确的原则或方法，但是在那一刻脑子里根本没有考虑过这个原则或方法，因为根本没有亲自实践过，所以根本不是自己的一部分，不属于自己）。但如果有人在恰当的时候讲这些原则或在方法给你指点出来，你会恍然大悟，但是，当没有人指点的时候，要学会自己提醒自己。在阅读很多书的时候，不要想当然地以为，“啊，这个我知道了，啊，那个我了解了，嗯，这个以后要注意”，这样的阅读方式只会强化原有的自己已经知道的部分，而不大可能把“以后要注意”这东西全部内化。所以，自负的读者读完之后必然觉得“哈哈，高手不过如此，大部分我也知道嘛”，而不是“是的，我还有不少要注意”，这两种态度，就把高手和易于满足的中手永恒的分开了。想要内化这些小声音，还是要靠事实践，即使你把这些小声音写在100块钱的高档笔记本上也没有用。正确的做法是，先大致理解和记住里边的Tip，然后每周争取实践2-3个Tip，你需要 自动频繁地测试 别手动做繁琐的工作 对于我其实再多的道理，如果没有实践都是纸上谈兵；而只是埋头写代码，看别人的博客，也很难以形成自己的知识体系。之所以很多企业不喜欢培训班出来的学院，不是因为他们不能干活，而是主动学习能力和即使没有太多项目经验的科班学生是不能比的，当扔给他们一个新的技术栈，很多人就和白纸一样，而你的leader需要看到的是有自己的知识体系和学习方法，能够快速利用现有的认知能力解剖这个新知识。而这种能力是建立在长期以来形成的良好思考习惯而非死记硬背下的。拿前端来说，你可以不会Angular，也可以不会React，但是你会的，需要看到你的深入和自己的东西。所以呢，学代码，要实战+看书，两者都很重要。现在我的习惯是，白天工作写代码，觉得一知半解的，先解决问题，再放到专门整理的问题集中，晚上10点以后，就是解决问题，可能一个问题需要花好几天晚上，但是每天必须保持至少半个小时的读书时间。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://www.voyax.me/tags/读书/"}]},{"title":"Mac下安装配置redis","slug":"Mac下安装配置redis","date":"2016-08-29T12:31:13.000Z","updated":"2017-09-20T10:02:43.000Z","comments":true,"path":"/posts/22544/","link":"","permalink":"http://www.voyax.meposts/22544/","excerpt":"","text":"系统：OS X EI 10.11.6安装方式：Homebrew 安装$ brew install redis 开机启动$ ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents 额外补充 ln干嘛的 =&gt; 为文件创建连接，可以创建软链接和创建硬链接。通过参数-s创建软链接，软链接可以理解为Windows下的快捷方式，实际是路径path。不加参数默认创建硬链接，硬链接指向的是源文件的节点inode，所以修改文件会所有都会同步改变 关于删除的影响：我们所说的文件，并非实际存储空间，而是文件节点，操作系统通过i-node查找到文件的block。删除源文件对于硬链接来说是不会丢失文件，这是硬链接会变成普通文件；至于软链接和Windows上一样 更多有意思的讨论，详见ChinaUnix 另外launchctl是mac下用来定时执行任务的，而任务的具体的事件、时间等通过.plist指定 定制redis-server的配置文件$redis-server /usr/local/etc/redis.conf 设置密码在配置文件/usr/local/etc/redis.conf 设置 requirepass的值 一年没碰redis了，以前的配置已丢，暂时不需要，之后根据实际补充 卸载redis$ brew uninstall redis $ rm ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 查看redis是否启动$ redis-cli ping 如果输出PONG，redis已经启动了 启动、停止、重启 启动brew services start redis 停止stop brew services stop redis 重启restart brew services restart redis （之前有人说homebrew services被废了，但是现在又回来了，详见官方文档）","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://www.voyax.me/tags/环境配置/"}]},{"title":"分支管理规范","slug":"分支管理规范","date":"2016-08-12T15:04:05.000Z","updated":"2016-08-12T15:14:39.000Z","comments":true,"path":"/posts/undefined/","link":"","permalink":"http://www.voyax.meposts/undefined/","excerpt":"代码仓库Git规范，主要涉及Git分支管理策略，命名规范以及权限控制。每个团队成员必须遵循这些规范以保证开发的可靠。 分支策略如下图： 一个中心版本库，至少包括两个分支：master(主分支) 和 develop(开发分支) ；随着开发的需要，还包括三类 特性分支: feature branches(特性分支) release braches（预发布分支） hotfixes branches（热补丁分支）","text":"代码仓库Git规范，主要涉及Git分支管理策略，命名规范以及权限控制。每个团队成员必须遵循这些规范以保证开发的可靠。 分支策略如下图： 一个中心版本库，至少包括两个分支：master(主分支) 和 develop(开发分支) ；随着开发的需要，还包括三类 特性分支: feature branches(特性分支) release braches（预发布分支） hotfixes branches（热补丁分支） 主分支master只允许在master分支上保存完全稳定的代码。当release分支保持稳定状态，或者某些特性分支完成所有测试，合并入master分支，并且使用 版本号 打上 标签 。（master分支只有管理员拥有权限进行push） 开发分支develop开发分支与master分支平行，用于测试开发。开发中绝大多数分支都应该是源于develop分支 特性分支短期分支，用于实现单一特性或相关工作。开发完成后，合并到主干分支（develop或master），然后删除。特性分支 只存在 于开发者仓库，不出现在orgin中。基本步骤： 从develop 新建特性分支 git checkout -b feature-* develop 切换分支 git checkout develop 分支合并，注意 –no-ff git merge –no-ff feature-* 删除分支 git branch -d feature-* 分支命名规范：feature-*，function-*，feature-* 功能分支 feature来源：develop合并回： develop描述：用于开发特定功能。 热补丁分支 hotfixes来源： master合并回：develop和master描述：用于修复bug。注意： 创建热补丁后必须设置一个新的版本号（比如当前master分支tag V.1.2，提交绑定后标记V1.2.1） hotfixex 必须合并回master分值和develop分支，保证在下个版本中包含修复补丁。 预发布分支 release来源：develop合并回： develop和master命名： release-版本号描述：用于发布前的测试注意：release分支存在期间，如需新增功能，必须合并到develop分支，release保持当前版本特性。 Git学习资料git pro第二版","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.voyax.me/tags/git/"}]},{"title":"atom代码补全snippets配置","slug":"atom代码补全snippets配置","date":"2016-08-11T19:00:14.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/1758/","link":"","permalink":"http://www.voyax.meposts/1758/","excerpt":"snippets干嘛的目前对我来说，snippets有两个帮助： 提高敲代码的速度 维护一份好的代码模板 在atom中，许多核心插件都提供了自身对应的snippets，比如language-html提供了一些html语法的snippets，当输入html然后敲 tab 键，默认情况下将生成如下代码块： &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;","text":"snippets干嘛的目前对我来说，snippets有两个帮助： 提高敲代码的速度 维护一份好的代码模板 在atom中，许多核心插件都提供了自身对应的snippets，比如language-html提供了一些html语法的snippets，当输入html然后敲 tab 键，默认情况下将生成如下代码块： &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 而且你会注意到，此时光标将自动调到title之间，再次敲tab,光标将移动到body中。快捷键 Alt+Shift+S 可以帮助查看当前文档支持的所有snippets 定义自己的snippets：所有自定义的snippets都保存在snippets.cson中（atom打开的时候会自动加在这个文件）。 点击Atom选择Snippets将会打开这个文件（mac） 打开后可以看到基本说明和一个基础的配置样例： &#39;.source.js&#39;: &#39;console.log&#39;: &#39;prefix&#39;: &#39;log&#39; &#39;body&#39;: &#39;console.log(${1:&quot;crash&quot;});$2&#39; 我们定义的snippets按照所支持的文件进行分类，比如我们定义的所有JavaScript的snippets都定义在上边的key值为.source.js的对象中，如果出现重复的snippet key，那么只有最后声明的一个有效。 以上边的配置为例，具体说明一下： 文件类型选择（.source.js）： 第一行指定了snippets对应的文件类型：查看相应语言插件的Scope，在Scope的前边加上.就将当前的snippets的与对应的文件关联。 snippet名字(console.log)：这主要是为了方便我们理解，所以你想怎么取就怎么取了。 触发条件(prefix)：输入prefix设置的字符串，按下tab，就可以自动补充代码片段。 snippet的内容(body)：通过$可以设置光标的位置以及设置默认值。如果body有多行内容，需要用&quot;&quot;&quot;将其包裹起来。 根据自己需要定义html的snippets&#39;.text.html.basic&#39;: &#39;html&#39;: &#39;prefix&#39;: &#39;html&#39; &#39;body&#39;: &quot;&quot;&quot; &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;${1:My Site}&lt;/title&gt; &lt;!-- Disables zooming on mobile devices --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; $2 &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.voyax.me/tags/开发工具/"}]},{"title":"如何灵活在控制Flex Item在主轴上的布局","slug":"如何控制flex item在主轴上的布局","date":"2016-07-18T20:51:43.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/64197/","link":"","permalink":"http://www.voyax.meposts/64197/","excerpt":"先看一个案例：（这个例子最简单，但并非特别有针对性，更好的例子是三栏布局，第一栏左对齐，第二栏要求居中。）一个页面的头部，经常看到的是最左边放上logo，右边是几个导航链接。 采用Flexbox布局，可能这么写： HTML &lt;div class = &quot;header&quot;&gt; &lt;img class = &quot;header__logo logo&quot; src = &quot;./img/logo.png&quot; /&gt; &lt;ul class = &quot;nav&quot;&gt; &lt;li&gt; &lt;a href = &quot;#&quot; &gt;Link 1&lt;/a&gt; &lt;a href = &quot;#&quot; &gt;Link 2&lt;/a&gt; …… &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;","text":"先看一个案例：（这个例子最简单，但并非特别有针对性，更好的例子是三栏布局，第一栏左对齐，第二栏要求居中。）一个页面的头部，经常看到的是最左边放上logo，右边是几个导航链接。 采用Flexbox布局，可能这么写： HTML &lt;div class = &quot;header&quot;&gt; &lt;img class = &quot;header__logo logo&quot; src = &quot;./img/logo.png&quot; /&gt; &lt;ul class = &quot;nav&quot;&gt; &lt;li&gt; &lt;a href = &quot;#&quot; &gt;Link 1&lt;/a&gt; &lt;a href = &quot;#&quot; &gt;Link 2&lt;/a&gt; …… &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; CSS .header{ display: flex; flex-direction: row; justify-content: flex-start; } 现在logo和导航在header中按照从左往右布局。如何让导航在header的右端？ 为什么没有justify-self上述问题的解决的方法很多，只是如果你习惯了align-self，会不会情不自禁联想到justify-self，可惜啊，并没有这个属性——因为没有必要存在这个属性，我们通过其他两个属性完全可以实现类似align-self的功能： justify-content auto margins 先来看看W3C的原文：Aligning with ‘auto’ margins 8.1. Aligning with ‘auto’ margins This section is non-normative. The normative definition of how margins affect flex items is in the Flex Layout Algorithm section. Auto margins on flex items have an effect very similar to auto margins in block flow: During calculations of flex bases and flexible lengths, auto margins are treated as ‘0’. Prior to alignment via ‘justify-content’ and ‘align-self’, any positive free space is distributed to auto margins in that dimension. Overflowing elements ignore their auto margins and overflow in the end/foot direction. Note that, if free space is distributed to auto margins, the alignment properties will have no effect in that dimension because the margins will have stolen all the free space left over after flexing. 所以对于一个flex item，当设置margin auto，它的计算顺序如下： 先按照margin: 0 计算flex item的尺寸； 将所有父元素的剩余空间赋值给margin（margin的优先级大于justify-content，以及align-self。这有一个类似的场景：如何计算图片尺寸） 现在再看看如何修改我们上边的导航： .nav{ margin-left: auto; } 【译】更多的例子注：原文请看stackoverflow上的回答 第一个flex item居左，其余flex item居右 其他实用场景 将flex item放置在一个角上你会不会想这么写哈哈哈哈.box { align-self: flex-end; justify-self: flex-end; } 水平、垂直居中这次这玩意儿可是真的♪(^∇^*) .box56{ margin: auto; } 在flex item中，margin: auto 相当于在flexbox上设置了justify-center:center; align-items:center。 除了在container上应用如下样式： .container{ justify-content: center; align-items: center; } 你可以直接在flex item上使用margin： .box56{ margin: auto; } 当我们要居中一个大小超出父元素的子元素来说，利用margin:auto将非常有用(http://stackoverflow.com/questions/33454533/cant-scroll-to-top-of-flex-item-that-is-overflowing-container) 译者注：在flexbox中，当子元素超出了父元素，而且我们采用了align-items: auto和justify-content: center进行居中，会出现超出部门内容不可见的问题。比如说，flex item的高度是500px,而container高度是300；正常的情况是我们拉动垂直方向的滚动条，能够浏览flex item的全部内容；但实际上是，你只能看到flex item的部分内容，顶部的内容是看不到的（0-100这一部分），不管你怎么拉动滚动条（如果不好理解，自己写代码试试就知道了）。其中的原因是设置justify-content和align-items居中后，即使flex item超出container还是保持居中。 居中一个flex item， 然后将第二个flex item 放在第一个flex item 和父元素的边界之间 相关内容 Aligning two flex items: one to the top, the other centeredHow to center one of two flex items in a flex container?Flexbox: Align between bottom and center?How to center-align one flex item and right-align another using Flexbox 注：这两个方法只能针对高度（宽度）相同的flex items 有效。不同高度的解决方案，看下一个例子。 当相邻的flex item尺寸不同时，如何居中 场景描述：一行里边有三个flex items，将第二个item相对父元素居中（justify-content: center)，同时，相邻的两个元素在container的两侧(justify-self:flex-start和justify-self: flex-end)。 注意：当flex items大小不同时，将container的justify-content设置成space-around、space-between是不能让第二个flex item居中的。 正如上边提醒的，除非所有flex items高度或者宽度一致，否者中间的元素是没办法真正居中的。这个问题真的让人觉得justify-self很有必要呀！！！。 但是，目前来说，我们可以对flex item采用绝对定位，虽然绝对定位会使元素浮出文档流，并非完美，你也许还是会用得找的： 另外一个不采用绝对定位的方法： Keep one element truly centered between two elements of different widths in flexbox justify-content: space-same(这只是一个概念！！！别当真)再来看justify-content，我们还会经常碰到一个需求： space-same: space-between和space-around的中间产物(hybrid，词穷了。。。)。说白了其实很简单，就是相当于让flex items评分剩余的空间，同时让两侧的空白是等于相邻flex item间距的，而不是像space around那样等于一半。 来来来，用伪元素解决这个问题：","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"ife前端任务-定位和居中","slug":"ife前端任务-定位和居中","date":"2016-05-03T03:19:24.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/20965/","link":"","permalink":"http://www.voyax.meposts/20965/","excerpt":"","text":"任务介绍 任务目标 实践HTML/CSS布局方式深入了解position等CSS属性 任务描述 实现如 示例图（点击打开） 的效果灰色元素水平垂直居中，有两个四分之一圆位于其左上角和右下角。 任务注意事项 思考不同情况下（如灰色高度是根据内容动态变化的）水平垂直居中的解决方案。动手试一试各种情况的组合，父元素和子元素分别取不同的 position 值。思考 position 属性各种取值的真正含义，尤其是 absolute 究竟是相对谁而言的。注意测试不同情况，尤其是极端情况下的效果。调节浏览器宽度，灰色元素始终水平居中。调节浏览器高度，灰色元素始终垂直居中。调节浏览器高度和宽度，黄色扇形的定位始终准确。其他效果图中给出的标识均被正确地实现，错一项扣一分。 题目解析此题注意： 水平居中和垂直居中的各种实现方式和应用场景，具体参考CSS居中完全指南 理解border-radius的四个属性( border-top-left-radius, border-top-right-radius, border-bottom-right-radius 以及 border-bottom-left-radius)及取值。参考MDN 上border-radius 实现效果及代码 效果 ：http://voyax.me/ife2016_task/task4/index.html 代码","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"The best of best","slug":"the-best-of-best-0","date":"2016-05-02T05:29:30.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/55105/","link":"","permalink":"http://www.voyax.meposts/55105/","excerpt":"读书的时候，好像没什么是大不了的 回到家，都会好","text":"读书的时候，好像没什么是大不了的 回到家，都会好 工作了，回家比大学来得勤，只是现在每次爷爷、爸妈问，什么时候家呀，已经答不上话了 好多东西，怕 若无其事地给爷爷打电话，问着爷爷吃饭了吗，吃的什么呀，身体还好吗。等我没话可说了，爷爷说，“在外边是不是遇到什么事了，不要憋在心里，虽然公老了不懂你现在做的，我和你爸爸都会支持你。你自己的项目有信心啦嘛”。 一边小跑着上楼顶，一边说，“嗯，没撒子，就是打电话问问你跟婆；都好都好”。 听着爷爷的声音，就能像以前读书那样，心安 The best of best","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"The best of best","slug":"The-best-of-best","date":"2016-05-02T05:29:12.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/55104/","link":"","permalink":"http://www.voyax.meposts/55104/","excerpt":"读书的时候，好像没什么是大不了的回到家，都会好","text":"读书的时候，好像没什么是大不了的回到家，都会好 工作了，回家比大学来得勤，只是现在每次爷爷、爸妈问，什么时候家呀，已经答不上话了 好多东西，怕 若无其事地给爷爷打电话，问着爷爷吃饭了吗，吃的什么呀，身体还好吗。等我没话可说了，爷爷说，“在外边是不是遇到什么事了，不要憋在心里，虽然公老了不懂你现在做的，我和你爸爸都会支持你。你自己的项目有信心啦嘛”。一边小跑着上楼顶，一边说，“嗯，没撒子，就是打电话问问你跟婆；都好都好”。听着爷爷的声音，就能像以前读书那样，心安 要举重若轻 The best of best","categories":[],"tags":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/tags/365/"}]},{"title":"[译]CSS居中完全指南","slug":"译-CSS居中完全指南","date":"2016-04-19T15:46:40.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/10282/","link":"","permalink":"http://www.voyax.meposts/10282/","excerpt":"原文地址:https://css-tricks.com/centering-css-complete-guide/ 居中是CSS中的一大难题。经常会听见有人抱怨，为何CSS居中如此困难。在我看来，其实并非居中困难，难的是我们如何根据不同情况选择合适的居中方式。 在这，我们建立一个决策树，帮助大家更容易的掌握CSS居中的方法。 水平居中居中元素是否是inline 或者 inline-*（好比文本或者链接）通过text-align将块级元素中的行内元素居中： .center-children{ text-align: center; }","text":"原文地址:https://css-tricks.com/centering-css-complete-guide/ 居中是CSS中的一大难题。经常会听见有人抱怨，为何CSS居中如此困难。在我看来，其实并非居中困难，难的是我们如何根据不同情况选择合适的居中方式。 在这，我们建立一个决策树，帮助大家更容易的掌握CSS居中的方法。 水平居中居中元素是否是inline 或者 inline-*（好比文本或者链接）通过text-align将块级元素中的行内元素居中： .center-children{ text-align: center; } 这样可以便可以将display为inline,inline-block,inline-table,inline-flex的元素居中。 关于text-align：text-align会影响有一个元素中的文本对其方式，需要注意的是text-align是应用于块级元素，改变块级元素中内容的对其方式，而且text-allign是拥有继承性的，vertical-align是没有继承性的（vertical-align应用于行内元素和表单元素，还要继承干嘛`）。（voya注） 是否是块级元素设置margin-left和margin-right为auto（并且width给定值，否则宽度将充满父元素，居中也就无意义了）。代码如下： .center-me{ margin: 0 auto; } 这种方法对要居中的元素和其父元素的宽度都没有要求。（译者注，明白水平格式化中margin-left,margin-right以及width的关系，如果还迷糊，赶紧看《CSS权威指南》第七章，会帮你解决很多奇葩问题） 需要注意的是，通过float是不能实现居中的。但是，这有一个利用浮动居中的小技巧。 居中多个块级元素？如果在一行中需要对多个块级元素居中，可以通过设置display来实现。下边分别提供了将display设置为inline-block和flexbox的两种例子。 如果居中的这些块元素是从上让下排列而且放置在同一行，那么，auto margin(left/right)仍然适用： 垂直居中垂直居中相对会麻烦一些。 是否是inline或者inline-*（好比文本或者链接）？单行设置相同的上下内边距可以是inline/text元素居中。 .link{ padding-top: 30px; padding-bottom: 30px; } 当因为其他某些因素，不能采用padding，也没有换行的时候，可以通过设置line-height等于height达到居中效果。 .center-text-trick { height: 100px; line-height: 100px; white-space: nowrap; } 多行对于多行文本垂直居中，同样可以采用设置相同的上下内边距；当无法通过设置padding达到效果时，可以按照table cell格式布局需要居中的文本元素。这种情况下，采用vartical-align处理居中与在单行中有所不同。（vertical-align详解） 有时候我们不希望采用表格布局的方法，那么可能可以可以采用flexbox。在flex-parent居中flex-child非常简单。 .flex-center-vertically { display: flex; justify-content: center; flex-direction: column; height: 400px; } 注意，只有当父元素设定了高度（指定px或者百分数等等），子元素才能相应居中。 如果以上方法都不适用，还有“幽灵元素”这一招：为父元素创建一个高度为100%伪元素，设置文本根据这个伪元素居中。 .ghost-center { position: relative; } .ghost-center::before { content: &quot; &quot;; display: inline-block; height: 100%; width: 1%; vertical-align: middle; } .ghost-center p { display: inline-block; vertical-align: middle; } 是否是块级元素？元素高度确定在页面布局中，诸多原因让我们无法确定元素的高度；比如说，随着宽度变化，文本回流重绘将改变容器高度；字体样式改变、文本内容的增减以及改变比例固定元素（例如图片）的尺寸等等都会导致高度的变化。 但是！万一真的不幸确定高度哈哈哈，那么可以采用下面的方法： .parent { position: relative; } .child { position: absolute; top: 50%; height: 100px; margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */ } 元素高度无法确定在未知元素高度的情况下，依然可以做到垂直居中：将元素下移其父元素高度的一半，然后向上移动其自身一半的高度。 .parent { position: relative; } .child { position: absolute; top: 50%; transform: translateY(-50%); } 采用flexbox正如我们期待的，在flexbox中居中将是非常容易的： .parent { display: flex; flex-direction: column; justify-content: center; } 垂直居中 + 水平居中你可以尝试将上诉方法进行任意的组合，从而达到理想的居中效果。大致可以分为以下三种情况： 宽度和高度固定利用绝对定位，水平和垂直方向进行50%(父元素的50%)的偏移，然后设置水平和垂直方向上50%的负边距，即可跨浏览器实现居中。 .parent { position: relative; } .child { width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; } 宽度或高度不确定在无法确定元素宽度或者高度的情况下，利用transform属性，设置水平和垂直方向移动-50%(translate(-50%, -50%);)（translate的偏移值根据元素的实际宽度和高度进行计算）。 .parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 采用flexboxflexbox进行居中，需要利用到两个属性： .parent { display: flex; justify-content: center; align-items: center; } 总结相信你现在已经可以游刃有余地操作居中了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"ife前端任务-三栏布局","slug":"ife前端任务-三栏布局","date":"2016-04-17T14:42:41.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/279/","link":"","permalink":"http://www.voyax.meposts/279/","excerpt":"任务介绍 任务目标 掌握HTML/CSS布局的概念掌握盒模型的概念掌握position与float的概念以及在布局时的用法 任务描述 使用 HTML 与 CSS 按照 示例图（点击查看） 实现三栏式布局。左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。","text":"任务介绍 任务目标 掌握HTML/CSS布局的概念掌握盒模型的概念掌握position与float的概念以及在布局时的用法 任务描述 使用 HTML 与 CSS 按照 示例图（点击查看） 实现三栏式布局。左右两栏宽度固定，中间一栏根据父元素宽度填充满，最外面的框应理解为浏览器。背景色为 #eee 区域的高度取决于三个子元素中最高的高度。 任务注意事项 尝试 position 和 float 的效果，思考它们的异同和应用场景。注意测试不同情况，尤其是极端情况下的效果。图片和文字内容请自行替换，尽可能体现团队的特色。调节浏览器宽度，固定宽度和自适应宽度的效果始终符合预期。改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度。其他效果图中给出的标识均被正确地实现。 题目解析此题需要注意两点： 三栏布局中，中间栏宽度自适应 父元素高度由三栏中最高元素确定 考虑两种实现方案： BFC 负边距 BFC结合浮动和BFC，非常简单的可以满足题目要求，具体说明参见谈谈BFC 负边距利用负边距的原理很简单，但必须先清楚float的排列方式：浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动（或右浮动）元素的（右）边界，除非后出现浮动元素的顶端在先出现浮动元素的底端下面。（关于浮动元素的更多内容，看《CSS权威指南 第三版》第10章 浮动和定位） 利用负边距，我们可以将本身需要换行的浮动元素放到上一行。 实现效果及代码 三栏布局效果 ：http://voyax.me/ife2016_task/task3/index.html 三栏布局代码","categories":[],"tags":[]},{"title":"谈谈BFC","slug":"谈谈BFC","date":"2016-04-10T16:06:22.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/44803/","link":"","permalink":"http://www.voyax.meposts/44803/","excerpt":"BFC牵扯了许多东西，能力时间有限，将逐渐补充先关内容。 什么是BFCBFC（Block Formating Context）被称为块级格式化上下文。直白来讲，BFC只是一个概念，但凡符合这个定义的，便遵循BFC的渲染规则。 官网描述如下： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. 也就是说，浮动、绝对定位元素（position 为 absolute 或 fixed）、行内块元素 display:inline-block、表格单元格 display:table-cell、表格标题 display:table-caption 以及 overflow 属性值不为 visible 的元素（除了该值被传播到视点 viewport 的情况）将创建一个新的块级格式化上下文。","text":"BFC牵扯了许多东西，能力时间有限，将逐渐补充先关内容。 什么是BFCBFC（Block Formating Context）被称为块级格式化上下文。直白来讲，BFC只是一个概念，但凡符合这个定义的，便遵循BFC的渲染规则。 官网描述如下： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. 也就是说，浮动、绝对定位元素（position 为 absolute 或 fixed）、行内块元素 display:inline-block、表格单元格 display:table-cell、表格标题 display:table-caption 以及 overflow 属性值不为 visible 的元素（除了该值被传播到视点 viewport 的情况）将创建一个新的块级格式化上下文。 In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. 在BFC内，盒子从包含块（这个概念要清楚(⊙o⊙)哦）顶端开始，按垂直方向一个接一个排列。相邻两个盒子之间的垂直距离有margin决定，但并非简单的两个margin之和，而是采用所谓的外边距折叠（Collapsing Margins ） In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC中，每个盒子的左外边距紧贴包含块（对于从右往左的布局中，正好相反）。需要注意的是，即使是浮动元素，也遵循这个规则，除非我们为这个盒子新建了一个BFC。 BFC 规则概述根据官方描述，对BFC触发条件以及渲染规则总结： 如何创建BFC 浮动：float不为none postion等于absolute或者flex display等于table-cell、table-caption、inline-block、flex 或 inline-flex overflow不为visible 这几个条件各有利弊，结合具体情况灵活使用。 BFC特性 属于同一BFC的相邻元素会发生外边距折叠（换句话说，如果不属于同一个BFC，那就不会折叠了） BFC中的float元素会撑开容器 在BFC中，每个盒子的左外边距紧贴包含块 BFC应用举例——多栏布局借用百度ife的一个任务： 效果图： 要求：改变中间一栏的内容长度，以确保在中间一栏较高和右边一栏较高时，父元素的高度始终为子元素中最高的高度 此题有多种优秀解决方案，在这我们关注如何利用BFC解决（这也是目前我认为此题最简单的解法）。 解题思路： 我们先让左侧和右侧站好位，剩下的空间给中间的模块。左侧和右侧的两个盒子，那就直接采用float。但是有两个需要解决的地方： 一个元素浮动时，其他内容会“环绕”该元素。结果就是如果两个侧栏的高度小于中间栏，那中间栏就会环绕两个侧栏了。 浮动元素已经从文档的正常流中删除，存在高度塌陷。当左右侧栏的高度均大于中间栏的高度，父元素高度无法撑开。 如何解决 避免环绕：首先要明白为何会存在“环绕”，原因在于，在BFC中，每个盒子的左外边距紧贴包含块的左侧。 解决方法也很清楚了，让中间栏创建一个新的BFC就可以了。 高度：上文说过，BFC可以包含浮动元素；所以只要为父元素创建BFC够了。 HTML代码 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left-box&quot;&gt; &lt;img src=&quot;img/logo.jpeg&quot; /&gt; &lt;h2&gt;九歌&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;right-box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;img/qiu.jpeg&quot; alt=&quot;秋&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/rui.png&quot; alt=&quot;瑞&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/voya.jpeg&quot; alt=&quot;运&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;center-box&quot;&gt; &lt;h2&gt;关于我们&lt;/h2&gt; &lt;p&gt;一张褪色的照片 好像带给我一点点怀念 巷尾老爷爷卖的热汤面 味道弥漫过旧旧的后院 流浪猫睡熟在摇晃秋千 夕阳照了一遍他咪着眼 那张同桌寄的明信片 安静的躺在课桌的里面 快要过完的春天 还有雕刻着图案的门帘 窄窄的长长的过道两边 老房子依然升起了炊烟 刚刚下完了小雨的季节 爸妈又一起走过的老街 记不得哪年的哪一天 很漫长又很短暂的岁月 现在已经回不去 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS .container{ margin:20px; border: #999; background: #eeeeee; overflow: hidden; padding: 20px; } img{ height: 80px; width: 80px; } .left-box,.center-box,.right-box{ border: 1px solid #999; padding: 20px; background: #fff; } .left-box{ float: left; width: 158px; margin-right: 20px; } .left-box img{ float: left; } .left-box h2{ overflow: hidden; padding-left: 20px; } .right-box{ float: right; box-sizing: 120px; margin-left: 20px; text-align: center; } .center-box{ overflow: hidden; }","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"关于ES6中let关键字的疑惑","slug":"关于ES6中let关键字的疑惑","date":"2016-03-06T02:51:24.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/38426/","link":"","permalink":"http://www.voyax.meposts/38426/","excerpt":"一段熟悉的代码： function createFunctions(){ var result = new Array(); for(var i = 0;i &lt; 10;i++){ result[i] = function(){ console.log(i); }; } return result; } var functions = createFunctions(); functions[2](); //10 上述代码输出结果为10。 觉得理所应当或者有所疑惑都很正常，请继续往下看：","text":"一段熟悉的代码： function createFunctions(){ var result = new Array(); for(var i = 0;i &lt; 10;i++){ result[i] = function(){ console.log(i); }; } return result; } var functions = createFunctions(); functions[2](); //10 上述代码输出结果为10。 觉得理所应当或者有所疑惑都很正常，请继续往下看： function createFunctions2(){ &#39;use strict&#39;; var result = new Array(); for(let i = 0;i &lt; 10;i++){ result[i] = function(){ console.log(i); } } return result; } createFunctions2()[2](); //2 输出结果为2。 因为这里边涉及闭包的使用，对闭包理解不够透彻的人，很有可能认为是因为 闭包 的因素；但问题的实质在于 作用域。 一 先说采用var声明的这段代码ES6之前，JavaScript只有全局作用域和函数作用域，没有块级作用域的概念。但ES6中的let让JavaScript有了块级作用域。 在第一段代码中，变量i实际是在createFunctions中创建，在函数内部都可以进行访问（理解这一句其实问题就解决了）。 来看下具体过程：每次循环创建一个新函数result[i]，由于var i的作用域是createFunctions,所以每次新建的函数都是引用的createFunctions活动对象中的i；这个i一直都是指向同一个地址；所以当i的值变化，result[x]中的i值自然也随之而变。 明白？ 简单来说，因为var i的作用域是createFunctions，而非{}，它一直都没被销毁。 我们只是用闭包来描述了具体的过程，但闭包不是问题的答案。 咱别晕在闭包上+_+；如需要补充闭包的知识，请认真理解 变量对象,活动对象，作用域链这三个概念以及他们之间的关系，当你能用图把他们之间的关系描述清楚，那闭包就透彻了。 二 看let这段代码，这段代码其实并不简单。for(let i =0;i &lt; 10;i++){ ... } 1. 每次for循环i是同一个i吗？当然不是，我们说过，let是块级作用域。let声明的变量只在它所在的代码块有效。 引用MDN的描述： let allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope. 所以，每进行一次循环，i都是一个全新的变量，i只在当前循环有效。 如果没问题，继续看下一个问题。 2. 既然每次i都是全新的变量，凭啥能记录循环的状态当我们在for语句中使用let的时候，其实会自动对循环变量名进行绑定；然后创建一个局部作用域：在这里边，定义循环变量以及保存之前计算所得的循环变量的结果。 执行完循环体中的代码后，在进入下一次循环时，新建一个局部循环变量，利用上一次保存的最新结果进行初始化。 代码描述如下：(参看stackoverflow上的回答) { let i; i = 0; __state = {i}; } { let {i} = __state; if(i &lt; 10){ ... //循环体代码 __state = {i}; } } { let {i} = __state; i++; if(i &lt; 10){ ... __state = {i}; } } { let {i} = __state; i++; ... } 明白了吧，其实很简单，只是概念有点蹦。 三 如果明白了，那如何用var实现第二段代码的功能？是的，关键在于模拟块级作用域，简单吧O(∩∩)O~~) function createFunctions3(){ var result = new Array(); for(var i = 0;i &lt; 10;i++){ (function(c){ result[i] = function(){ console.log(c); } })(i); } return result; } var functions = createFunctions3(); functions[2](); //10","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.voyax.me/tags/JavaScript/"}]},{"title":"函数表达式-JavaScript","slug":"函数表达式-JavaScript","date":"2016-01-11T09:04:06.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/12846/","link":"","permalink":"http://www.voyax.meposts/12846/","excerpt":"","text":"一.函数表达式两种定义方式 函数声明 function functionName(arg0,arg1,arg2){ //函数体 } 函数表达式 var functionName = function(arg0,arg1,arg2){ //函数体 } 函数声明提升 理解函数声明和函数表达式的区别的重要一点就是理解函数声明提升 函数声明提升 是指在执行代码之前，会先读取函数声明 const _ = { once: once, }; var once = function(func){ var flag = false; var res; return function(){ if(flag){ return res; } else{ flag = true; res = func(); return res; } } } module.exports = _; 变量声明是提前了，但once: once的时候，once是undefined;用函数表达式时的时候需要注意执行顺序 二.闭包2.1 闭包与变量2.2 this内存泄露function assignHandler(){ var element = document.getElementById(&#39;someElement&#39;); element.onclick = function(){ alert(element.id); } }","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.voyax.me/tags/JavaScript/"}]},{"title":"（转|译）在AngularJS中使用的表单验证功能","slug":"在AngularJS中使用的表单验证功能","date":"2015-08-06T10:29:55.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/45363/","link":"","permalink":"http://www.voyax.meposts/45363/","excerpt":"验证功能是AngularJS里面最酷炫的功能之一，它可以让你写出一个具有良好用户体验的Web应用。 在AngularJS中，有许多用于验证的指令。我们将先学习几个最流行的内置指令，然后再创建一个自定义验证规则的指令。 &lt;form name=&quot;form&quot;&gt; &lt;label name=&quot;email&quot;&gt;Your email&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; placeholder=&quot;Email Address&quot; /&gt; &lt;/form&gt; AngularJS可以让我们轻松的处理客户端验证。虽然我们不能仅靠客户端验证来保证我们Web应用的安全性，但他们提供了良好用户体验。","text":"验证功能是AngularJS里面最酷炫的功能之一，它可以让你写出一个具有良好用户体验的Web应用。 在AngularJS中，有许多用于验证的指令。我们将先学习几个最流行的内置指令，然后再创建一个自定义验证规则的指令。 &lt;form name=&quot;form&quot;&gt; &lt;label name=&quot;email&quot;&gt;Your email&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; placeholder=&quot;Email Address&quot; /&gt; &lt;/form&gt; AngularJS可以让我们轻松的处理客户端验证。虽然我们不能仅靠客户端验证来保证我们Web应用的安全性，但他们提供了良好用户体验。 我们首先必须确保form上标签有一个name属性，像上面的例子一样。 我们可以进行一些基本的验证，例如最小长度，最大长度，等等，这些都是HTML5自带的属性验证功能。 Tips:通常需要在form标签中加上novalidate属性，这样可以禁用浏览器自带的验证功能，从而使用AngularJS提供的。 下面来看看我们可以在input中设置哪些验证： 必填验证是否已输入文字，只需在标签上加上required： &lt;input type=&quot;text&quot; required /&gt; 最小长度验证至少输入{number}个字符，使用指令ng-minlength=&quot;{number}&quot;： &lt;input type=&quot;text&quot; ng-minlength=5 /&gt; 最大长度验证至多输入{number}个字符，使用指令ng-maxlength=&quot;{number}&quot;： 正则匹配确保输入匹配一个正则表达式，使用指令ng-pattern=&quot;/PATTERN/&quot;: &lt;input type=&quot;text&quot; ng-pattern=&quot;/a-zA-Z/&quot; /&gt; Email验证输入是一个Email，设置input的type属性为email： &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;user.email&quot; /&gt; 数字验证输入是一个数字，设置input的type属性为number： &lt;input type=&quot;number&quot; name=&quot;number&quot; ng-model=&quot;user.age&quot; /&gt; Url验证输入是一个URL，设置input的type属性为url： &lt;input type=&quot;url&quot; name=&quot;homepage&quot; ng-model=&quot;user.facebook_url&quot; /&gt; 自定义验证AngularJS可以很容易的使用指令来添加自定义验证。例如，我们要验证我们的用户名是可用的（在数据库中不重复）。要做到这一点，我们将实现一个指令，它在输入字符变化时触发一个Ajax请求： var app = angular.module(&#39;validationExample&#39;, []); app.directive(&#39;ensureUnique&#39;, [&#39;$http&#39;, function($http) { return { require: &#39;ngModel&#39;, link: function(scope, ele, attrs, c) { scope.$watch(attrs.ngModel, function() { $http({ method: &#39;POST&#39;, url: &#39;/api/check/&#39; + attrs.ensureUnique, data: {&#39;field&#39;: attrs.ensureUnique} }).success(function(data, status, headers, cfg) { c.$setValidity(&#39;unique&#39;, data.isUnique); }).error(function(data, status, headers, cfg) { c.$setValidity(&#39;unique&#39;, false); }); }); } } }]); 验证表单状态AngularJS将DOM验证的结果保存在$scope对象中。这使我们能够实时做出一些处理。提供给我们的属性有： 请注意，这是这个属性的格式： formName.inputFieldName.property 未修改过的表单表示用户是否修改了表单。如果为ture，表示没有修改过： formName.inputFieldName.$pristine; 修改的表单当且用户是否已经修改过表单： formName.inputFieldName.$dirty 经过验证的表单表示否通过验证：formName.inputFieldName.$valid 未通过验证的表单表示否通过验证。如果表单当前没有通过验证，他将为true： formName.inputFieldName.$invalid 最后两个属性在用于DOM元素的显示或隐藏时是特别有用的。当然，如果想要设置特定的class时，他们也是非常有用的。 错误另一个有用的属性是AngularJS提供的$error对象。这个对象包含每一个无效的input验证的集合。为了访问这个属性，使用下面的语法： formName.inputfieldName.$error 如果验证失败，则此属性将是true的(因为length&gt;0)。 控制验证时的样式当AngularJS处理的验证时，它将根据验证的状态增加一些特定的class属性。 这些class是: .ng-pristine {} .ng-dirty {} .ng-valid {} .ng-invalid {} 这些class对应着其对应的验证对象的结果。 当一个字段是无效的，.ng-invalid将被应用到这个字段上。我们可以通过css来设置这些class的样式: input.ng-invalid { border: 1px solid red; } input.ng-valid { border: 1px solid green; } 全部放一起试试让我们编写一个注册表单。本申请表单将包括姓名，Email，以及用户名。 让我们定义一个form表单:&lt;form name=&quot;signup_form&quot; novalidate ng-submit=&quot;signupForm()&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Signup&lt;/legend&gt; &lt;button type=&quot;submit&quot; class=&quot;button radius&quot;&gt;Submit&lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; 这个表单的名字是signup_form ，当我们点击提交时我们将调用signupForm()方法. 现在，让我们添加用户的Name:&lt;div class=&quot;row&quot;&gt; &lt;div&gt; &lt;label&gt;Your name&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=3 ng-maxlength=20 required /&gt; &lt;/div&gt; &lt;/div&gt; 我们增加了一个名字为name的输入框，并且将对象绑定在$scope对象的signup.name对象上（通过ng-model）。 我们还设置了几个验证。这些验证分别是：必须有一个长度为3或更多的名字。并且最大长度限制为20个字符。最后，名称应该是必填的。 让我们用属性来控制显示还是隐藏错误信息。我们还将使用$dirty属性，以确保当用户没有输入字符前错误信息不会显示： &lt;div class=&quot;row&quot;&gt; &lt;div&gt; &lt;label&gt;Your name&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=3 ng-maxlength=20 required /&gt; &lt;div class=&quot;error&quot; ng-show=&quot;signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid&quot;&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.required&quot;&gt; Your name is required. &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.minlength&quot;&gt; Your name is required to be at least 3 characters &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.maxlength&quot;&gt; Your name cannot be longer than 20 characters &lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 在之前，当输入内容改变时它只能告诉我们我们输入是否有效。现在，我们将看到当那些没有通过的验证时的错误信息。 让我们接着看Email验证:&lt;div class=&quot;row&quot;&gt; &lt;div&gt; &lt;label&gt;Your email&lt;/label&gt; &lt;input type=&quot;email&quot; placeholder=&quot;Email&quot; name=&quot;email&quot; ng-model=&quot;signup.email&quot; ng-minlength=3 ng-maxlength=20 required /&gt; &lt;div class=&quot;error&quot; ng-show=&quot;signup_form.email.$dirty &amp;&amp; signup_form.email.$invalid&quot;&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.email.$error.required&quot;&gt; Your email is required. &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.email.$error.minlength&quot;&gt; Your email is required to be at least 3 characters &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.email.$error.email&quot;&gt; That is not a valid email. Please input a valid email. &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.email.$error.maxlength&quot;&gt; Your email cannot be longer than 20 characters &lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 这一次，我们增加了Email字段。请注意，我们设置了input的type属性为email并且添加了$error.email错误信息。这是基于AngularJS的Email验证（使用了HTML5属性）。 最后，让我们来看看在我们的最后一个验证，用户名：&lt;div&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Desired username&quot; name=&quot;username&quot; ng-model=&quot;signup.username&quot; ng-minlength=3 ng-maxlength=20 ensure-unique=&quot;username&quot; required /&gt; &lt;div class=&quot;error&quot; ng-show=&quot;signup_form.username.$dirty &amp;&amp; signup_form.username.$invalid&quot;&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.username.$error.required&quot;&gt;Please input a username&lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.username.$error.minlength&quot;&gt;Your username is required to be at least 3 characters&lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.username.$error.maxlength&quot;&gt;Your username cannot be longer than 20 characters&lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.username.$error.unique&quot;&gt;That username is taken, please try another&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; 在我们的最后一个字段，我们使用之前编写的自定义验证指令： app.directive(&#39;ensureUnique&#39;, [&#39;$http&#39;, function($http) { return { require: &#39;ngModel&#39;, link: function(scope, ele, attrs, c) { scope.$watch(attrs.ngModel, function() { $http({ method: &#39;POST&#39;, url: &#39;/api/check/&#39; + attrs.ensureUnique, data: {&#39;field&#39;: attrs.ensureUnique} }).success(function(data, status, headers, cfg) { c.$setValidity(&#39;unique&#39;, data.isUnique); }).error(function(data, status, headers, cfg) { c.$setValidity(&#39;unique&#39;, false); }); }); } } }]); 当表单输入是有效的时，它将发送POST api/check/username请求到服务器来检查用户名是否可用。很明显，因为我们在这里只谈论前端代码，我们写后端代码，尽管很容易。 更新:根据评论，我加入了服务器超时检查。要查看完整的源代码，请点击here。 最后，我们加上提交按钮，根据验证是否有效使用ng-disabled来控制按钮的禁用和启用： &lt;button type=&quot;submit&quot; ng-disabled=&quot;signup_form.$invalid&quot; class=&quot;button radius&quot;&gt;Submit&lt;/button&gt; 正如我们上面所说的，表单是否有效的属性$invalid给我们提供了便利。 更新 2:虽然及时验证很棒，它可以立即提醒用户，但是当他们正在输入很长的能通过验证的文字时，他们将在输入中途看到错误提示。有更好的方式来处理验证：当用户点击提交时，或者当他们将光标移开输入框之后。让我们来看看这2种方式。 点击提交后显示验证信息要在用户试图提交表单时显示的验证，你可以通过在scope中设置一个’submitted’值，并检查该值来控制显示错误。 让我们来看看第一个例子，只有在点击提交表单时才显示错误。使用ng-show指令来控制显示，我们可以添加一个检查，看是否已点击提交按钮： &lt;form name=&quot;signup_form&quot; novalidate ng-submit=&quot;signupForm()&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Signup&lt;/legend&gt; &lt;div class=&quot;row&quot;&gt; &lt;div&gt; &lt;label&gt;Your name&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=3 ng-maxlength=20 required /&gt; &lt;div class=&quot;error&quot; ng-show=&quot;signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid &amp;&amp; signup_form.submitted&quot;&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.required&quot;&gt; Your name is required. &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.minlength&quot;&gt; Your name is required to be at least 3 characters &lt;/small&gt; &lt;small class=&quot;error&quot; ng-show=&quot;signup_form.name.$error.maxlength&quot;&gt; Your name cannot be longer than 20 characters &lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;button radius&quot;&gt;Submit&lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; 现在，那个错误信息只将在signup_form.submitted为true时才显示。我们可以这样实现signupForm方法： app.controller(&#39;signupController&#39;, [&#39;$scope&#39;, function($scope) { $scope.submitted = false; $scope.signupForm = function() { if ($scope.signup_form.$valid) { // Submit as normal } else { $scope.signup_form.submitted = true; } } }]); 现在，当用户尝试提交表单并且同时有一个无效的元素时，你可以捕获它，并告诉他们错误的原因。 当时去焦点时验证错误如果你想保留错误验证的实时性，那么可以在用户离开该输入框时显示错误信息。要做到这一点，我们可以添加一个指令，将添加一个新的变量。 我们使用ngFocus指令： app.directive(&#39;ngFocus&#39;, [function() { var FOCUS_CLASS = &quot;ng-focused&quot;; return { restrict: &#39;A&#39;, require: &#39;ngModel&#39;, link: function(scope, element, attrs, ctrl) { ctrl.$focused = false; element.bind(&#39;focus&#39;, function(evt) { element.addClass(FOCUS_CLASS); scope.$apply(function() {ctrl.$focused = true;}); }).bind(&#39;blur&#39;, function(evt) { element.removeClass(FOCUS_CLASS); scope.$apply(function() {ctrl.$focused = false;}); }); } } }]); 要使用ngFocus，我们只需要简单加上这个指令到输入框元素上，像这样： &lt;input ng-class=&quot;{error: signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid}&quot; type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=3 ng-maxlength=20 required ng-focus /&gt; 加上ngFocus指令后，将在输入框的blur和focus事件中注册相应操作，当焦点在该输入框时，它添加一个class（ng-focused），并且该输入框的$focused属性也将变为true。因此，你可以根据需求是否在焦点上来个性化设置显示错误消息。例如： &lt;div class=&quot;error&quot; ng-show=&quot;signup_form.name.$dirty &amp;&amp; signup_form.name.$invalid &amp;&amp; !signup_form.name.$focused&quot;&gt; 我希望这篇文章可以告诉你如何很酷炫的使用AngularJS来进行验证。 原文：Form validation with AngularJS (en)译文原文：http://www.cnblogs.com/woshinidezhu/p/form-validation-with-angularjs.html","categories":[],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.voyax.me/tags/AngularJS/"}]},{"title":"60分钟搞定AngularJS——Getting Started","slug":"Started","date":"2015-08-03T10:46:10.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/19847/","link":"","permalink":"http://www.voyax.meposts/19847/","excerpt":"在学习之前，我们应该明白，你为什么还需要学习AngularJS，AngularJS到底提供了哪些有价值的特性。在这一章，我会帮大家回答这个问题。","text":"在学习之前，我们应该明白，你为什么还需要学习AngularJS，AngularJS到底提供了哪些有价值的特性。在这一章，我会帮大家回答这个问题。 单页应用 Single Page Application(SPA) 首先，什么是单页应用。 单页应用是指在一个页面上集成了多个视图模块，其中这个最外层的页面结构称之为Shell Page（翻译成“壳”也太难听了，了解操作系统中shell概念的想必也更乐意说shell）。 在传统的APP上，你的每一次操作都需要重新加载所有内容，对于带宽特别是在手机上进行这样的操作是非常不方便的。 而对于单页应用，我们首先做的是，将重要的内容预加载，不同视图或者一些小的组件则采用动态加载。 通过后面的学习，你会发现，AngularJS是一个非常优秀的单页应用框架，但其优点并不止于此。事实上，如果只是要实现动态加载视图，你完全不必采用AngularJS；你可以选择仅仅是利用AngularJS实现代码分离以及数据绑定。但是，现在本文的重点在利用AngularJS实现单页应用。 单页应用的挑战 如果自己从头实现单页应用，需要解决各种各样的问题：DOM操作、History以及动态加载各模块，同时你还需要处理类似异步调用的Promise模式等等问题。（译者注：我之后将些一篇文章讲解promise） 对于单页应用，路由是非常重要的部分，你需要准确地知道现在是在哪个位置，同时下一步又是跳转到哪个模块。 前边所谈到的所有这些功能，我们都是可以找到相应的js库的：sammyJS、JQuery、historyJS、requreJS。但是，正如你将会了解到的，AngularJS实现了所有这些功能。 AngularJS一个全方位的SPA框架 AngularJS是一个核心库。 我非常喜欢这个概念，因为我不用依赖繁多的脚本库，也不需要担心各个script在以后是否兼容的问题。 如果你是在一个开发团队中工作，那么代码的维护将是你需要考虑的目标之一，如果你正好是做维护这方面工作的，其重要性更不必说。 在我看来，AngularJS有非常好的向下兼容性，你也可以非常方便的进行扩展。 接下来看一下AngularJS为我们具体提供了哪些功能。 如上文所谈，AngularJS是一个为单页应用而生的框架，提供了各种各样的功能：双向数据绑定、MVC（Model-View-Controller 模板-视图-控制器）的概念，通过内建的路由实现视图之间的路由。 AngularJS一开始就考虑了测试功能，我们强烈推荐建立健壮的测试。 AngularJS内置了jQlite进行Dom操作，jQlite实现了一些类似于JQuery的操作，你可以把它当做一个精简版的JQuery。如果你需要用到更高级操作，你也可以引入JQuery:Angular和JQuery可以完全兼容。 谈到数据绑定，AngularJS提供了全面的模板支持。AngularJS内部实现了history，通过factory和service可以实现数据和代码的共享。 AngularJS还提供了许多其他很多东西：通过View Model(模板视图)来完成数据绑定，下一章节介绍的Directives将给HTML带来一些新的花样，表单的验证，依赖注入等等。 （这里对依赖注入进行简单的解释：依赖注入是一种软件设计模式，即各组件之间的关系由运行期间的需要动态决定，解决依赖关系硬编码的问题，减少逐渐之间的耦合；这在进行单元测试的时候将非常方便。对AngularJS依赖注入的解释可以参考知乎上《AngularJS中的依赖注入实际应用场景？》 的讨论。) These are just some of the core features and these features will satisfy some of the others that I mentioned when it comes to building a SPA. 这些都是AngularJS提供的众多特性中的一部分，这些特性将解决使得单页应用中的其他部分得以解决。 如此看来，从头做一个单页应用可能是一个挑战，但也并非高不可攀。 AngularJS.org 打开AngularJS的网站，我将给大家演示如何开始。在下一部分，我们将学习AnuglarJS入门的一些关键特性。首先，访问angularjs.org。在这你既可以通过github下载所有的script代码，也可以直接点击”Download”进行下载，非常简单吧。 在这有两个下载选项，既可以下载稳定版（stable）也可下载测试版(unstable)。如果你想尝试最新的东西，那就下载测试版吧，我个人一直都采用测试版，而且也并没有遇到什么问题，不过如果是在实际产品中，官方推荐采用稳定版。 接下来选择压缩版或者没有压缩的，以及Zip版本的。 你也可以采用 CDN ，CDN 将有谷歌各地区的数据中心提供。 采用CDN可能会带来缓存、多域资源加载等优势。如果你善于利用，你将会发掘CDN带来更多的好处。 CDN的优势（译者注） 多域名加载资源一般情况下，浏览器都会对单个域名的并发请求数（文件加载）进行限制，通常最多有4个，第五个加载项将被阻塞，知道前面某一加载项完成。因为CDN文件是存放在不同域的，所以对浏览器来说是可以同时加载页面所需的文件远不止4个，从而提高了页面加载速度。 文件缓存一些通用的js库或者是css样式库，如jQuery，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的CDN访问过了其他的某一个网站，恰巧这个网站同样也使用了jQuery，那么此时用户浏览器已经缓存有该jQuery文件（同IP的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度。 高效率你的网站做的再NB也不会NB过百度NB过Google吧？一个好的CDNs会提供更高的效率，更低的网络延时和更小的丢包率。 分布式数据中心假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而CDNs则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。 内置版本控制通常，对于CSS文件和JavaScript库来说都是有版本号的，你可以通过特定版本号从CDNs加载所需的文件，也可以使用latest加载最新版本（不推荐）。 使用情况分析一般情况下CDNs提供商（如百度云加速）都会提供数据统计功能，可以了解更多关于用户访问自己网站的情况，可以根据统计数据对自己的站点适时适当的做出些许调整。 有效防止网站被攻击一般情况下CDNs提供商也是会提供网站安全服务的。 现在我只需下载压缩过的稳定版angular.min.js，点击保存。 现在我们只需将angular.min.js引入到一个页面中。 我已经将脚本引入到页面头部，","categories":[],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.voyax.me/tags/AngularJS/"}]},{"title":"60分钟搞定AngularJS——Introduction","slug":"60分钟搞定AngularJS","date":"2015-08-01T01:01:21.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/53122/","link":"","permalink":"http://www.voyax.meposts/53122/","excerpt":"翻译：Eleven voya 你是否早已耳闻AngularJS，确不知道该如何着手学习？我想这个视频正是为你准备的。 《AngularJS Fundamentals in 60-ish Minutes》将会介绍所有你应该掌握的这个单页应用框架——AngularJS的关键基础知识。 附上教程视频地址 免责声明：原创内容版权为上述链接视频原作者所有，此部分出现的任何错误、意见或观点仅代表原作者的意见。因为翻译问题而出现的错误，由译者自行承担。","text":"翻译：Eleven voya 你是否早已耳闻AngularJS，确不知道该如何着手学习？我想这个视频正是为你准备的。 《AngularJS Fundamentals in 60-ish Minutes》将会介绍所有你应该掌握的这个单页应用框架——AngularJS的关键基础知识。 附上教程视频地址 免责声明：原创内容版权为上述链接视频原作者所有，此部分出现的任何错误、意见或观点仅代表原作者的意见。因为翻译问题而出现的错误，由译者自行承担。 目录简介关于作者姓名：Dan Wahlin, 乐于帮助大家从最基础的原理角度解决关键问题。我的博客地址：http://weblogs.asp.net/dwahlin，如果你也玩儿Twitter，可以关注@danwahlin，我们可以方便的在Twitter上交流学习。 AngularJS话不多说，正式开始学习AngularJS吧 Hi !，你可以在http://tinyurl.com/AngularJSDemos上找到本教程中的所有源代码我将从一些简单的实例开始，循序渐进，逐渐深入，最后我将帮大家把这些所有内容串联起来。我并不认为通过短短60分钟的学习，你就可以掌握开发一个商业APP的所有知识，但是我想你已经可以采用AngularJS开发这样的APP。如果你只是一个对AngularJS完全不了解的新手，你可以从AngularJS官网获取AngularJS的所有东西，官网提供了全面的文档、演示和教材——所有的这些东西都非常有趣。对单页应用最初的印象是，大量繁琐的脚本，实在是太混乱了。但是AngularJS的出现，让我兴奋不已，正如你将看到的，AngularJS非常适合写单页应用。 AngularJS让我感到一些陌生。而且越深入，在某些东西让人更加困惑。 “transclusion”、“scope”、”directive”这些都是什么鬼？事实上，我并不确定transclusion是不是一个有实际意义的词，很遗憾竟然真的是！现在我甚至有点喜欢这个词了😄 从90年代开始，我就用Javascript开发了，通常情况下我对事物都上手很快。但是，当接触到AngularJS的时候，我差点到了痛哭流涕的地步，不得不说，“好吧，也许我确实有那么一点智商不够”。后来才发现，其实我只是没有理解AngularJS的思维模式，不知道如果着手学习AngularJS而已。 每当回过头来看，心平气和地告诉自己，“嘿，这其实也没有那么难”的时候，我就变得冷静一些了，而且意识到：哇，这真是神奇了。 在我看来，AngularJS是一个令人敬畏的框架，有时给人昏天黑地的感觉……但是一旦将所有的知识结构都联系在一起，又会与一种恍然大悟之感。就像学习其他东西一样，在学习新框架时，有时候你能够立刻掌握，有时却无能为力。认识到这一点，我意识到我的问题并不是没有花时间学习，而是没有花时间去研究这些零散的知识碎片之间的关系，总是零零散散东学一点西学一点。通过这个视频，我将向大家讲解有关AngularJS的所有关键知识，不必像我当年那样痛苦，希望这个教程可以助大家一臂之力。 一旦你坚持下来，你将会像这个小孩一样拥有SuperPowers!也许不是超能“力”，但至少在单页应用上是超强的。 本教程安排 我们将从AngularJS的关键特性开始，同时会给大家介绍在没有良好的组织架构下编写单页应用会遇到的各种麻烦。 任何认识我的人都知道，我不建议不采用框架就开始开发。对我来说，考虑到后期的维护，这无疑是一噩梦。 各种脚本、版本依赖、脚本改动 以及 things breaking(这个怎么翻！) 因此，我们将要谈论下AngularJS是如何解决这些问题的。 然后，我们将讲解AngularJS提供的一些基础特性。 接下来，介绍你需要掌握的关键技术，比如A-B-Cs,以及指令（Directives）、过滤器（Filters）和稍微困难点的双向数据绑定（two-way Data Binding） 除了AngularJS,我也非常喜欢想KnockoutJS等框架，但是你将认识到AngularJS才是真正的框架，一个库提供是单一功能的实现，但是利用一个框架你可以做各种各样的事情。 掌握Directives，Filters和Data Binding后，我们将谈论视图（View）、控制器(Controller)以及作用域（Scope）。 然后，我们将学习Modules，讲解如何将其他部分绑定到modules。进一步，介绍SPA（单页应用）的相关概念，例如，Routes（路由）、负责数据的Factories（仓库）。","categories":[],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.voyax.me/tags/AngularJS/"}]},{"title":"有时候，我已不想说话","slug":"有时候，我已不想说话","date":"2015-07-14T15:58:28.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/27048/","link":"","permalink":"http://www.voyax.meposts/27048/","excerpt":"","text":"[caption id=”attachment_1155” align=”alignnone” width=”1024”] 仰望星空[/caption] 毕业半月，却是郁结难平从去年的七月份到今日，变数太多。我时常自我安慰，如今所做的一切无非都是自我修养，有时候一个人的时候，想起某些事情，却还是痛得想哭……最初一意孤行要考从未接触也至今仍未明白的金融，数分之差人大财政经融将我拒之门外在学校最后那段日子，未免心高气傲，只愿花一周时间找工作，仅仅因为对某些人的印象选择了深圳，而非情况或许更好的北京。以前觉得，这是我要的情怀与自由绝大多数情况，不说并非代表可以任人利用。自作聪明之人太多，最近我终于有所理解大智若愚不早了，睡觉，如今，我只想当个程序员有一天，我会做我想做的事，说我想说的话。 忆往昔童梦求真知，看明日吾辈现英豪。 期待有一天，我羽翼丰满，振翅高飞 披惊雷 傲骄阳 狂风当歌 不畏冰雪寒霜","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2015-06-16T16:36:33.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/16107/","link":"","permalink":"http://www.voyax.meposts/16107/","excerpt":"","text":"许久未写过东西，人啊，总是很奇怪，想说的东西太多便一句也不愿说。 毕业季，有人欢笑有人愁，但是正如四年前，黄勇老师给我们的赠语， 榜上有名的不一定必将欢笑，榜上无名的必将哀伤。 落地的麦子会长出新芽 盛开的花朵都将枯萎 得失两忘的人永远及格 早晨与黄昏各有所长离校最后十几天，说不尽的感慨与惆怅，难辨是非 消极的东西自不必说，装逼之人太多 永远记得心怀感恩，不忘初心 It is my youth and I luv it. Life is unknown and unexpected just fight for it and the dream will come true. Thanks for the ppl who r nice. [caption id=”” align=”alignnone” width=”780”] 毕业照[/caption] [caption id=”” align=”alignnone” width=”781”] 毕业照[/caption] [caption id=”” align=”alignnone” width=”781”] 毕业照[/caption] [caption id=”” align=”alignnone” width=”780”] 京津客2012年10月[/caption] [caption id=”” align=”alignnone” width=”781”] 索尔[/caption] [caption id=”” align=”alignnone” width=”780”] 索尔[/caption] [caption id=”” align=”alignnone” width=”781”] 台联[/caption] [caption id=”” align=”alignnone” width=”599”] 台联[/caption] [caption id=”” align=”alignnone” width=”781”] 台联[/caption] [caption id=”” align=”alignnone” width=”781”] 我所爱的家人们[/caption]","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"谈谈Web安全色（web safe color）","slug":"谈谈web安全色（web-safe-color）","date":"2015-06-08T15:09:41.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/16108/","link":"","permalink":"http://www.voyax.meposts/16108/","excerpt":"","text":"Web安全色对于大多数写程序的人来说都是毫无概念，当然，web safe color本身是一个历史遗留问题，今天已经没有太多讨论的必要。在这里介绍web安全色只是帮助还在Google “is web safe color still important”（用英文搜索往往比在千篇一律的中文网页中寻找来得更快）的朋友了解什么是web安全色，216种web安全色已经成为历史✌️ 1.web安全色干嘛用和安全相对的自然是不安全，当你在mac的word下洋洋洒洒写了几万字的论文，拿去复印店准备打印的时候发现TMD全乱码了，你就能深深体会web安全色的妙用。所谓的web安全色是指在不同的平台下显示效果一致的颜色。比如在mac下本来显示深红色，但是在windows下可能被渲染成其他颜色。简而言之，采用web安全色能够保证在不同平台上的效果与预期一致。 2.为什么为出现web安全色引用《CSS权威指南》中web安全色的定义，”在256色计算机系统上总能避免抖动的颜色“。这句话非常精炼的说明了web安全色的来历。 显示器显示不同颜色的原理是对红绿蓝的不同组合，在CRT计算机显示器中，有三支分别发射红、绿、蓝三种三种光的”枪“，通过控制不同光束的强度，构成各种颜色。在说web安全色的产生前，先科普下颜色的表示，颜色的表示方法有很多种，具体参加维基百科，在此只说明16进制的表示方法，如果我们需要白色，通常的写法是#FFFFFF或者（#FFF），用两位16进制代表红（绿，蓝），转换成10进制就是(255,255,255)，那为啥就是255？计算机能表示多少颜色取决于采用多少位用于颜色的存储，如果使用24位，那就是我们常说的真彩色，一共可以有256256256种不同颜色。 颜色表示说完了，进入正题。老式的计算机受显存大小的限制，一般只有4位~16位的空间存储颜色，所以最多只能显示256种颜色，为了显示更多的颜色，提出了抖动（dithering）的技术，抖动将不同的颜色交错起来才生新颜色的视觉效果，如下图： [caption id=”attachment_1087” align=”alignnone” width=”350”] dithering color[/caption] 但是不同平台的调色板不同，这导致采用抖动技术可能会产生不同的效果。说到这，明白了吗，最基础的256中颜色其实都可以作为安全色，但是由于某些平台只支持216中颜色（这个有人解释下么），所以这216中颜色正式我们所说的安全色。安全色都是RGB值51的倍数，所以说，rgb(0,204,153)，rgb(255,0,102)都是安全色。为什么是51的倍数参看下图中不同平台下调色板的结构： [caption id=”attachment_1088” align=”alignnone” width=”221”] ie safe palette[/caption] [caption id=”attachment_1089” align=”alignnone” width=”221”] netscape web safe palette[/caption] 现在已经几乎没有还在用256色的电脑了，所以，去它的web safe color吧","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"母亲节，感恩","slug":"母亲节，感恩","date":"2015-05-06T14:59:49.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/51411/","link":"","permalink":"http://www.voyax.meposts/51411/","excerpt":"","text":"微博上看到一个关于母亲节的视频，《什么是最好的礼物》 在外面呆的时间长了，人也变得冷漠了，常怀感恩","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"mac（windows）必装软件之Adobe CC 2014全系列下载和激活工具（可更新）","slug":"mac（windows）必装软件之adobe-cc-2014全系列下载和激活工具（可","date":"2015-04-23T17:20:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/21769/","link":"","permalink":"http://www.voyax.meposts/21769/","excerpt":"","text":"2014年6月18日Adobe推出Adobe CC 2014，Adobe CC 2014从本质上而言完全是一个全新的版本（Adobe CC 2014版本号是18，而adobe CC是17）。Adobe CC 2014无论从功能上还是界面上都将给用户带来超酷的设计体验。 给出Mac版和Windows版的全套Adobe CC 2014下载地址以及激活工具。 [caption id=”attachment_1049” align=”alignnone” width=”728”] adobe cc 2014[/caption] Adobe CC 2014全系列下载地址（百度网盘）：Adobe After Effects CC 2014： 链接: http://pan.baidu.com/s/1i3tLswt 密码: n43i Adobe Audition CC 2014： 链接: http://pan.baidu.com/s/1dDB41gt 密码: f699 Adobe Bridge CC 6.1： 链接: http://pan.baidu.com/s/1o6urhf8 密码: b6h5 Adobe Captivate 8： 链接: http://pan.baidu.com/s/1ntrBtqx 密码: zr9y Adobe Dreamweaver CC 2014：链接: http://pan.baidu.com/s/1sjx8Kyh 密码: ihsf Adobe Edge Animate CC 2014：链接: http://pan.baidu.com/s/111hOa 密码: yi49 Adobe Flash Pro CC 2014： 链接: http://pan.baidu.com/s/1mgIHIic 密码: qe54 Adobe Illustrator CC 2014： 链接: http://pan.baidu.com/s/1qW9Mgnq 密码: ubjr Adobe InCopy CC 2014： 链接: http://pan.baidu.com/s/1pJxCPcR 密码: kac6 Adobe InDesign CC 2014： 链接: http://pan.baidu.com/s/1i3iqeBb 密码: mkja Adobe Media Encoder CC 2014： 链接: http://pan.baidu.com/s/1mgFZSTE 密码: u4tm Adobe Muse CC 2014： 链接: http://pan.baidu.com/s/1bnjikpT 密码: n6c8 Adobe Photoshop CC 2014： 链接: http://pan.baidu.com/s/1sjsOZRv 密码: 5cwi Adobe Photoshop Lightroom 5.5：链接: http://pan.baidu.com/s/1i3vhnBB 密码: t8ad Adobe Prelude CC 2014： 链接: http://pan.baidu.com/s/1eQcW3aM 密码: jpux Adobe Premiere Pro CC 2014： 链接: http://pan.baidu.com/s/1tZAAM 密码: adnu Adobe SpeedGrade CC 2014： 链接: http://pan.baidu.com/s/1bnsBBfp 密码: xbdh Adobe CC 2014激活方式（亲测可用 CC 2014）：Adobe CC 2014激活工具xf-accm2014下载：链接: http://pan.baidu.com/s/1hqxlhnm 密码: 91nn windows版激活步骤：1. 断网，并且保证你的Host文件不存在以下内容： 127.0.0.1 lmlicenses.wip4.adobe.com 127.0.0.1 lm.licenses.adobe.com【注：host文件路径C:\\Windows\\System32\\drivers\\etc】 如果有，注释掉后保存。 2. 安装Adobe CC 2014软件，因为是断网下要求激活，要求登陆Adobe账户，点击登陆后提示无法联网，选择稍后连接 即可。确定协议后要求输入序列号，则使用Adobe CC 2014注册机算号输入进入下一步，继续提示联网失败，选择稍后连 接; 3. 选择路径，安装好软件后，选择立即启动软件，软件将提示需要登陆，此时请选择“连接Internet时是否出现问题？” 选择“脱机激活”-“生成请求代码”； 4.将生产的脱机代码复制到注册机内，点击“GENERATE”生成响应代码，将响应代码复制到软件激活窗口，点击“激活”; 5.重复Step 2至Step 4步骤逐一激活你要安装的Adobe CC 2014软件; 6. 最后以管理员身份运行软件包内的disable_activation.cmd，修改Host文件或者手动为你的Windows Host文件添加以 下记录（务必确保你的Host文件存在以下记录，否则会激活失败）： 127.0.0.1 lmlicenses.wip4.adobe.com 127.0.0.1 lm.licenses.adobe.com 127.0.0.1 na1r.services.adobe.com 127.0.0.1 hlrcv.stage.adobe.com 127.0.0.1 practivate.adobe.com 127.0.0.1 activate.adobe.com Mac版激活步骤：1.断网，并且使用xf-accm2014.dmg文件夹中的 Reset hosts file to the default.app 应用把之前的系统host还原。 2.安装你所需要的软件，安装时选择“我已购买，用序列号安装”，忽视联网。 3.用xf-accm2014.dmg并选择相应的软件，算出序列号，输入序列号安装（记得保存这个序列号，用于激活） 4.安装完成点击启动，启动后出现以下界面，选择 链接Internet时是否出现问题？ 5.选择 脱机激活，然后吧生成的激活码粘贴到刚才算序列号的工具中，生成激活码，并粘贴到安装程序中，完成激活。 6.点击算号器文件夹中的“Smart Adobe CC Blocker 1.1.app” 锁定host，然后重启软件，联网，完成全部破解。","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.voyax.me/tags/Mac/"}]},{"title":"mac必装软件之视频播放器MPlayerX","slug":"mac必装软件之视频播放器mplayerx","date":"2015-04-23T16:03:27.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/64655/","link":"","permalink":"http://www.voyax.meposts/64655/","excerpt":"","text":"Mac自带的QuickTime支持格式太少，需要另外装解码插件，而且还不稳定。所以几乎无用。 知乎上有人评论说目前的 OS X 平台没有一款全能型播放器。但对于大多数人，个人MPlayerX足以够用，支持绝大多数格式（比如不支持蓝光），解码速度很快，资源占用很低，有很好的字幕支持，对于强迫症来说，界面也是足够的简洁。 之前有过“射手播放器拿了MPlayerX的代码，然后把产品放到app store上销售”的讨论，想表达啥？忘了。。。GPL也没有这样的限制。 MPlayerX下载地址：MPlayerX-1.0.22.1.dmg","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.voyax.me/tags/Mac/"}]},{"title":"mac必装软件之解压BetterZip2.3.3破解版下载","slug":"mac必装软件之解压betterzip2-3-3破解版下载","date":"2015-04-23T15:27:30.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/34363/","link":"","permalink":"http://www.voyax.meposts/34363/","excerpt":"","text":"BetterZip——Mac非常好用的一款快速压缩软件，支持多种格式 zip, gz, bz, bz2, tar, tgz, tbz, rar, 7-zip, cpio, arj, lha, lhz, cab, iso, chm, rpm, deb, nsis, sit, dd, hqx, and bin BetterZip2.3.3版本Betterzip破解方法1.安装好后不要打开【BetterZip】,打开【CORE Keygen.app】,首先点击「Patch」按钮，选择「应用程序」中的「BetterZip.app」，破解应用； 2.然后点击「Generate」，将生成的序列号和Name粘贴到激活窗口即可。 在10.10以上OS X Yosemite下 ： 进入 应用程序 ▸ BetterZip.app ▸ Contents ▸ Resources 替换Register.nib文件就行，无须使用注册机。 BetterZip破解版下载地址：链接: http://pan.baidu.com/s/1GuoME 密码: s2k9","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.voyax.me/tags/Mac/"}]},{"title":"超赞！设计师完全自学指南","slug":"超赞！设计师完全自学指南","date":"2015-04-14T14:57:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/4911/","link":"","permalink":"http://www.voyax.meposts/4911/","excerpt":"","text":"本文译自国外高质量问答社区Quora，原文作者Karen X. Cheng，原是微软Excel的项目经理，后通过自学转型成为设计师。她讲述的自学过程详实细致且条理有序，读完会发现与想象中的大不一样，对于想自学设计但迷茫不知道从何入手的童鞋来说，可以遵循她的步骤去学习，除了规划得当，还能对设计有一个全局的了解 : ） 设计师完全自学指南：我不是毕业于设计学系，但我得到了一份设计师的工作。 我想换工作，成为一位设计师，但我没有四年和十万元美金让我回到学校上课，所以我决定自修。起初，我相当怀疑一个人到底能不能靠着自修来找到相关的工作。 答案是：可以 我边上班边自学了六个月的设计。虽然我觉得还没准备好，但我还是参加了许多公司的面试，最后我成功在一间很棒的新创公司 Exec 找到工作。 我知道我不比许多专业科系毕业的设计学生还要优秀，但我的能力已足以将我的工作做好。我会设计许多东西，例如网页、iPhone 应用程序、电子邮件、社群媒体和印刷品等。 一、学会观察：新手最容易犯的错误是直接上手Photoshop，要清楚学会Photoshop并不能让你成为设计师，就像你买了一套高质量的画笔也不会成为艺术家一样，从真正的基础开始吧。 首先，学一点绘画： 1. 你不需要挤在一个画室里，跟一群艺术家一起画裸女2. 你甚至不需要画得非常好，只要掌握一点基础，就能画一幅素描画3. 你只有一件事，去学习如何画画，我看了很多关于绘画的书，这里推荐一本最好的：如何在30天内学会画画（小编找不到中文版，倒是有英文版PDF，微盘下载），然后每天花半个小时去练习画画，坚持一个月，会有惊人的效果。 学习平面设计理论： 1. 从《Picture This》这本书开始学起。本书虽以童话《小红帽》为例，却能教会你一切平面设计的基础。 2. 学会运用颜色、排版，以及栅格。若附近有开班教平面设计，就去报名吧。 强烈推荐大家也一并阅读我们下方推荐的配色经典文章《新手学配色：配色达人速成》，一定会让您对配色有全新的认知。每天复习这些棒极了的教程 → psd.tutsplus，当然你也可以每天关注优设的设计版块 学习使用者经验的基础： 坊间有许多谈论使用者经验的书，我推荐从这两本开始：《The Design of Everyday Things》 → 中文版（设计心理学）PDF，微盘下载、《Don’t Make Me Think》→ 中文版《不要让我思考》PDF，微盘下载 学习如何写作： 不要用废话来充版面。身为一个设计师，你的工作不只是画出美美的图片而已，你还必须是个优秀的沟通者。想想你过去的一切经验，并且慎选每一个用字遣词。记得要「说人话」，而不是像学校写报告时拿来充字数的连篇鬼话。 1. 读《Made to Stick》 → 中文版《粘住》PDF，微盘下载。这是我这辈子最爱的书之一，它将教会你如何获得你专属的死忠读者。 2. 「Voice and Tone」这个网站充满了很多很棒的例子，教你如何与使用者沟通。 学习放弃自己的作品： 这是最困难的部份。要作好心理准备，随时有可能必须像扼杀自己的孩子般销毁自己的作品。若能越快做好这样的心理准备，工作就能越快上手，因此若觉得成品不够好时，就随时砍掉重练吧。 找到公正的另一双眼：向懂设计的人询问看完你作品后的意见。若身边没有这类朋友，就去参加设计师聚会或相关活动上认识几个吧！ 也要问问不懂设计的人，对你的作品有什么看法。让你将来的使用者试用看看你做的网页或应用程序。不要害怕问陌生人的意见，有一次班机误点，我就利用这个机会问问航厦中的其他乘客对于我设计中的应用程序的看法。他们大都乐意协助，我也获得了许多很棒的意见。 聆听： 确实地聆听别人的意见，而且不要辩解。当你问别人意见，而对方愿意花时间和精力回答你时，不要用辩解来回报他们。相反地，你可以感谢他们，并且问他们问题，然后再自行考虑是否采纳他们的意见。 &nbsp; 二、学会使用 Photoshop 和 Illustrator耶！现在你在视觉设计与用户经验上已经有相当坚实的基础，可以朝下一步迈进了。事实上，我建议从 Illustrator 开始学，接着再去碰 Photoshop。设计师通常使用 Illustrator 来制作商标或图示，而 InDesign 则在制作传单或名片等印刷品时非常好用。 学习使用 Illustrator： 有无数本书跟网站都在教怎么用 Illustrator，你可以挑自己喜欢的，以下是我自己很喜欢的： 《Adobe Illustrator Classroom in a Book》：这本书很无聊，但却非常实用。 《Vector Basic Training》：这本书会教你如何用 Illustrator 做出真的还蛮好看的东西。好玩的来了，到以下的免费学习网站看看你学会了多少吧！这是我最喜欢的两个：logo 和scenic landscape。 学习使用 Photoshop： 网络上有成千上万的教学网站，但很多都很烂。幸好，还是有不少高质量的教学网站，例如PSDTuts 就是其一。想学做 iPhone 应用程序的话，这里有很棒的教学 ; 想学做网页的话，则看这个网站。 若每天挤出一两个小时来复习这些教学课程，你进步的速度将会连你自己都感到难以置信。 &nbsp; 三、学会专业技能你想设计的是应用程序、网页、还是信息图表？我建议在全部尝试过后，选择其中你比较有兴趣的领域去钻研学习。 学习设计商标： 1. 想学会设计商标，建议读《Logo Design Love》 → 中文版《超越LOGO设计》PDF，微盘下载。 2. 若连网站和名片都想一起学会，就建议读《Designing Brand Identity》。 学习设计应用程序： 1. 从这个教学课程开始学习应用程序的视觉设计。2. 读这本关于 iPhone 的书《Tapworthy》→ 中文版《触动人心：设计优秀的Iphone应用》PDF，微盘下载，它能教你如何作出美观又实用的应用程序。3. 好好研究你手机中的应用程序。你觉得哪边很棒，哪边又很糟？ 学习设计网页： 1. 读《Don’t Make Me Think》，学习如何做出好读的网页。2. 想做出好看的网页，就去读《The Principles of Beautiful Web Design》。3. 列出你觉得很漂亮的网页，并找出他们的共同点。SiteInspire 上有很多不错的例子。 难题来了：身为设计师，一定要懂 HTML 或 CSS 吗？我的答案是，依工作性质而定，但若懂这些肯定对工作是加分的。网络上有非常多学习 HTML 和 CSS 的资源： 4. 我最喜欢的免费网站是Web Design Tuts。5. 我最喜欢的付费网站则是 Treehouse（每个月只要 25 美元）。假如你是从头开始学，而且希望有人为你详细解说一切，就去上 Treehouse 的教学课程吧。 &nbsp; 四、建立自己的作品集想成为设计师，你不需要去过学校上课，但你一定需要一个作品集。话虽如此，又刚开始学设计又没读过相关学系，要从哪里生出作品集来？告诉你一个好消息：你不需要真的处理过企划项目才能建立一份作品集，你可以列出以下成品： 1. 你为 T 恤所做的疯狂设计。2. 替一个很丑的网站重新设计新风貌。3. 设计一个 iPhone 应用程序。4. 参加设计比赛 → 百度输入法三周年皮肤大赛：青春正当时！5. 寻找当地的非营利组织，提供免费设计服务。 另外记得： 1. 不要把每个作品都放进作品集中，只要把最好的一些作品放进来即可。2. 找灵感：先不必担心原创的问题，就像刚学新乐器时，一定是先学如何演奏别人的歌曲，最后才学做自己的歌曲。3. 你还可以到优设看酷站推荐专栏，寻找网页设计的灵感。 &nbsp; 五、找到一份设计师的工作当我刚开始学设计时，我曾去过一个设计师工作坊，里面充满了想找工作的资深设计师，有好几位有过 5、10、甚至 15 年的工作经验了。想到必需跟他们竞争，我感到十分胆怯。然而一年后，我就成功找到了一份设计师的工作。我认为我比其他设计师多了一项关键优势：我懂得如何与软件开发人员合作。 去学一些交互式设计，或是基本的 HTML 和 CSS 语法吧！科技业的设计师（交互式装置、网页和应用程序设计师等）炙手可热且薪水很高。假如没有跟开发人员合作过的经验，可以参加Startup Weekend、Hackathons 最后，告诉你身边所有人你想成为一位设计师吧！谁都有可能会成为帮你找到工作的贵人。 找到工作后也要持续学习 我已经在 Exec 工作一年了，也从这份工作中学到许多。我会去向比我资深的设计师学习、去找其他设计课程，像TutsPlus 、优设设计版块都是不错的在线课程，甚至翻遍书店中设计类的书籍。还有许多东西是我可以学习以及改善的。记得要不断磨练你的技能，并且不停学习。 &nbsp; 原文地址：Quaro 作者：Karen X. Cheng 译文整合自techorange : ） &nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"设计","slug":"设计","permalink":"http://www.voyax.me/tags/设计/"}]},{"title":"两个在线图片压缩工具","slug":"两个在线图片压缩工具","date":"2015-04-14T12:08:07.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/17218/","link":"","permalink":"http://www.voyax.meposts/17218/","excerpt":"","text":"在优化网页加载速度的时候都会对图片进行一定的压缩，在尽量保持画质的情况下将图片尽可能地压缩。以前雅虎有一个在线压缩工具smush，可惜如今不能使用了。 今天找了两个不错的在线压缩工具，色彩笔和 http://tools.dynamicdrive.com/imageoptimizer/index.php 1.色彩笔在线压缩http://www.secaibi.com/tools/ [caption id=”” align=”alignnone” width=”716”] 色彩笔在线压缩[/caption] GIF,PNG处理后保留透明，动画，Alpha通道右侧设置栏中新增“PNG极限压缩”功能，启用后，PNG的压缩比可以大副提升，不过png图像质量有轻微下降。极限处理后的PNG图片可能无法在photoshop等编辑软件中显示。但请不要但心，在浏览器或相册中都可以正确显示。 算法： PNG和GIF保持100%无损处理(注1)。通过先进算法重新去除冗余区块，并重新规划生成PNG/GIF文件布局来减小文件体积。 JPG处理后，图像品质细节保留99%，变化的部分由于重取样导致，大部分图片人眼很难识别出差异。特别需要说明的是，程序中并没有使用降低JPG图像品质因子(0-100)的方法来减小体积。体积减小是因为有一个更智能的JPG编码器。更专业的算法介绍点这里。 注1：2014年11月6日更新后，默认启用png极限压缩, 图片质量将产生微损。在设置中关闭极限压缩， 图片质量将依旧保持无损。 2.Online Image Optimizer- GIF, JPG, and PNGhttp://tools.dynamicdrive.com/imageoptimizer/index.php dynamicDrive是一个免费的在线图片优化压缩工具网站，支持GIF、JPG、PNG等格式的图片，上传图片的大小限制2.86MB之内。 这款工具能一次性通过7种压缩比例进行压缩（分别是256 colors、128colors、64colors、32colors、16colors、8colors、4colors），在压缩结果里除了给出压缩后的图片大小和压缩比例外，还会显示压缩图片的效果图，","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"[转]java内存分配和String类型的深度解析","slug":"转java内存分配和string类型的深度解析","date":"2015-04-12T15:12:09.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/14139/","link":"","permalink":"http://www.voyax.meposts/14139/","excerpt":"","text":"一、引题在java语言的所有数据类型中，String类型是比较特殊的一种类型，同时也是面试的时候经常被问到的一个知识点，本文结合java内存分配深度分析关于String的许多令人迷惑的问题。下面是本文将要涉及到的一些问题，如果读者对这些问题都了如指掌，则可忽略此文。 1、java内存具体指哪块内存？这块内存区域为什么要进行划分？是如何划分的？划分之后每块区域的作用是什么？如何设置各个区域的大小？ 2、String类型在执行连接操作时，效率为什么会比StringBuffer或者StringBuilder低？StringBuffer和StringBuilder有什么联系和区别？ 3、java中常量是指什么？String s = “s” 和 String s = new String(“s”) 有什么不一样？ 本文经多方资料的收集整理和归纳，最终撰写成文，如果有错误之处，请多多指教！ 二、java内存分配1、JVM简介Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最 具吸引力的特性之一。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏 蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 如下图所示，JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（Classloader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 如下图所示，JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（Classloader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 [caption id=”” align=”alignnone” width=”757”] JVM体系结构[/caption] 2、java内存分区从上节知道，运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。程序喜欢有规律的东西，最讨厌杂乱无章的东西。 根据存储数据的不同，java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。其相关设置参数： -Xss –设置方法栈的最大值本地方法栈（Native Stack）：存储本地方方法的调用状态。 [caption id=”” align=”alignnone” width=”735”] 线程专有运行时数据区[/caption] 方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。 [caption id=”” align=”alignnone” width=”779”] 常量池[/caption] 堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String(“s”)时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存，如下图所示。 JAVA虚拟机有一条在堆中分配新对象的指令，却没有释放内存的指令，正如你无法用Java代码区明确释放一个对象一样。虚拟机自己负责决定如何以及何时释放不再被运行的程序引用的对象所占据的内存，通常，虚拟机把这个任务交给垃圾收集器（Garbage Collection）。其相关设置参数： -Xms – 设置堆内存初始大小 -Xmx – 设置堆内存最大值 -XX:MaxTenuringThreshold – 设置对象在新生代中存活的次数 -XX:PretenureSizeThreshold – 设置超过指定大小的大对象直接分配在旧生代中Java堆是垃圾收集器管理的主要区域，因此又称为“GC 堆”（Garbage Collectioned Heap）。现在的垃圾收集器基本都是采用的分代收集算法，所以Java堆还可以细分为：新生代（Young Generation）和老年代（Old Generation），如下图所示。分代收集算法的思想：第一种说法，用较高的频率对年轻的对象(young generation)进行扫描和回收，这种叫做minor collection，而对老对象(old generation)的检查回收频率要低很多，称为major collection。这样就不需要每次GC都将内存中所有对象都检查一遍，以便让出更多的系统资源供应用系统使用；另一种说法，在分配对象遇到内存不足时，先对新生代进行GC（Young GC）；当新生代GC之后仍无法满足内存空间分配需求时， 才会对整个堆空间以及方法区进行GC（Full GC）。 [caption id=”” align=”alignnone” width=”515”] java堆之新生代和老生代[/caption] 在这里可能会有读者表示疑问：记得还有一个什么永久代（Permanent Generation）的啊，难道它不属于Java堆？亲，你答对了！其实传说中的永久代就是上面所说的方法区，存放的都是jvm初始化时加载器加载的一些类型信息（包括类信息、常量、静态变量等），这些信息的生存周期比较长，GC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen Space错误。其相关设置参数： -XX:PermSize –设置Perm区的初始大小 -XX:MaxPermSize –设置Perm区的最大值 新生代（Young Generation）又分为：Eden区和Survivor区，Survivor区有分为From Space和To Space。Eden区是对象最初分配到的地方；默认情况下，From Space和To Space的区域大小相等。JVM进行Minor GC时，将Eden中还存活的对象拷贝到Survivor区中，还会将Survivor区中还存活的对象拷贝到Tenured区中。在这种GC模式下，JVM为了提升GC效率， 将Survivor区分为From Space和To Space，这样就可以将对象回收和对象晋升分离开来。新生代的大小设置有2个相关参数： -Xmn – 设置新生代内存大小。 -XX:SurvivorRatio – 设置Eden与Survivor空间的大小比例 老年代（Old Generation）： 当 OLD 区空间不够时， JVM 会在 OLD 区进行 major collection ；完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”Out of memory错误” 。 三、String类型的深度解析让我们从Java数据类型开始说起吧！Java数据类型通常（分类方法多种多样）从整体上可以分为两大类：基础类型和引用类型，基础类型的变量持有原始值，引用类型的变量通常表示的是对实际对象的引用，其值通常为对象的内存地址。对于基础类型和引用类型的细分，直接上图吧，大家看了一目了然。当然，下图也仅仅只是其中的一种分类方式。 针对上面的图，有3点需要说明： char类型可以单独出来形成一类，很多基本类型的分类为：数值类型、字符型（char）和bool型。 returnAddress类型是一个Java虚拟机在内部使用的类型，被用来实现Java程序中的finally语句。 String类型在上图的什么位置？yes，属于引用类型下面的类类型。下面开始对String类型的挖掘！ 1、String的本质打开String的源码，类注释中有这么一段话“Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings.Because String objects are immutable they can be shared.”。这句话总结归纳了String的一个最重要的特点：String是值不可变(immutable)的常量，是线程安全的(can be shared)。接下来，String类使用了final修饰符，表明了String类的第二个特点：String类是不可继承的。下面是String类的成员变量定义，从类的实现上阐明了String值是不可变的(immutable)。private final char value[];private final int count;因此，我们看String类的concat方法。实现该方法第一步要做的肯定是扩大成员变量value的容量，扩容的方法重新定义一个大容量的字符数组buf。第二步就是把原来value中的字符copy到buf中来，再把需要concat的字符串值也copy到buf中来，这样子，buf中就包含了concat之后的字符串值。下面就是问题的关键了，如果value不是final的，直接让value指向buf，然后返回this，则大功告成，没有必要返回一个新的String对象。但是。。。可惜。。。由于value是final型的，所以无法指向新定义的大容量数组buf，那怎么办呢？“return new String(0, count + otherLen, buf);”，这是String类concat实现方法的最后一条语句，重新new一个String对象返回。这下真相大白了吧！ 总结：String实质是字符数组，两个特点：1、该类不可被继承；2、不可变性(immutable)。 2、String的定义方法在讨论String的定义方法之前，先了解一下常量池的概念，前面在介绍方法区的时候已经提到过了。下面稍微正式的给一个定义吧。常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中，String类的intern()方法是这一特性的典型应用。不懂吗？后面会介绍intern方法的。虚拟机为每个被装载的类型维护一个常量池，池中为该类型所用常量的一个有序集合，包括直接常量(string、integer和float常量)和对其他类型、字段和方法的符号引用（与对象引用的区别？读者可以自己去了解）。 String的定义方法归纳起来总共为三种方式： 使用关键字new，如：String s1 = new String(“myString”); 直接定义，如：String s1 = “myString”; 串联生成，如：String s1 = “my” + “String”;这种方式比较复杂，这里就不赘述了，请参见java–String常量池问题的几个例子。 第一种方式通过关键字new定义过程：在程序编译期，编译程序先去字符串常量池检查，是否存在“myString”,如果不存在，则在常量池中开辟一个内存空间存放“myString”；如果存在的话，则不用重新开辟空间，保证常量池中只有一个“myString”常量，节省内存空间。然后在内存堆中开辟一块空间存放new出来的String实例，在栈中开辟一块空间，命名为“s1”，存放的值为堆中String实例的内存地址，这个过程就是将引用s1指向new出来的String实例。各位，最模糊的地方到了！堆中new出来的实例和常量池中的“myString”是什么关系呢？等我们分析完了第二种定义方式之后再回头分析这个问题。 第二种方式直接定义过程：在程序编译期，编译程序先去字符串常量池检查，是否存在“myString”，如果不存在，则在常量池中开辟一个内存空间存放“myString”；如果存在的话，则不用重新开辟空间。然后在栈中开辟一块空间，命名为“s1”，存放的值为常量池中“myString”的内存地址。常量池中的字符串常量与堆中的String对象有什么区别呢？为什么直接定义的字符串同样可以调用String对象的各种方法呢？ 带着诸多疑问，我和大家一起探讨一下堆中String对象和常量池中String常量的关系，请大家记住，仅仅是探讨，因为本人对这块也比较模糊。第一种猜想：因为直接定义的字符串也可以调用String对象的各种方法，那么可以认为其实在常量池中创建的也是一个String实例（对象）。String s1 = new String(“myString”);先在编译期的时候在常量池创建了一个String实例，然后clone了一个String实例存储在堆中，引用s1指向堆中的这个实例。此时，池中的实例没有被引用。当接着执行String s1 = “myString”;时，因为池中已经存在“myString”的实例对象，则s1直接指向池中的实例对象；否则，在池中先创建一个实例对象，s1再指向它。如下图所示： 这种猜想认为：常量池中的字符串常量实质上是一个String实例，与堆中的String实例是克隆关系。 第二种猜想也是目前网上阐述的最多的，但是思路都不清晰，有些问题解释不通。下面引用《JAVA String对象和字符串常量的关系解析》一段内容。在解析阶段，虚拟机发现字符串常量”myString”，它会在一个内部字符串常量列表中查找，如果没有找到，那么会在堆里面创建一个包含字符序列[myString]的String对象s1，然后把这个字符序列和对应的String对象作为名值对( [myString], s1 )保存到内部字符串常量列表中。如下图所示： 如果虚拟机后面又发现了一个相同的字符串常量myString，它会在这个内部字符串常量列表内找到相同的字符序列，然后返回对应的String对象的引用。维护这个内部列表的关键是任何特定的字符序列在这个列表上只出现一次。例如，String s2 = “myString”，运行时s2会从内部字符串常量列表内得到s1的返回值，所以s2和s1都指向同一个String对象。这个猜想有一个比较明显的问题，红色字体标示的地方就是问题的所在。证明方式很简单，下面这段代码的执行结果，javaer都应该知道。String s1 = new String(“myString”);String s2 = “myString”;System.out.println(s1 == s2); //按照上面的推测逻辑，那么打印的结果为true；而实际上真实的结果是false，因为s1指向的是堆中String对象，而s2指向的是常量池中的String常量。 虽然这段内容不那么有说服力，但是文章提到了一个东西——字符串常量列表，它可能是解释这个问题的关键。 文中提到的三个问题，本文仅仅给出了猜想，请知道真正内幕的高手帮忙分析分析，谢谢！ 堆中new出来的实例和常量池中的“myString”是什么关系呢？ 常量池中的字符串常量与堆中的String对象有什么区别呢？ 为什么直接定义的字符串同样可以调用String对象的各种方法呢？ 3、String、StringBuffer、StringBuilder的联系与区别上面已经分析了String的本质了，下面简单说说StringBuffer和StringBuilder。 StringBuffer和StringBuilder都继承了抽象类AbstractStringBuilder，这个抽象类和String一样也定义了char[] value和int count，但是与String类不同的是，它们没有final修饰符。因此得出结论：String、StringBuffer和StringBuilder在本质上都是字符数组，不同的是，在进行连接操作时，String每次返回一个新的String实例，而StringBuffer和StringBuilder的append方法直接返回this，所以这就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。那么，哪种情况使用StringBuffe？哪种情况使用StringBuilder呢？ 关于StringBuffer和StringBuilder的区别，翻开它们的源码，下面贴出append()方法的实现。 [caption id=”” align=”alignnone” width=”413”] java-StringBuffer[/caption] [caption id=”” align=”alignnone” width=”353”] java-StringBuilder[/caption] 四、参考文献 Java虚拟机体系结构 Java内存管理基础篇-Java内存分配 Java堆内存设置优化 Java内存管理和垃圾回收 Java堆内存的转换和回收 Java虚拟机的JVM垃圾回收机制 浅谈设置JVM内存分配的几个妙招 深入Java字符串 Java性能优化之String篇 java字符串常量池知识 Java内存分配及String类型详解 Java String的内存机制 Java之内存分析和String对象 String类学习总结原文地址：http://my.oschina.net/xiaohui249/blog/170013?p=2#comments","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.voyax.me/tags/JAVA/"}]},{"title":"电商爬虫第一版完工","slug":"电商爬虫第一版完工","date":"2015-04-07T15:27:14.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/38510/","link":"","permalink":"http://www.voyax.meposts/38510/","excerpt":"","text":"清明节三天憋在家终于搞定针对京东的爬虫，今天下班回来，抓紧把程序部署到vps上。毕设还有一堆活要做，Come on! 整理下这几天遇到的麻烦： 开发环境： 本机：Mac OS X 10.9 jdk:1.7 maven :3.3.1 mongodb:3.0一、maven 问题汇总 1.maven 之环境变量 Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0好吧，这个是不是问题的问题，不要鄙视我，但是我就是没设置环境变量…… 解决方案：设置JAVA_HOME呗 export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home顺便提一句，安装maven时，记得看官方给你说明，比较下网上那些所谓的参考教程，你就知道网上说的不仅千篇一律还错误连篇！官网给的说明很清晰！ 2.maven 之编译打包 之前一直在eclipse下用m2e插件管理工程，但是不可能跑到vps上装一个eclipse啊，好吧，我把整个工程打包成jar扔到了远程上，让它自己玩去吧~ maven打包时，遇到各种问题。不好意思，抛得各种错误没有记录，将pom.xml中的build部分贴出来吧，其中指定了运行的main class： [caption id=”” align=”alignnone” width=”488”] maven-build[/caption] 关于maven的初步介绍和使用，推荐一篇教程http://my.oschina.net/huangyong/blog/194583 maven直接打包也很简单，配置好后，直接clean再package，搞定 mvn clean package二、log4j 的问题，现在仍没明白……log4j是一个操控日志信息的一个工具，其他的自行Google，我在eclipse下运行完全正常，但是打包后运行就报 log4j:WARN No appenders could be found for logger (org.apache.ibatis.logging.LogFactory).log4j:WARN Please initialize the log4j system properly.调了一下午没解决，没解决……然后晚上回来莫名其妙好了。不懂了附上配置文件： &nbsp; [caption id=”” align=”alignnone” width=”517”] log4j-config[/caption] 三、Java 内存溢出java.lang.OutOfMemoryError 当时在eclipse下直接用debug configurations配置了jvm得内存，部署到ubuntu下又抛了内存溢出， 直接在运行的时候加上Xms和Xmx参数。 好困，先睡觉:)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"Timed out after 10000 ms while waiting for a server that matches AnyServerSelector{}.","slug":"timed-out-after-10000-ms-while-waiting-for-a-server-that-matches-anyserverselector","date":"2015-04-04T16:07:01.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/65148/","link":"","permalink":"http://www.voyax.meposts/65148/","excerpt":"","text":"测试用mongodb持久化爬取的电商数据时，中途出现了这么个问题。 果真是不拍脑子直接写的后果，之前本打算一直保持mongodb连接，但是后来图省事直接每次新建一个连接，关键是还忘记关闭 暂时直接每次加上close()，性能调优后续再做","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"关于毕业","slug":"关于毕业","date":"2015-03-24T15:41:06.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/28034/","link":"","permalink":"http://www.voyax.meposts/28034/","excerpt":"","text":"“来”与“离”想来无非一念之差，不情愿地来，不知所措地离开…… 本想今晚贴上今年生日照片，后来想起老子的“道可道，非常道。名可名，非常名”，索性还是罢了。 近来已懒得动笔，看到小巷有人写的毕业随笔，也就来个“拿来主义” &gt; ### 标题：总有些人后来真的再也没见过&gt;&gt; 毕业——告别&gt;&gt; 尽管我们都在彼此的同学录里写着“友谊常在”之类的字眼，也不知道现在是不是还流行着同学录这样的东西，还是现在早已互留人人微博，但还是莫名其妙的失去联系。曾经的人人热闹的景象也不见了，取而代之的是一片沉默。&gt;&gt; 倒不是不想去联系，只是怕联系的时候只剩下一句：“好久不见。”“最近不错。”便无话可说。谁都害怕曾经的友谊变得如此似是而非，所以干脆不联系。也有因为逐渐开始走向各自的生活轨迹，偶然想起的时候，只是害怕打扰。前几天回去的路上，下车时发现一高中同学竟然和我同车，只是直到下车才发现彼此的存在，虽然心里有点小小的激动，有很多想说的话，可是张口却变成了：“咦，你也在这车上啊？你坐哪的，刚怎么没看见”“嗯，我就坐这的。。。。。。”然后微笑着就不知道说什么了，直到车子停下来，我和她说了句，那我先走了，就没有然后了。。。&gt;&gt; 早早起床只为了见他一面的那个少年，晚上熬夜在楼下一起去网吧通宵的死党，失恋时陪我很久又突然失去联系的少年，散伙饭上抱着哭的闺蜜们，&gt;&gt; 后来就真的再也没见过。&gt;&gt; 有段时间，会突然和一些人关系很好，就连认识的方式都突然的莫名其妙。那个时候一起唱歌一起玩，一起聊天一起看帅哥，一起八卦，然后突然间又全部消失，想想无奈却也只是无奈。&gt;&gt; 后来我开始想，为什么我记不清初中里坐最后一排的人是谁，却能记住很多只见了几面的人。&gt;&gt; 谁知道。&gt;&gt; 那些恋人未满的人，总尝试着做些什么却还是无果而终；那些萍水相逢的人们，在一起的感觉是那么的自然，却还是了无联系；那些曾经爱过恨过的人，经历了很多还是分开。离别似乎永远是相遇必须面对的命运。&gt;&gt; 然而我谢谢这些，仔细回顾过去遇到的人之后，开始明白：&gt;&gt; 每个人的人生是一个过程：你从不会做饭到后来的得心应手；从开始一个人生活的不知所措到现在的井井有条；从根本不能习惯离别后到最后的平静；从曾经爱的过度疯癫到现在的小心翼翼。在这个不可逆的过程里，我们只能沉淀，只能向前，变成另外一个人，这个人也许成熟也许挣扎，只愿你能变成一个你不讨厌的自己。&gt;&gt; 而在这其中起到很大作用的，就是你遇到的人。也许他只是在你难过的某个时段恰好在你身旁，也许他在你生病的时候总是在你身旁，也许你连他的名字都不知道。&gt;&gt; 这个世界就是这么不公平，有些人拼命想进入你的世界而你记得的只是陌生人的一个侧影，有些人爱了你很多年你却偏偏爱上只见了几面的另一个人。它就是这么不公平。而我们只能学会去面对。&gt;&gt; 而我们终究要开始习惯明天没有课的生活，学会摸爬滚打。随着毕业，留下的东西会越来越少，但也越来越重要。还好有你，能一起回忆那些年，老朋友。这比什么都重要。&gt;&gt; 总之有些人后来真的再也没见过。&gt;&gt; 而还能陪伴至此的人，一千个一万个感慨","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"MySQL必知必会文字版PDF下载","slug":"mysql必知必会文字版pdf下载","date":"2015-03-23T17:30:17.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/972/","link":"","permalink":"http://www.voyax.meposts/972/","excerpt":"","text":"一本难得的好书，《MySQL必知必会》，简单明了，当个参考手册也不错。 [caption id=”” align=”alignnone” width=”499”] MySQL必知必会（文字版）[/caption] 目录结构： 第1章 了解SQL 1.1 数据库基础 1.1.1 什么是数据库 1.1.2 表 1.1.3 列和数据类型 1.1.4 行 1.1.5 主键 1.2 什么是SQL 1.3 动手实践 1.4 小结 第2章 MySQL简介 2.1 什么是MySQL 2.1.1 客户机-服务器软件 2.1.2 MySQL版本 2.2 MySQL工具 2.2.1 mysql命令行实用程序 2.2.2 MySQL Adminis-trator 2.2.3 MySQL Query Browser 2.3 小结 第3章 使用MySQL 3.1 连接 3.2 选择数据库 3.3 了解数据库和表 3.4 小结 第4章 检索数据 4.1 SELECT语句 4.2 检索单个列 4.3 检索多个列 4.4 检索所有列 4.5 检索不同的行 4.6 限制结果 4.7 使用完全限定的表名 4.8 小结 第5章 排序检索数据 5.1 排序数据 5.2 按多个列排序 5.3 指定排序方向 5.4 小结 第6章 过滤数据 6.1 使用WHERE子句 6.2 WHERE子句操作符 6.2.1 检查单个值 6.2.2 不匹配检查 6.2.3 范围值检查 6.2.4 空值检查 6.3 小结 第7章 数据过滤 7.1 组合WHERE子句 7.1.1 AND操作符 7.1.2 OR操作符 7.1.3 计算次序 7.2 IN操作符 7.3 NOT操作符 7.4 小结 第8章 用通配符进行过滤 8.1 LIKE操作符 8.1.1 百分号（%）通配符 8.1.2 下划线（_）通配符 8.2 使用通配符的技巧 8.3 小结 第9章 用正则表达式进行搜索 9.1 正则表达式介绍 9.2 使用MySQL正则表达式 9.2.1 基本字符匹配 9.2.2 进行OR匹配 9.2.3 匹配几个字符之一 9.2.4 匹配范围 9.2.5 匹配特殊字符 9.2.6 匹配字符类 9.2.7 匹配多个实例 9.2.8 定位符 9.3 小结 第10章 创建计算字段 10.1 计算字段 10.2 拼接字段 10.3 执行算术计算 10.4 小结 第11章 使用数据处理函数 11.1 函数 11.2 使用函数 11.2.1 文本处理函数 11.2.2 日期和时间处理函数 11.2.3 数值处理函数 11.3 小结 第12章 汇总数据 12.1 聚集函数 12.1.1 AVG（）函数 12.1.2 COUNT（）函数 12.1.3 MAX（）函数 12.1.4 MIN（）函数 12.1.5 SUM（）函数 12.2 聚集不同值 12.3 组合聚集函数 12.4 小结 第13章 分组数据 13.1 数据分组 13.2 创建分组 13.3 过滤分组 13.4 分组和排序 13.5 SELECT子句顺序 13.6 小结 第14章 使用子查询 14.1 子查询 14.2 利用子查询进行过滤 14.3 作为计算字段使用子查询 14.4 小结 第15章 联结表 15.1 联结 15.1.1 关系表 15.1.2 为什么要使用联结 15.2 创建联结 15.2.1 WHERE子句的重要性 15.2.2 内部联结 15.2.3 联结多个表 15.3 小结 第16章 创建高级联结 16.1 使用表别名 16.2 使用不同类型的联结 16.2.1 自联结 16.2.2 自然联结 16.2.3 外部联结 16.3 使用带聚集函数的联结 16.4 使用联结和联结条件 16.5 小结 第17章 组合查询 17.1 组合查询 17.2 创建组合查询 17.2.1 使用UNION 17.2.2 UNION规则 17.2.3 包含或取消重复的行 17.2.4 对组合查询结果排序 17.3 小结 第18章 全文本搜索 18.1 理解全文本搜索 18.2 使用全文本搜索 18.2.1 启用全文本搜索支持 18.2.2 进行全文本搜索 18.2.3 使用查询扩展 18.2.4 布尔文本搜索 18.2.5 全文本搜索的使用说明 18.3 小结 第19章 插入数据 19.1 数据插入 19.2 插入完整的行 19.3 插入多个行 19.4 插入检索出的数据 19.5 小结 第20章 更新和删除数据 20.1 更新数据 20.2 删除数据 20.3 更新和删除的指导原则 20.4 小结 第21章 创建和操纵表 21.1 创建表 21.1.1 表创建基础 21.1.2 使用NULL值 21.1.3 主键再介绍 21.1.4 使用AUTO_ INCREMENT 21.1.5 指定默认值 21.1.6 引擎类型 21.2 更新表 21.3 删除表 21.4 重命名表 21.5 小结 第22章 使用视图 22.1 视图 22.1.1 为什么使用视图 22.1.2 视图的规则和限制 22.2 使用视图 22.2.1 利用视图简化复杂的联结 22.2.2 用视图重新格式化检索出的数据 22.2.3 用视图过滤不想要的数据 22.2.4 使用视图与计算字段 22.2.5 更新视图 22.3 小结 第23章 使用存储过程 23.1 存储过程 23.2 为什么要使用存储过程 23.3 使用存储过程 23.3.1 执行存储过程 23.3.2 创建存储过程 23.3.3 删除存储过程 23.3.4 使用参数 23.3.5 建立智能存储过程 23.3.6 检查存储过程 23.4 小结 第24章 使用游标 24.1 游标 24.2 使用游标 24.2.1 创建游标 24.2.2 打开和关闭游标 24.2.3 使用游标数据 24.3 小结 第25章 使用触发器 25.1 触发器 25.2 创建触发器 25.3 删除触发器 25.4 使用触发器 25.4.1 INSERT触发器 25.4.2 DELETE触发器 25.4.3 UPDATE触发器 25.4.4 关于触发器的进一步介绍 25.5 小结 第26章 管理事务处理 26.1 事务处理 26.2 控制事务处理 26.2.1 使用ROLLBACK 26.2.2 使用COMMIT 26.2.3 使用保留点 26.2.4 更改默认的提交行为 26.3 小结 第27章 全球化和本地化 27.1 字符集和校对顺序 27.2 使用字符集和校对顺序 27.3 小结 第28章 安全管理 28.1 访问控制 28.2 管理用户 28.2.1 创建用户账号 28.2.2 删除用户账号 28.2.3 设置访问权限 28.2.4 更改口令 28.3 小结 第29章 数据库维护 29.1 备份数据 29.2 进行数据库维护 29.3 诊断启动问题 29.4 查看日志文件 29.5 小结 第30章 改善性能 30.1 改善性能 30.2 小结 附录A MySQL入门 附录B 样例表 附录C MySQL语句的语法 附录D MySQL数据类型 附录E MySQL保留字 索引下载地址： http://lhyun-wordpress.qiniudn.com/MySQL必知必会（文字版）.pdf &nbsp;","categories":[{"name":"资料","slug":"资料","permalink":"http://www.voyax.me/categories/资料/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.voyax.me/tags/MySQL/"}]},{"title":"网络爬虫之Apache HttpComponents入门","slug":"网络爬虫之apache-httpcomponents入门","date":"2015-03-22T15:48:58.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/37394/","link":"","permalink":"http://www.voyax.meposts/37394/","excerpt":"","text":"注：此文来源于网络，并非原创，在此谢过作者。 1 简介超文本传输协议(http)是目前互联网上极其普遍的传输协议，它为构建功能丰富，绚丽多彩的网页提供了强大的支持。构建一个网站，通常无需直接操作http协议，目前流行的WEB框架已经透明的将这些底层功能封装的很好了，如常见的J2EE, .NET, php等框架或语言。 除了作为网站系统的底层支撑，http同样可以在其它的一些场景中使用，如游戏服务器和客户端的传输协议、web service、 网络爬虫、HTTP代理、网站后台数据接口等。 Http Components 对HTTP底层协议进行了很好的封装，如果你是一个J2EE、.net或php程序员，对下面涉及的概念可能不会陌生。 2 httpComponents组件结构HttpComponents Core简称HttpCore, 是一组底层Http传输协议组件，支持两种I/O模型，阻塞I/O模型和和非阻塞I/O模型。上层组件(HttpComponents Client, HttpComponents AsyncClient)依赖此组件实现数据传输。 阻塞I/O模型基于基本的JAVA I/O实现，非阻塞模型基于JAVA NIO实现。 HttpComponents Client 建立在HttpCore之上的Http客户端管理组件。底层基于HttpCore 阻塞I/O。从Commons HttpClient 3.x 继承而来，Commons HttpClient原来是apache commons组建的一部分，现在被HttpComponents Client所替代了。 原始的Commons HttpClient 3.x可以在http://hc.apache.org/httpclient-legacy/index.html找到。 HttpComponents AsyncClient建立在HttpCore NIO模型之上的Http客户端，与基于阻塞I/O的HttpComponents Client形成互补，由于底层使用的NIO非阻塞模型，所以适用于高性能的应用场景。 开始使用HttpComponents组件 首先打开http://hc.apache.org/，点击左侧的Download链接，进入下载页面，下载最新版本的HttpComponents。在编写本文时最新版本是4.1.2。解压缩下载到的压缩包，lib目录下是HttpComponents和它依赖的类库，将它们放到你的工程classpath中，如果依赖文件已经存在了，不要放置多份，以免类库之间的冲突。 然后需要检查一下工程的classpath中是否存在commons http包。Commons http与HttpComponents是完全两个东西，HttpComponents中的Client是从Commons http继承而来的，所以很多类名是相同的。为了避免出现莫名奇妙的问题，应将Commons http从工程中删除（当然，如果你认为自己足够聪明，也可以在引用java包时小心区分）。 Commons http类库的包是org.apache.commons.httpclient HttpComonents类库的包是org.apache.http 3 Get请求Get、Post是最常见的获取网页内容的请求形式，当然，返回内容并非必须是html代码，任何的xml、json或文字字符串都可以作为返回内容。 下面是用Get请求获取一个html网页内容的代码 // (1) 创建HttpGet实例 HttpGet get = new HttpGet(\"http://www.126.com\"); // (2) 使用HttpClient发送get请求，获得返回结果HttpResponse HttpClient http = new DefaultHttpClient(); HttpResponse response = http.execute(get); // (3) 读取返回结果 if (response.getStatusLine().getStatusCode() == 200) { HttpEntity entity = response.getEntity(); InputStream in = entity.getContent(); readResponse(in); } 1）HttpGet的实例就是一个get请求，构造函数只有一个字符串参数，即要获取的网页地址。另外一种构造形式是使用URI实例作为HttpGet的参数。HttpComponents提供了URIUtils类，它的createURI()返回一个URI实例，将请求地址拆分构造不失为一种更加清晰的方式。 URI uri = URIUtils.createURI(\"http\", \"[www.126.com](http://www.126.com/)\", 80, \"/\", \"\", null); HttpGet get = new HttpGet(uri); （2）请求最后被HttpClient发送出去，new DefaultHttpClient()创建一个基本的HttpClient实例。由于底层是基于阻塞的JAVA I/O模型，执行execute()的时间与具体请求的远程服务器和网络速度有关，在实际运行场景中应特别注意此问题。如果是在tomcat等环境中执行可能会造成线程等待，浪费服务器资源，或拒绝其它的连接。 （3）请求返回后就可以读取返回内容了，但有一个前提是此次请求是否真的成功了？服务器地址错误，或请求的页面不存在等问题都会让请求失败。为了确保得到了正确的响应首先应判断返回码是否正确。调用response.getStatusLine()返回一个StatusLine的实例，此实例描述了一次请求的响应信息。一个成功响应的StatusLine实例本身包含如下信息： > HTTP/1.0 200 OK > > > HTTP/1.0：是请求协议和版本号 > > > 200：是响应码 StatusLine的下面2个方法分别用于获取响应信息的各部分内容 > getProtocolVersion()： 得到请求协议和协议版本号，如HTTP/1.0 > > > getStatusCode()：得到响应码，如200 HttpEntity entity = response.getEntity()返回一个HttpEntity实例，进而调用getContent()就得到了一个输入流。后面的事情应该很明确了。readResponse()是一个自己写的读取输入流中字符串的方法，代码如下： public static void readResponse(InputStream in) throws Exception{ BufferedReader reader = new BufferedReader(new InputStreamReader(in)); String line = null; while ((line = reader.readLine()) != null) { System.out.println(line); } } 4 Post请求Post请求在代码上与Get请求的主要区别是将HttpGet换成了HttpPost，其余部分代码基本一致。请看代码： // (1) 创建HttpGet实例HttpPost post = new HttpPost(“http://www.126.com“); // (2) 使用HttpClient发送get请求，获得返回结果HttpResponseHttpClient http = new DefaultHttpClient();HttpResponse response = http.execute(post); // (3) 读取返回结果if (response.getStatusLine().getStatusCode() == 200) { HttpEntity entity = response.getEntity(); InputStream in = entity.getContent(); readResponse(in); }与Get请求不同的代码被标注为红色。可见Post请求与Get请求在代码上的区别并不大，互相切换也是比较容易的。在下面可以看到的令一个不同之处是传递的查询字符串，即请求参数。 5 参数传递Get与Post在传递参数时有一些区别，Get请求的参数作为查询字符串出传递，而Post请求的参数则作为实体传递。在开发WEB项目时经常遇到乱码的问题，使用HttpComponents也会涉及到这个问题，所以在使用时应特别注意。服务器端的处理方法与WEB项目相同， HttpComponents只要注意字符编码就可以了。 Get请求传递参数方法一：将查询字符串作为请求地址的一部分 这是一种最简单的传参方式，将查询参数用(&amp;)连接，然后放在请求地址?的后面，如下面这个请求地址 http://localhost:8080/servlet1?name=ahopedog&amp;work=programer 请看代码： // (1) 创建HttpGet实例HttpGet get = new HttpGet(“http://localhost:8080/jsx/servlet?id=007“);这里只对请求地址稍作了些修改，请求地址是http://localhost:8080/jsx/servlet查询参数是id=007请求地址与查询参数之间用?连接 Get请求传递参数方法二：使用URI携带查询字符串还记得上面提到的HttpGet有一种用URI构造的方法吗？这第二种传递的方式就是借助了这个机制，只是HttpComponents提供了一种创建查询参数比较清晰的方式NameValuePair // (1)创建查询参数List params = new ArrayList();params.add(new BasicNameValuePair(“name”, “ahopedog”));params.add(new BasicNameValuePair(“work”, “程序员”));String queryString = URLEncodedUtils.format(params, “utf-8”); // (2) 创建Get实例URI uri = URIUtils.createURI(“http”, “localhost”, 8080, “/jsx/servlet”, queryString, null);HttpGet get = new HttpGet(uri);(1)NameValuePair用一对键、值表示一个查询参数，将多个NameValuePair放在一个List中，就形成了一组查询参数。但是List并不能直接被HttpGet使用，所以需要用URLEncodedUtils.format()方法将其编码成字符串。URLEncodedUtils是HttpComponents提供的一个编译查询字符串的工具类。(2)使用编译好的查询字符串构造URI对象，这样查询参数就一起被发送到了服务器上。其实，这里的查询字符串完全可以手工的方式拼凑出来，只是，从代码的清晰性和维护性方面考虑，NameValuePair和URLEncodedUtils的方式更加可取。值得一提的是，在开发J2EE项目时，经常遇到一些查询条件或请求条件众多的情况，有的是将多个值放在一个Map中管理，有的则创建一个固定结构的Java Bean类。在这方面不同人可能会有不同的看法。Map方式固然省事，而且也很灵活，但是如果缺少了文档和注释时，会很难知道这个Map中放的到底是什么。而创建成Java Bean的话，代码本身就是一个很好的说明，让人一目了然，缺点是导致Java Bean的急剧增加，以致混乱和难以管理。本人想不到什么很完美的解决办法，但是，任何极端的方式都是不可取，我想在这时折中或许稍好些，什么方法由场景决定。Post请求传递参数： // (1) Post请求HttpPost post = new HttpPost(“http://localhost:8080/jsx/servlet“); //添加参数List params = new ArrayList();params.add(new BasicNameValuePair(“name”, “ahopedog”));params.add(new BasicNameValuePair(“work”, “程序员”));post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8)); // (3) 发送请求HttpClient http = new DefaultHttpClient();HttpResponse response = http.execute(post);也是用到了List组织参数，这样就不用费更多心思研究新的方式了。将请求参数加入查询是上面代码中红色文字的一行。很简单，只要别把你的字符编码搞错就行了。 6 响应直接操作响应中的输入流是最直接也是最有效的方式，不过需要注意的一点是，输入流读取完以后一定要将其关闭。其实在前面的代码中已经涉及过了对响应的处理，这里再加详细的给予说明： // (1) Post请求HttpPost post = new HttpPost(“http://www.126.com“); // (2) 发送请求HttpClient http = new DefaultHttpClient();HttpResponse response = http.execute(post); // (3) 处理响应结果if (response.getStatusLine().getStatusCode() == 200) {HttpEntity entity = response.getEntity(); // (4) 从输入流读取网页字符串内容System.out.println(entity.getContentType());System.out.println(entity.getContentEncoding());System.out.println(entity.getContentLength()); InputStream in = null;try{in = entity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(in));String line = null;while ((line = reader.readLine()) != null) {System.out.println(line);} }finally{//记得关闭输入流if(in != null)in.close();}在本例中只需关心标记为红色的代码，其它行的代码上面已经介绍过了。HttpEntity有3个获取返回数据的描述信息（或叫做元数据）getContentType()：获取响应体的类型getContentEncoding()：获取响应体的字符编码getContentLength()：获取响应体的字节长度元数据的内容由远程服务器返回，实际上这些信息是包含在响应的头部信息中的，HTTP请求的响应头中还包含了其它有用的信息，HttpComponents将返回头中的关键元数据封装到了HttpEntity中，已便于使用。entity.getContent()可以得到响应体的InputStream，有了这个流对象，基本上就可以”为所欲为”了。因为InputStream是Java I/O中底层的基础类，结合相对上层的输入流对象或者对字节进行编码等方法就可以获得不同类型和形式的响应数据了。在本例中用BufferedReader将响应体以字符串形式读取（返回的内容确实也是字符串的内容）。 7 headers头部信息在客户端与服务器的HTTP传输过程中提供元数据，如服务器类型、处理时间、内容长度、内容类型等。 7.1 请求头部信息下图是用Firefox访问Google时获取到的请求头信息，在我们使用浏览器访问一个网址时，浏览器都会默默的将一些与请求和客户端相关的信息发送给服务器，让服务器能更好的处理特定的客户端请求。这里面也包括了Cookie。 从上图中可以看到，在发送给服务器的头信息里，Host是我们访问的远程服务器主机地址。User-Agent是浏览器标识，服务器程序可以通过这个字符串得知客户端浏览器的类型和操作系统等信息。Accept-Charset则是客户端可以接受的字符编码类型。 其它各参数的含义在这里就不再一一说明了，感兴趣的读者可以参考相关文章或在Google上搜索相关的资料。 我们是使用HttpComponents代替浏览器访问服务器，默认情况并不包含浏览器所传递的头信息。即使不传递这些信息，通常服务器也会正常返回你所要的网页HTML内容的。但如果你真的很无聊，或者有一些特殊的操作，则完全可以模拟浏览给远程服务器发送这些头信息。 // (1) Post请求HttpPost post = new HttpPost(“http://www.126.com“); // (2) 添加请求头信息post.setHeader(“User-Agent”, “Ahopedog/5.0 (Linux NT 5.1; rv:5.0) Gecko/20100101 FireDog/5.0”);post.setHeader(“Accept-Charset”, “GB2312,utf-8;q=0.7,*;q=0.7”); // (3) 发送请求HttpClient http = new DefaultHttpClient();http.execute(post);上面两行红色代码向HttpPost中添加了User-Agent, Accept-Charset两个头信息（内容可以随意设置），头信息会随着HttpClient的execute一起发送出去。 7.2 响应头部信息还是先在浏览器中都会得到什么样的响应头 上图内容是从FireBug返回头的截图，返回头包含了服务器时间，缓存控制，返回内容编码，服务器等信息。这里很有意思的一处是Google的服务器是gws，而百度的服务器则是BWS/1.0，从没见过的服务器，看来是自主研发的，不过名字也用不着太相近吧。接下来，看看HttpComponents是如何解析这些信息的 // (1) Post请求HttpPost post = new HttpPost(“http://www.126.com“); // (2) 发送请求HttpClient http = new DefaultHttpClient();HttpResponse response = http.execute(post); // (3) 遍历返回头Header[] headers = response.getAllHeaders();for(Header h : headers){System.out.println(h.getName() + “ : “ + h.getValue());}System.out.println(“======================================”); // (4) 获取Server头信息，头名字不区分大小写Header serverHeader = response.getFirstHeader(“server”);System.out.println(serverHeader.getName() + “ : “ + serverHeader.getValue());(3)response.getAllHeaders()得到响应头数组，一个响应头封装成一个Header实例。Header的两个关键方法是getName()和getValue()，得到头名字和值。(4)response.getFirstHeader()可以指定获取一个特定的头，需要指定头的名字。多个头名字是可以重名的，而getFirstHeader是得到同名头中的第一个。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"HttpComponents","slug":"HttpComponents","permalink":"http://www.voyax.me/tags/HttpComponents/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.voyax.me/tags/爬虫/"}]},{"title":"Shadowsocks + ChnRoute 实现 OpenWRT 路由器自动翻墙","slug":"shadowsocks-chnroute-实现-openwrt-路由器自动翻墙","date":"2015-03-16T06:08:55.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/42761/","link":"","permalink":"http://www.voyax.meposts/42761/","excerpt":"","text":"原文地址：https://cokebar.info/archives/664#method1 这篇文章介绍的方法基于aa65535的shadowsocks-spec for openwrt，介绍了如何在OpenWRT下配置自动翻墙，新版本支持在Luci下图形化配置，大大简化了配置过程。配置完成后，路由器本身获得自动翻墙能力，所有连入该路由的设备都可无障碍访问被墙的站点。是运行于路由器的透明代理。 方案根据IP判断是否代理，国内IP不代理，国外IP走代理。代理通过shadowsocks所带ss-redir做TCP转发实现，分国内外IP通过国内IP段列表文件chnroute来区别，并通过iptables规则分别处理（这些功能已经全部集成到shadowsocks-spec里了无需额外配置）。由于是基于IP的判定，故需要解决DNS污染的问题，故搭配使用ChinaDNS来解决。 由于只要国外IP均走代理，而不是被墙才走代理，那么本方案的优缺点也就很明显了。 优点：基本不会有漏网之鱼，保证所有被墙站点能访问；能够一定程度改善国内访问一些国外网站缓慢的问题，如果你的服务器速度很好，那么甚至可以起到加速国外站点访问的作用。 缺点：如果服务器速度一般，访问一些网站甚至会减速；对一些限制IP的站点和软件应用可能会造成麻烦。总之，请酌情选择。 本方案主要涉及到的开源项目 https://github.com/aa65535/openwrt-shadowsocks https://github.com/aa65535/openwrt-chinadns https://github.com/aa65535/openwrt-redsocks2 https://github.com/aa65535/openwrt-dist-luci https://github.com/madeye/shadowsocks-libev https://github.com/clowwindy/ChinaDNS 一、shadowsocks 安装次安装的话，先安装必要的包，确保路由器联网，先更新软件包列表（下载有问题的请手动到openwrt.org下载所有需要的包并上传到路由器上使用opkg install XXX.ipk命令安装）： opkg update shadowsocks有openssl（文件名是shadowsocks-libev-spec-X.XX.ipk）和polarssl（文件名是shadowsocks-libev-spec-polarssl-X.XX.ipk）两个版本选择，ROM空间吃紧的就选择后者吧。 先安装必要的包，如果要用polarssl版本的shadowsocks（polarssl体积更小）： opkg install ipset libpolarssl resolveip 如果要用普通版本（openssl）的shadowsocks，那么(openssl兼容性更好)： opkg install ipset libopenssl resolveip 期间可能会遇到类似以下的错误提示： kmod: failed to insert /lib/modules/3.10.44/ip_set.ko kmod: failed to insert /lib/modules/3.10.44/ip_set_bitmap_ip.ko kmod: failed to insert /lib/modules/3.10.44/ip_set_bitmap_ipmac.ko ... 没关系，这时因为安装ipset包后需要重启，我们此时先重启一次路由器。 > 然后下载下面四个包，前两个ipk包需要根据自己CPU型号选择： > > 下载地址： > > shadowsocks-spec: http://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/ > > chinadns-openwrt: http://sourceforge.net/projects/openwrt-dist/files/chinadns/ > > > luci-app-shadowsocks: http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/ > > > luci-app-chinadns: http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/ 接着将下载的包通过WinSCP之类的工具上传至路由器的/tmp目录。 接着安装shadowsocks和chinadns，一步步执行： cd /tmp opkg install shadowsocks-libev-spec_x.x.x-x_ar71xx.ipk opkg install ChinaDNS_x.x.x-x_ar71xx.ipk opkg install luci-app-chinadns_x.x.x-x_all.ipk opkg install luci-app-shadowsocks-spec_x.x.x-x_all.ipk 特别提醒：2015.1.8，由于ChinaDNS-C更名为ChinaDNS，所以包名有变化，此前安装过ChinaDNS-C的，需要手动卸载并重新安装新版。 安装完成后，shadowsocks和chinadns应该会被配置成开机启动，如果发现没有生效，运行： /etc/init.d/shadowsocks enable /etc/init.d/chinadns enable 二、shadowsocks 配置我们登陆Luci，指向“服务”，此时应该能够看到shadowsocks和chinadns了。 点击shadowsocks，取消勾选“使用配置文件”，新的选项就出来了，我们把服务器信息填进去，代理方式选择“忽略列表”，然后先把下面UDP转发功能关闭，然后保存并应用（选项不要留空）。服务器地址请尽量填入IP，否则容易出问题！ 全部完成后，刷新页面，确保shadowsocks是已启动状态。否则请检查配置。 [caption id=”” align=”alignnone” width=”345”] shadowsocks[/caption] 当然，你可以继续使用 config.json 进行配置，格式如下： { “server”: “X.X.X.X”, “server_port”: “443”, “password”: “password”, “local_port”: “1080”, “method”: “rc4-md5”}最后记得在Luci里面填把“使用配置文件”勾上，然后填写配置文件位置（不要留空）：然后看一下ChinaDNS的配置界面，此时可以先按照默认的配置来，确保ChinaDNS可以正常启动，也可以参考下面：做出说明： ChinaDNS参数说明: 1、虚假IP列表：默认值：/etc/chinadns_iplist.txt 是GFW常见的DNS污染用IP列表，解析出列表中的IP结果时候，ChinaDNS会自动抛弃，保留默认即可； 2、chnroute文件：默认值：/etc/chinadns_chnroute.txt 此文件标识哪些IP属于国内。用于ChinaDNS判断解析结果。ChinaDNS要求解析结果与DNS要匹配，国内网站采用国内DNS解析的结果，国外网站采用国外DNS解析结果，等等规则；确保以上两个文件内容完整无误，否则会造成无法启动； 3、本地端口：默认值：5353 ChinaDNS所监听的端口。根据实际情况更改，注意不能和其他服务的端口重复（特别是dnsmasq和shadowsocks）； 4、上游服务器：默认值：114.114.114.114,8.8.8.8 可填入一系列的上游DNS服务器，根据实际情况来，可以保留默认，注意逗号后面不能有空格。有些ISP会封杀公共DNS，此时请将114DNS改为ISP的DNS；此处必须至少填入一个国内IP的DNS和一个国外IP的DNS，否则会造成ChinaDNS启动失败。 4、等待时间： 默认值：0.3 为防止GFW的DNS污染抢答，而设置一个等待时间，请根据自己填写的国外DNS延迟值来填写，留下一定的裕度。GoogleDNS在国内延迟一般在100-200ms，留0.3比较合适。过大的值会造成DNS解析较大的延迟时间，过小的值可能导致无法接收正确的解析结果。 5、双向过滤： 默认：勾选 勾选时，当国外DNS服务器返回的查询结果是国内IP，或者当国内DNS服务器返回的查询结果是国外IP，则过滤掉这个结果（较为严格的模式）；去掉勾选的话只是过滤国内DNS的国外IP结果。 6、启用压缩指针： 默认：不勾选 利用GFW遇到压缩指针时的一个bug来精确识别来自GFW的抢答污染，从而极大提高识别的准确性和识别的效率，推荐启用，启用后，IPList和等待时间将禁用（因为用不到了）。然后，在Luci中切换至“网络”-“DHCP/DNS”设置，如下图，在”DNS转发”中填入127.0.0.1#5353 其中，5353是ChinaDNS的端口，如果你在之前设置界面里改了，这里记得别填错。 然后切到HOSTS和解析文件选项卡，勾中“忽略解析文件” 接下来的步骤会有区别，通过ChinaDNS进行防DNS污染及解析结果优化，方案有三： 1、对于shadowsocks是用自己服务器搭建的，推荐方案一，在自己服务器上搭建DNS服务； 2、如果没有这个条件，但服务器支持UDP转发（较新版本Shadowsocks均支持），那么方案二； 3、如果服务器Shadowsocks版本老，不支持UDP转发，那么可用方案三，要求版本&gt;=1.2.0； 4、如果方案三不好用，可以考虑使用方案四：TCP 方式查询解决 DNS 污染问题 前两种方案，目前来说是绝对没有DNS污染现象的，此时ChinaDNS的作用完全就是为国外站点做解析优化，因为DNS查询由代理服务器转发，DNS查询的发起者相当于代理服务器，获得的解析结果都是就近于代理服务器的；而方案三则会直面DNS污染，此时ChinaDNS的防污染功能发挥作用，同时方案三无法做到国外网站解析结果优化，因为获得的IP是就近于你的位置的。方案四则可以有效的避免国外DNS的污染，不过同样也无法做到国外网站解析结果优化。 然而对于前两种方案，也可能存在一些问题（很少见） 方案一 在代理服务器上搭建DNS服务来解析国外网站，可用dnsmasq或者pdnsd，监听非53端口。 比如说服务器IP是：3.4.5.6，dns服务端口是5050，那么，把ChinaDNS的上游服务器更改为： 114.114.114.114,3.4.5.6:5050，等待时间改为0.1秒（视VPS延迟酌情增加）；有些ISP使用114DNS可能效果不佳，此时可以将114DNS换成本地ISP的； 也可以勾选“启用压缩指针”，这样就无需延迟时间了： 最后，确保shadowsocks的设置页面里面的UDP转发是关闭状态。保存并应用，确认shadowsocks和chinadns都显示已启动后，就可以测试一下了~ 方案二 使用shadowsocks代理DNS请求。首先开启shadowsocks的DNS转发，并确保端口号不和ChinaDNS的一样，比如说我们改成5151；转发地址留默认的GoogleDNS即可，你也可以自行更改，格式是“IP:端口”。 然后配置ChinaDNS的上游DNS服务器为： 114.114.114.114,127.0.0.1:5151，等待时间填0.1（视VPS延迟酌情增加），其他酌情填写；有些ISP使用114DNS可能效果不佳，此时可以将114DNS换成本地ISP的： 也可以勾选“启用压缩指针”，这样就无需延迟时间了： 保存并应用，确认shadowsocks和chinadns都显示已启动后，Enjoy~ 方案三 首先确保shadowsocks配置页面的UDP转发关闭；并且确保你可以正常使用国外公共DNS服务。 切换至ChinaDNS界面，填入上游服务器地址，可以保留默认的114.114.114.114,8.8.4.4 勾选“启用压缩指针”： 或者不勾选“启用压缩指针”，但要酌情填写延迟时间，默认0.3秒（视VPS延迟酌情增加或减小）： 双向过滤可以打开；有些ISP使用114DNS可能效果不佳，此时可以将114DNS换成本地ISP的。 确认shadowsocks和chinadns都显示已启动后，Enjoy~所有的步骤完成后，可以尝试一些额外的步骤，比如： 使用作者提供的源来更加方便地更新shadowsocks和chinadns 定时检测代理状态遇到异常自动重启 PS1：ignore.list的定期更新，可以使用下面的命令： wget -O- ‘http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest‘ | awk -F| ‘/CN|ipv4/ { printf(“%s/%d\\n”, $4, 32-log($5)/log(2)) }’ &gt; /etc/shadowsocks/ignore.list或 curl ‘http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest‘ | awk -F| ‘/CN|ipv4/ { printf(“%s/%d\\n”, $4, 32-log($5)/log(2)) }’ &gt; /etc/shadowsocks/ignore.list当然你也可以重新下载新版的shadowsocks重新安装。ChinaDNS的同样也需要更新，默认位置是 /etc/chinadns_chnroute.txt PS2：ChinaDNS的 chinadns_chnroute.txt 和shadowsocks的 ignore.list 其实是重复的，此时你只需把luci配置界面里面ChinaDNS的chnroute改成 /etc/shadowsocks/ignore.list 就行了， chinadns_chnroute.txt 也就可以删除了，这样一来省点空间，而且免去要同时更新两个文件的麻烦。 PS3：如遇到别的被墙站点没问题但YouTube, Facebook, Twitter打不开，应该是DNS污染造成，请用dig命令排查，并尝试更换DNS转发方案。方案一和方案二可以配合这个dnsmasq配置文件使用效果更佳：dnsmasq_list.conf ，具体用法我就不详细说了，总之去掉ipset=/…/…的行，然后把127.0.0.1#5353改成你的相应地址。 PS4：有些ISP会禁用外部DNS，只能用ISP的，此时不要使用114DNS等公共DNS而要使用ISP的DNS；有些ISP做了DNS劫持，可能会导致指针压缩失效；有些ISP封杀国外UDP端口，会造成三种方案全部失效，请考虑方案四。","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[]},{"title":"人大经济学专业复试真题","slug":"人大经济学专业复试真题","date":"2015-03-16T03:13:57.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/54370/","link":"","permalink":"http://www.voyax.meposts/54370/","excerpt":"","text":"房地产经济学复试真题 国民经济学复试真题 环境学院人资环复试真题 金融学复试真题 经济学院国贸、世界经济复试真题 企业经济学 企业经济学复试 区域经济学复试真题 商学院国际贸易专业复试真题 西方经济学复试真题 政治经济学复试真题内容如下： [caption id=”” align=”alignnone” width=”500”] 人大复试真题[/caption] 下载地址： http://lhyun-wordpress.qiniudn.com/人大部分经济学专业复试真题.zip","categories":[{"name":"资料","slug":"资料","permalink":"http://www.voyax.me/categories/资料/"}],"tags":[{"name":"人大金融","slug":"人大金融","permalink":"http://www.voyax.me/tags/人大金融/"}]},{"title":"少年时，意气风发","slug":"少年时，意气风发","date":"2015-03-15T16:33:15.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/17748/","link":"","permalink":"http://www.voyax.meposts/17748/","excerpt":"","text":"[caption id=”” align=”alignnone” width=”533”] 少年时，意气风发[/caption] 连续熬了几个天，终于可以着手毕设的事情 从西南到东南 又从东南碾转华北 这一遭竟也绕遍了大半个中华。 从深圳回学校，到北京已是晚上十点，坐在回学校的大巴,和朋友有一搭没一搭的闲聊。 不知是北京的夜晚太冷还是这是个毕业季，望着窗外北京的寒夜，也没顾得上对方是个女生，我发了句 “回到北京感觉比刚去深圳还陌生”。 想冲到马路吼叫什么，却连张嘴的勇气都没有…… 回到校园，才明白，书生意气。 回学校的第一天清晨，在校园里闲荡，宽阔的马路，清静得让我没了脾气。 在图书馆坐了一个下午一个晚上，此刻才能明白陶醉是怎样的境界。 开学第一周，慢得出奇。 打了三次球，骑着自行车陪同学逛清华，去实验室装模作样的干活，晚上熬夜码代码，出去聚餐，还正儿八经在北京过了一次生日，还是没将这第一周彻底干掉…… 刚搞定公司的任务，打开音乐，第一首恰是《let it go》，这是我最喜欢的歌曲之一。 挣扎与反抗，绝望却不屈。 前两天和同学谈起创业，少年时都该有这样的激情。 不要期待成为下一个BAT，要有超越BG的信念。 至于信念为何物，晚上把枕头塞高点。 也许世事变幻，我们会穷困潦倒 但， 天涯海角， 我都愿战斗到底，笑傲世事 若有缘。 愿君是归人，不再是过客 &nbsp; 2015年3月16日00:32于北京 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"反向代理使用Google","slug":"反向代理使用google","date":"2015-03-12T16:57:17.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/41792/","link":"","permalink":"http://www.voyax.meposts/41792/","excerpt":"","text":"无奈以前用的代理失效了，分享一些反向代理使用Google的网址： http://www.gugesou.com/ http://www.googke.me/ http://s.amysql.com/ http://onccc.net/ http://www.googleisok.com/ https://yue.pao.im/ https://da.pao.im/ https://ibd.pt/ https://soso.red/ https://google.sqzr.cc/ https://www.out1000.com/ http://web.btbook.net/ https://www.lamjoeone.info/ https://jiong.lu/ http://www.googleforchina.com/ https://g.net.co/ https://repigu.com/ https://awk.so/ http://gl.randomk.org/ https://g4w.me/ https://safesearch.avira.com https://sec.hikyle.me/ http://suche.web.de/ http://webwebweb.com/ http://guge.io/ https://g.keyiso.com/ https://goojie.me/ http://e127f.azurewebsites.net/ http://0s.o53xo.m5xw6z3mmuxgizi.erenta.ru/ http://www.souji8.com/ http://865ba.azurewebsites.net/ https://gusouk.com/ https://d3vv89cvqbrqlq.cloudfront.net/ http://out1000.com/ https://gg.jude.me/ http://google.chn.im/ http://www.sousuodao.com 搜索岛 http://www.googleout.com/ https://g.ratafee.nl/ http://www.1220.cc/ http://music.google.cn/webhp https://www.glgoo.com GLGOO https://gg.eeload.com/ GG.EELOAD.COM http://gusou.in/ GUSO.IN http://www.wow.com/ WOW https://xie.lu/ 斜路 https://www.ggncr.com GGNCR.COM http://www.gfsoso.com 谷粉搜搜 http://www.886404.com/ 886 404 Google https://g.ttlsa.com/ http://home.tb.ask.com/ ASK Google http://verygoogle.com/ http://g.openibm.com/ OpenIBM Google http://z7.cc http://www.Google.com.im 谷歌复原 http://goog.sinaapp.com https://sinaapp.co/ Google镜像 https://wen.lu/ Google问路 www.sssis.com 备案域名反代理到Google IP http://www.gvgle.com 代理到Google IP http://gu1234.com 代理到Google IP http://www.xiexingwen.com Google镜像，动态检测可用Google服务器IP，实时更新 https://s3.amazonaws.com/google./index.html Google免翻墙镜像，如果镜像被封锁，访问https://github.com/greatfire/wiki 获得最新网址。 http://www.GoogleStable.com www.GoogleStable.com http://www.tmd123.com 通天塔","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[]},{"title":"mac 安装mongodb","slug":"mac-安装mongodb","date":"2015-03-09T12:50:37.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/54449/","link":"","permalink":"http://www.voyax.meposts/54449/","excerpt":"","text":"一.安装homebrew(如果已装，忽略)ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" brew官网：[http://brew.sh/](http://brew.sh/ \"brew官网\") ## 二.安装mongodb 1.Update Homebrew’s package database. In a system shell, issue the following command: brew update 2.多种安装方式： ### install the MongoDB binaries brew install mongodb Install the Latest Development Release of MongoDBbrew install mongodb --devel build MongoDB from the source files and include SSL supportbrew install mongodb --with-openssl","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://www.voyax.me/tags/mongodb/"}]},{"title":"语法糖（Syntactic sugar)和鸭子类型（duck typing）","slug":"语法糖（syntactic-sugar和鸭子类型（duck-typing）","date":"2015-03-08T08:25:53.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/54909/","link":"","permalink":"http://www.voyax.meposts/54909/","excerpt":"","text":"今天看《mongodb权威指南》时，看到一个词语——语法糖，读书太少，以前竟然都没听过，赶紧wiki…… 语法糖Syntactic sugarwiki 语法糖 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 百度百科 语法糖 举个例子：在C语言里用a[i]表示(a+i),用a[i][j]表示((a+i数组a第二维的长度)+j)，由此可见语法糖不是“现代语言”独有，这种写法简洁明了，容易被人理解。 实际上从面向过程到面向对象也是一种语法糖，C语言可以通过它的指针、类型转换，结构实现面向对象的编程风格，但是C++更进一步的推广了这种风格，更加易用，不过到了C#把OO的风格发挥得淋漓尽致。OO的编程风格对于面向过程来说是不是一种语法糖呢？如果生硬地照此理解，只有计算机硬件指令才不算语法糖，而其他一切利用编译器、汇编器将代码抽象，和自然语言更相近的手段都算语法糖。 很多很多编程思想，编程理论层出不穷，当然，对于学习来说我们是要抓住技术的核心，但对于工程来说如何提高工程质量，如何提高工程效率也是我们要关注的，既然这些语法糖能辅助我们以更好的方式编写代码为什么要“抵制“呢? 语法糖和其他编程思想一样重要，什么duck type，人本接口，最小接口，约定优于配置，广义来讲都是一些思想上的“语法糖“。 不过也并不是没有反对的声音，这其中就有图灵奖的第一个获得者: Alan Perlis。.net从2.0到3.0到3.5底层CLR并没有做更新，没有添加任何新的IL指令，所以C#从2.0到3.0中所有的特性都是语法糖，就算从1.0到2.0，也只有一个泛型不是语法糖，其余的新特性也都是如此，但是每一次C#发布新特性的时候我们不得不为之而鼓舞，为之而喝彩。新的语法可以酿造更好的编程风格，一些难以实现的方面也轻而易举了。 需要声明的是“语法糖”这个词绝非贬义词，它可以给我们带来方便，是一种便捷的写法，编译器会帮我们做转换；而且可以提高开发编码的效率，在性能上也不会带来损失。顺便说一下鸭子类型 鸭子类型（duck typing）在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 从鸭子类型，我们可以联想到它的推导，并不在乎类型的真正实体，只要他的行为有鸭子的特性，那么我们就可以把它当做一只鸭子来看到。在动态语言设计中，可以解释为无论一个对象是什么类型的，只要它具有某类型的行为（方法），则它就是这一类型的实例，而不在于它是否显示的实现或者继承。 鸭子类型在动态语言中被广为奉行。某类接口需要一个log接口，换句话说这借口中需要调用传入对象的log，方法，在动态语言中无论你传入的是什么对象，只有具有log方法则就是合法的。而java，c#这类静态强类型语言（当前首先声明c#已经不是纯的静态强类型语言，它具有dynamic，表达式，当然这里所说的c#是去掉这类特性，或者说C#2.0吧）我们传入的对象是必须显示实现该接口的类实例，他们直接必须具有显示的继承链。 以上所说的是两类语言设计中的对抽象的制约的区别。 javascript中鸭子类型的实现function log(logger){ logger.log(“hello world”)； } log({log:function(msg){ console.log(msg); }});代码量很少，这里只是一种简单的约定，而不是强制，使得我们的自控感增强，所以我喜欢javascript这门语言给我的自由度。但是相对于java这类静态强类型语言而言是将语法的检查推向了运行时期，延迟了发现问题的时间，不助于我们的调试。在强类型系统的语言中由于具有完备的类型信息，我们可以提高良好的IDE于开发时限制，有助于我们的大规模开发。所以这里没有对错，只是看你的选择和喜爱。如果你是一个优秀的程序员，动态语言这种检查的推迟对你并无什么问题，因为你能够有条理次序的节奏型开发。 关于鸭子型风格这里还得必须提到go语言，也是go语言带来我对这种风格的思考。我们还可以显示的定义在消费者方法中，形如 func SomeFunction(logger interface{Log(string)}){ logger.Log(“hello world, I am go lang”). }实现提供者： type S struct { } func (this *S)Log(msg string) { console.log(msg) }在类型S就是一个实现了Logger的实例。 Go还有一种叫做空接口，能够容纳万物的东西: func log(any interface{}) int { return any.(I).Get() }Go语言不同于其他鸭子类型语言的是它实现了在编译时期检查，同时也不失这种自由度。 另外TypeScript想必你也知道 ，这与google的dart一样致力于将javascript带入大规模开发的语言，不同的是TypeScript是javascript的超集，并不是重造一门新语言。他为javascript引入的接口，类型，泛型等较完备的类型系统，是的能够有更好的IDE支持，从某种程度上来说，这是对鸭子类型或者javascript编译器的检查推迟的弥补。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"［转］关于前端的那些事","slug":"［转］关于前端的那些事","date":"2015-03-04T04:47:55.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/23042/","link":"","permalink":"http://www.voyax.meposts/23042/","excerpt":"","text":"看到堂主一篇讲前端的文章，颇有同感，转载如下： 好吧，最近有些人又在讨论“前端是不是一个低级工种”、“前端这个职位是不是有存在的必要”等类似的问题了。这里说“又”是有原因的，因为这类话题出现的频率虽不似月经贴，但每隔一段时间年也总会出来秀一下下。 作为一个立志于为前端布道的从业者，有些个体的声音需要发出。 【1. 前端的尴尬】目前，前端的地位及受重视程度，相比前几年有了极大的提升。但尴尬之处仍存在，具体体现为：国内大部分有互联网业务的企业确实不需要专业前端，专业前端的就业面及需求量相比JAVA、PHP等开发工程师而言明显局限。 对大部分有互联网业务的企业而言，它们的互联网产品，开发工程师或者视觉设计师自己写一写table可能就够了，甚至其产品都是外包公司做出来的。即便需要前端也只是充当切图的页面仔，涉及到JS也只是实现一些简单交互。有的从业者甚至通过搜索引擎，搜出一些模板、代码片段，修改一下来满足需求、应付老板。这导致了相当一部分从业人能力平庸，被一些程序员同行概括认为前端技术难度有限，职位可有可无。 前端地位的尴尬返回来也导致学校教育上的漠视，在互联网技术快速发展的当下，迟迟不开设前端对应的专业课程。我在大二时就被当时拥有博士学位的数据结构老师点名批评：“就你天天研究的那些网页的东西，一点技术含量都没有，随便找个同学培训他一周 DreamWeaver 就能全学会！”微博微信上大学同学众多，堂主不会说谎话。 不过现在似乎有点改观，自从学校知道我这个挂科大户、反面典型来到淘宝工作后，我就变成了就业典型。甚至毕业前几个月院长还专门咨询过我，开设前端对应的课程，哪些书籍是适合作为教材的。能通过自己的就业对学院的教学改革产生一点点布道的作用，我现在还感到高兴和欣慰。 那么，前端的技术含量到底怎么样？是不是真的像其他人说的那样，企业不值得为其单独设立一个职位呢？ 【2. 企业中的前端】个人观点，其互联网业务仅作展示窗口作用的，可能确实不需要设立专业的前端职位。如企业展示类网站、政府网站等，其运营业务的核心渠道不基于互联网，其互联网产品更多承载的是品牌推广手段多样性的作用，其网站产品的开发完全可以通过外包来实现，顶多只需要设置1、2位运营编辑人员即可。 而对于那些核心营生基于互联网的企业而言，专业前端的职位就是必须的。因为前端作为一个职业存在的价值主要体现在：“叫专业的人干专业的事，解放并提升了产品方的生产力”。翻译成人话就是，前端解放了交互、解放了视觉、解放了开发，并用其专业技能提升了客户端的用户体验。 说解放了交互及视觉，是因为从此交互只专注于操作体验，视觉只聚焦于艺术呈现，而不用附带还要做切图切页面的事，且你叫交互、视觉去写要具备专业编程能力的 Javascript 语言他们也很难搞定。 说解放了开发是指开发可以将精力都投入在诸如底层系统架构、算法优化、数据处理等核心业务上，而不同再去写页面套页面，且你叫专业开发去捣鼓需要具备极强人文修养的 HTML 和 CSS，他们多半也会崩溃的。 说提升了客户端的用户体验，是因为，你找出一个能同时搞定HTML语义性、CSS兼容性、JS优异交互、整体性能经过优化、结构样式及脚本具备优异扩展性支持、且界面还原精确到1像素的交互、视觉或专业开发给我看看，有一个我们团队要一个！ 【3. 前端的工作内容及技术含量】作为前端开发工程师，我们中的绝大部分（极少部分的前端工程师的工作内容是面向底层库的开发，为其他前端提供更便捷的开发工具），在日常的开发实践中，确实鲜有要用到算法的情况。如此好似低端，却不意味着做好就容易。 相比字面意思理解性较差的F2E (Front End Engineer，前端开发工程师)，我们中绝大部分的工作性质更准确的形容应该是UIE（User InteractiveEngineer，用户界面开发工程师）。我们要处理的事务包括但不限于：产品界面的在浏览器端的展现、前后端数据的通信以及基于 DOM 操作的交互体验。 因前端编码手段过于灵活，质量参差的HTML、CSS和Javascript可能都可以满足当前的产品需求。可若一旦涉及可用性、扩展性、细节控、性能优和兼容性，质量不佳的代码劣势立现。如，对很多人最不重视的、认为最没技术含量的HTML：一个优异的HTML结构，且不论其本身就具备的高优雅性及可读性，更可以节省一大半的 DOM 操作；且具备良好的可扩展性，避免未来因需求变化而导致的大规模结构重构；更能避免绝大部分的CSS兼容性问题 —— 我就不提什么模块化复用性、搜索引擎优化和盲人阅读器的那些事了。 另外因前端职业成型晚，技术迭代快（且这种迭代属于技术累加式而非替换式，使得越往后入门的新人需学习的东西越多），产品兼容问题多（想做到 “write once, run anywhere” 是F2Er共同的梦），校园教育缺失，自学成本高、最佳实践积累少、职业思维模型需跨技术与人文等种种因素，都导致前端职业修养的养成成本更高，靠谱的人才稀少。 所以说，“糙活也能用，细活养成难”的现实一是阻碍了很多从业者的进步，二也造成了行业上认为前端“没难度级别低”的错觉。 但错觉终究是错觉，互联网的快速发展会帮助大家逐渐纠正这一认知。前端现在不论作为一个职业，还是其背后代指的一干技术与思维，都依然显得青稚，需要积淀与成熟。但请相信前端成熟的路不会更类似其他职业的开发——我会告诉你一个好的前端应该具备很强的人文气息么？人文这东西说不清道不明，但可以肯定它属于是感性的一类，正如HTML和CSS，看似简单，却绝非简单，一如文学创作，语境的形成不取决于语法，却依赖于开发者自身。 原文地址：http://www.osmn00.com/personal/244.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"好干净夜景","slug":"好干净夜景","date":"2015-03-02T17:05:18.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/24257/","link":"","permalink":"http://www.voyax.meposts/24257/","excerpt":"","text":"算来在深圳呆了也有一个多月，今天才发现夜景如此漂亮干净，想某日，必当骑车夜游深圳； 重庆的夜景很繁华可惜人气太重； 北京似乎从没有夜景一说，顶多算个光污染。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"布衣公子ppt系列合集＋《我的黄金十年》网盘下载","slug":"布衣公子ppt系列合集＋《我的黄金十年》网盘下载","date":"2015-03-01T14:10:05.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/30287/","link":"","permalink":"http://www.voyax.meposts/30287/","excerpt":"","text":"大二后一直参考布衣公子的ppt，简洁大方又不失炫酷，迄今个人最喜欢的ppt模版。 分享44个布衣公子的ppt： 百度网盘：http://pan.baidu.com/s/1jG9Wvoq 提取密码：3lv4 &nbsp;","categories":[{"name":"资料","slug":"资料","permalink":"http://www.voyax.me/categories/资料/"}],"tags":[{"name":"办公","slug":"办公","permalink":"http://www.voyax.me/tags/办公/"}]},{"title":"在你需要嘶吼的年纪","slug":"在你需要嘶吼的年纪","date":"2015-02-05T16:33:50.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/31494/","link":"","permalink":"http://www.voyax.meposts/31494/","excerpt":"","text":"有时候你必须承认，唯有在一个人处于时间的边缘，他才能感受到寂静时间的脉络，耳边回响起上课的铃声，心情像打了马赛克。许是到了岁末，人人都要缅怀吧，毕业季，我们总该感慨些什么。 现在越来越多的事开始让我意识到，这世上存在着很多看不见的外力和不可抗的因素。面对他们，作为个体的我们时常无能为力又渺小又孤独，接受这一事实很难，而要消化这个事实，并找到合适的态度和行动去应付，或许更难。然前路漫漫，人总该有所坚守。如果人的一生总该有一段时间高昂而激荡，那算上帕累托最优，就是在我们这个需要嘶吼的年纪了罢。 人啊，总是很奇怪。时而精明，时而糊涂；时而如芦苇般坚韧，时而像秋风少落叶般不堪一击。或许马克思的否定之否定确是真理，生活刀光剑影、纷纷扰扰，无休止的否定以及不可禁锢的成长。只是，在不可抗拒的客观规律下，人还有一种特性——“脾气”。 看过《月亮与六便士》的人必定对其中一句话不会陌生，“我们如今认为没有价值的艺术，或许是因为我们还没有欣赏它的能力。“大一到大四，每个学期都有一小段留给自己的对白，彼时稚气未脱的懵懂，在今日看来，竟是从未再有的弥足珍贵。 对于大学的总结，我不愿写得像批斗的检讨，自己痛苦，其他人也不会快乐，彼时的选择便是最好的了，我不是唯心主义，但我笃信，必然决定必然。如今再读鲁迅先生的话“希望是本无所谓有，无所谓无的，这正如地上的路，走的人多了，也便成了路。”又是另一种感受。 大学四年，我一直在寻找一种东西，无论“删繁就简三秋树”，亦是“洗尽铅华始见真”，可惜，似乎从未找到，每个学期期末总被不甘压得喘不过气。我告诉自己，要以轻快愉悦的姿态扎进这个光怪陆离的世界，正如量子纠缠描述的那样，要相信我们如今做的抉择都会是最好的状态。 大学三年我习惯于跟在别人后面，亦步亦趋，没有大起大落却也毫无生气；到了大四，一些东西改变了我的想法，我开始佩服那些有着自己想法并坚持的人，一个高中同学在沉默了近五年后，拿到了两份国外大学的offer，一个创业的同学依旧我行我素要完成他的事业。 一个同学说得好，我们疲于奔命于学历与工资，换句话说那是没有理想。理想是什么，好像很多年前被狗吃了？考名校、拿高薪、住别墅算理想吗——如果你认为那是你追求的东西，那就算吧。只是，拨开金钱奢侈，还有更多的东西值得我们毕生追寻。中国自古讲“仁、义、礼、智、信”，《礼记·大学》有云：“古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先修其身；欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。”人，要胸怀大志，也要坚信“天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能”。我相信做好本分，一切都会开花结果。 好运与噩梦呈正弦函数分布。我们仍可以在一次次的翻山越岭，不停的马失前蹄，又不断的整装重启后，看到山的那边瑰丽的海与天空。要戒掉肆无忌惮与有恃无恐，谨记知足感恩而非无度索求，习惯应该习惯的，恪守应该恪守的。像福柯说的那样，真实的生活就是游戏。该圆满地介入，并构筑那些存在。 我们早已死过千万次，我们还将出生千万次。 2015年1月11日于北航 &nbsp; 声明：1.这篇借用了lofter中某两位大家的不少话语。2.混杂无逻辑，不要在意我瞎扯……哦，还有，今天有人问了我个要命的问题，“你觉得你每天过得开心吗”，你说呢？","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"Fix 'jumping scrollbar' issue using only CSS—— Ayke van Laëthem","slug":"fix-jumping-scrollbar-issue-using-only-css-ayke-van-laethem","date":"2015-02-05T16:24:49.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/20324/","link":"","permalink":"http://www.voyax.meposts/20324/","excerpt":"","text":"Ayke van Laëthem – Fix ‘jumping scrollbar’ issue using only CSS When centering a page with CSS like margin: 0 auto;, there’s a small gotcha: the page will ‘jump’ a little on certain browsers when navigating between short and long pages. This is because the scrollbar gets hidden with short pages and is shown again with longer pages, which makes the page move a little horizontally.The classic fix for this is the following css: html { overflow-y: scroll; } &lt;/pre&gt; This makes the scrollbar always appear on the page, no matter whether it&#39;s required or not. When the scrollbar is not needed, the scrollbar will be grayed out but will stay the same width. The page doesn&#39;t jump, and usability is preserved. This is all nice, but what if we could have the cake and eat it too? In other words, what if we were able to only show the scrollbar when it&#39;s needed, and not have this jumping effect? I found a solution using100vw.100vwis the viewport width (including the scrollbar, and100%width (measured on the&lt;html&gt;element) is the width of the viewport excluding the scrollbar. Using a little CSScalc()trickery, we can give the page an (invisible) margin on the left that is exactly as wide as the scrollbar and disappears when the scrollbar disappears. That way, the margin on the right (the scrollbar) and on the left (created by us) is always the same. &lt;pre&gt;html { margin-left: calc(100vw - 100%); margin-right: 0; } &lt;/pre&gt; **Note**: calculating the scrollbar width this way [only works](http://lists.w3.org/Archives/Public/www-style/2013Jan/0616.html) when the&lt;html&gt;element hasoverflow: auto;. There&#39;s one small issue: when using [responsive web design](http://en.wikipedia.org/wiki/Responsive_web_design) (which you should!), it gets quite obvious that the margin at the left is bigger than at the right when the page is made smaller. This won&#39;t be an issue on mobile because scrollbars aren&#39;t normally shown there, but it just looks ugly on a desktop browser when the browser is resized. This can be fixed by only enabling this feature on wider viewports: &lt;pre&gt;@media screen and (min-width: 960px) { html { margin-left: calc(100vw - 100%); margin-right: 0; } } &lt;/pre&gt; The960pxis arbitrary: just use something that&#39;s somewhat bigger than your webpage (about150pxwill do). This trick works in most new browsers, and it degrades gracefully in older browsers (the page will just keep on jumping). Older browsers won&#39;t understand the rule so they&#39;ll just skip it. Supporting browsers include IE9+, Chrome and Firefox, but unfortunately Opera (Classic) and Safari 7 don&#39;t support it. I think Safari doesn&#39;t work due to a WebKit bug in handlingcalc()combined with the new viewport units (vw,vh,vminandvmax). I don&#39;t know about Opera Classic, but newer Opera versions based on the Chromium source code should work as this trick works just fine in Chrome. * * * This is my first post on this blog. I hope it will be useful for someone. At the same time, this post is a proof-of-concept that the blog actually works, as I wrote the blogging engine myself. * * * ## Update Ater being picked up by [CSS-Tricks](http://css-tricks.com/), I burned through about 1GB of bandwidth. As the biggest part of the page is the ±60kb icon in the top (HTML and CSS is just a few kb each), I guess that are about 15000 unique visitors (!). I&#39;m new to blogging, and suddenly having so many pageviews is… very surprising. Anyway, I got a few replies to this post. I discovered them as external links in Google Webmaster Tools. I did not have an &quot;[about me](http://aykevl.nl/about)&quot; page back then and I still haven&#39;t got [pingbacks](http://en.wikipedia.org/wiki/Pingback) or statistics of any form implemented, so GWT is the only way I can find out about links to my site. First of all, [Mark Senff](http://www.marksenff.com/front-end/even-more-elegant-fix-jumping-scrollbar-issue/) investigated it and provided an alternative solution: &lt;pre&gt;html { width:100vw; overflow-x:hidden; }This has the side-effects that it will hide the right part of the page as the scrollbar hides that part, and it will disable horizontal scrolling. So I personally would not use it.My scrollbar trick is only intended for centered content, something that may not have been clear. The example he gives includes a header that takes up the full width of the browser screen and that is mostly left-aligned. Of course, such a header wouldn’t jump a lot. The text beneath, in comparison, would be well suited for it, and I found out the trick can be applied to a part of the page just fine. I’ve put an ugly example of that up at Codepen.io.Some other mentions on the web include: Edwin Smith mentioned it on his blog on Smithy.com. Gavin Elster made a live (and good-looking) example on Codepen.io. I forked that one to give the example above, but my version is very ugly in comparison :)Thank you all! *原文链接：http://aykevl.nl/2014/09/fix-jumping-scrollbar&nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.voyax.me/tags/CSS/"}]},{"title":"流浪的卡农","slug":"流浪的卡农","date":"2015-02-01T16:24:57.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/57868/","link":"","permalink":"http://www.voyax.meposts/57868/","excerpt":"","text":"[caption id=”attachment_860” align=”alignnone” width=”510”] 流浪的卡农[/caption] 关掉这个城市的灯 借着笔记本熟悉的光亮 敲打着冰冷的键盘 耳边只有沉静平凡的卡农 青春，翘首。一世不过，烟花易冷，人事易分 今天我想说的话，就在这里吧。如果困了，就去睡觉吧，酒愈久弥香；思绪，说出来与埋在心中自有各自风味。 2015年1月18日来到深圳，如今恰好半月。离开一个陌生的城市又来到另一个更加陌生的地方。 一个朋友说：“年轻就是折腾，能跟随自己的想法是多么有意义的坚持。”我只能回答，“是这样。” 记得离开北京的前一天，大灰狼、老班还有一个老乡陪我一起度过了一个下午和晚上，很是感动与欢喜，哦，还有重庆我最好的兄弟给我打电话，老爸早上5点给我打电话担心我睡过…… 周末，一个人在深圳，独享这两室一厅，却说不出的落寞。 有时候想啊，我真的是个混蛋；那天老班说得对，相同的条件下，她会比我更快乐；我所追求的是否确是我想要的，在北京呆了四年，家人在重庆，最好的朋友也在重庆。然而，我却推掉了北京的offer，见狡辩这重庆信息产业不发达，直接来到了深圳。 年轻的时候，是该，去漂去拼，只是是不是我真的太过固执，很多时候都很明确的知道有一条康庄大道，但我往往就选择和自己作对。 很怕长大后就没有了激情，也怕失去童心。我现在给自己评价还是一个躁坯子（重庆方言） 今天就到这吧，Come on! 谨记谦虚，用心做事，微笑感恩:)&nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"JS获取屏幕信息方法汇总","slug":"js获取屏幕信息方法汇总","date":"2015-01-23T09:03:32.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/2636/","link":"","permalink":"http://www.voyax.meposts/2636/","excerpt":"","text":"function getInfo(){ var s = “”; s += “ 网页可见区域宽：”+ document.body.clientWidth+”\\n”; s += “ 网页可见区域高：”+ document.body.clientHeight+”\\n”; s += “ 网页可见区域宽：”+ document.body.offsetWidth + “ (包括边线和滚动条的宽)”+”\\n”; s += “ 网页可见区域高：”+ document.body.offsetHeight + “ (包括边线的宽)”+”\\n”; s += “ 网页正文全文宽：”+ document.body.scrollWidth+”\\n”; s += “ 网页正文全文高：”+ document.body.scrollHeight+”\\n”; s += “ 网页被卷去的高(ff)：”+ document.body.scrollTop+”\\n”; s += “ 网页被卷去的高(ie)：”+ document.documentElement.scrollTop+”\\n”; s += “ 网页被卷去的左：”+ document.body.scrollLeft+”\\n”; s += “ 网页正文部分上：”+ window.screenTop+”\\n”; s += “ 网页正文部分左：”+ window.screenLeft+”\\n”; s += “ 屏幕分辨率的高：”+ window.screen.height+”\\n”; s += “ 屏幕分辨率的宽：”+ window.screen.width+”\\n”; s += “ 屏幕可用工作区高度：”+ window.screen.availHeight+”\\n”; s += “ 屏幕可用工作区宽度：”+ window.screen.availWidth+”\\n”; s += “ 你的屏幕设置是 “+ window.screen.colorDepth +” 位彩色”+”\\n”; s += “ 你的屏幕设置 “+ window.screen.deviceXDPI +” 像素/英寸”+”\\n”; alert (s); } getInfo(); [caption id=”attachment_836” align=”alignnone” width=”609”] 页面信息详解[/caption]","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.voyax.me/tags/JavaScript/"}]},{"title":"【转】Selenium WebDriver操作说明","slug":"【转】selenium-webdriver操作说明","date":"2015-01-19T03:57:09.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/25893/","link":"","permalink":"http://www.voyax.meposts/25893/","excerpt":"","text":"1.打开一个测试浏览器对浏览器进行操作首先需要打开一个浏览器，接下来才能对浏览器进行操作。 Java代码 import java.io.File; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxBinary; importorg.openqa.selenium.firefox.FirefoxDriver; importorg.openqa.selenium.ie.InternetExplorerDriver; public class OpenBrowsers { public static void main(String[] args) { //打开默认路径的firefox WebDriver diver = new FirefoxDriver(); //打开指定路径的firefox,方法1 System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\MozillaFirefox\\\\firefox.exe\"); WebDriver dr = new FirefoxDriver(); //打开指定路径的firefox,方法2 File pathToFirefoxBinary = newFile(\"D:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\"); FirefoxBinary firefoxbin = newFirefoxBinary(pathToFirefoxBinary); WebDriver driver1 = newFirefoxDriver(firefoxbin,null); //打开ie WebDriver ie_driver = new InternetExplorerDriver(); //打开chrome System.setProperty(\"webdriver.chrome.driver\",\"D:\\\\chromedriver.exe\"); System.setProperty(\"webdriver.chrome.bin\", \"C:\\\\Documents and Settings\\\\gongjf\\\\Local Settings\" +\"\\\\ApplicationData\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\"); } } 2.打开一个具体的url打开一个浏览器后，我们需要跳转到特定的url下，看下面代码：Java代码 import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class OpenUrl { public static void main(String []args){ Stringurl = \"http://www.51.com\"; WebDriverdriver = new FirefoxDriver(); //用get方法 driver.get(url); //用navigate方法，然后再调用to方法 driver.navigate().to(url); } } 3.如何关闭浏览器测试完成后，需要关闭浏览器 Java代码 import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class CloseBrowser { public static void main(String []args){ Stringurl = \"http://www.51.com\"; WebDriverdriver = new FirefoxDriver(); driver.get(url); //用quit方法 driver.quit(); //用close方法 driver.close(); } } 4.如何返回当前页面的url和title有时候我们需要返回当前页面的url或者title做一些验证性的操作等。代码如下：Java代码 import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class GetUrlAndTitle { public static void main(String []args){ Stringurl = \"http://www.google.com\"; WebDriverdriver = new FirefoxDriver(); driver.get(url); //得到title Stringtitle = driver.getTitle(); //得到当前页面url StringcurrentUrl = driver.getCurrentUrl(); //输出title和currenturl System.out.println(title+\"\\n\"+currentUrl); } } 5.其他方法getWindowHandle() 返回当前的浏览器的窗口句柄getWindowHandles() 返回当前的浏览器的所有窗口句柄getPageSource() 返回当前页面的源码 从上面代码可以看出操作浏览器的主要方法都来自org.openqa.selenium.WebDriver这个接口中。看了一下源代码这些方法都是在org.openqa.selenium.remote.RemoteWebDriver这个类中实现的，然后不同浏览的driver类继承RemoteWebDriver。 C 定位页面元素selenium-webdriver提供了强大的元素定位方法，支持以下三种方法。单个对象的定位方法多个对象的定位方法层级定位定位单个元素在定位单个元素时,selenium-webdriver提示了如下一些方法对元素进行定位。 By.className(className)) By.cssSelector(selector) By.id(id) By.linkText(linkText) By.name(name) By.partialLinkText(linkText) By.tagName(name) By.xpath(xpathExpression) 注意：selenium-webdriver通过findElement()\\findElements()等find方法调用”By”对象来定位 和查询元素。By类只是提供查询的方式进行分类。findElement返回一个元素对象否则抛出异常，findElements返回符合条件的元素 List，如果不存在符合条件的就返回一个空的list。 1.使用className进行定位当所定位的元素具有class属性的时候我们可以通过classname来定位该元素。下面的例子定位了51.com首页上class为”username”的li。Java代码 import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.By; public class ByClassName { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); driver.get(\"http://www.51.com\"); WebElement element =driver.findElement(By.className(\"username\")); System.out.println(element.getTagName()); } } 输出结果： Java代码 Li ### 2.使用id属性定位 51.com首页的帐号输入框的html代码如下： Java代码 在下面的例子中用id定位这个输入框，并输出其title,借此也可以验证代码是否工作正常。 Java代码 import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxDriver; public class ByUserId { /** * @param args */ public static void main(String[] args) { //TODO Auto-generated method stub WebDriverdr = new FirefoxDriver(); dr.get(\"http://www.51.com\"); WebElementelement = dr.findElement(By.id(\"passport_51_user\")); System.out.println(element.getAttribute(\"title\")); } } 输出结果： Java代码 用户名/彩虹号/邮箱 ### 3.使用name属性定位 51.com首页的帐号输入框的html代码如下： Java代码 使用name定位 Java代码 import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxDriver; public class ByUserId { /** * @param args */ public static void main(String[] args) { //TODO Auto-generated method stub WebDriverdr = new FirefoxDriver(); dr.get(\"http://www.51.com\"); WebElemente = dr.findElement(By.name(\"passport_51_user\")); System.out.println(element.getAttribute(\"title\")); } } 输出结果： Java代码 用户名/彩虹号/邮箱 ### 4.使用css属性定位 51.com首页的帐号输入框的html代码如下： Java代码 使用css定位 Java代码 WebElement e1 =dr.findElement(By.cssSelector(\"#passport_51_user\")); ### 5.使用 XPATH定位 51.com首页的帐号输入框的html代码如下： Java代码 通过xpath查找： Java代码 WebElement element=driver.findElement(By.xpath(\"//input[@id=' passport_51_user ']\")); ### 6.使用其他方式定位 在定位link元素的时候，可以使用link和link_text属性； 另外还可以使用tag_name属性定位任意元素； ### 7.定位多个元素 上面提到findElements()方法可以返回一个符合条件的元素List组。看下面例子。 Java代码 import java.io.File; import java.util.List; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxBinary; import org.openqa.selenium.firefox.FirefoxDriver; public class FindElementsStudy { /** * @author gongjf */ public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); driver.get(\"http://www.51.com\"); //定位到所有标签的元素，然后输出他们的id Listelement = driver.findElements(By.tagName(\"input\")); for(WebElement e : element){ System.out.println(e.getAttribute(\"id\")); } driver.quit(); } } 输出结果： Java代码 passport_cookie_login gourl passport_login_from passport_51_user passport_51_password passport_qq_login_2 btn_reg passport_51_ishidden passport_auto_login 上面的代码返回页面上所有input对象 ### 8.层级定位 层级定位的思想是先定位父元素，然后再从父元素中精确定位出其我们需要选取的子元素。 层级定位一般的应用场景是无法直接定位到需要选取的元素，但是其父元素比较容易定位，通过定位父元素再遍历其子元素选择需要的目标元素，或者需要定位某个元素下所有的子元素。 下面的代码演示了如何使用层级定位class为\"login\"的div，然后再取得它下面的所有label，并打印出他们的文本 Java代码 import java.io.File; importjava.util.List; importorg.openqa.selenium.By; importorg.openqa.selenium.WebDriver; importorg.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxBinary; importorg.openqa.selenium.firefox.FirefoxDriver; publicclass LayerLocator { /** * @author gongjf */ public static void main(String[] args){ WebDriver driver = new FirefoxDriver(); driver.get(\"http://www.51.com\"); //定位class为\"login\"的div，然后再取得它下面的所有label，并打印出他们的值 WebElement element =driver.findElement(By.className(\"login\")); List el =element.findElements(By.tagName(\"label\")); for(WebElement e : el) System.out.println(e.getText()); } } 输出结果： Java代码 帐号： 密码： 隐身 ## >如何对页面元素进行操作 找到页面元素后，怎样对页面进行操作呢？我们可以根据不同的类型的元素来进行一一说明。 ### 1\\. 输入框（text field or textarea） 找到输入框元素： WebElement element =driver.findElement(By.id(\"passwd-id\")); 在输入框中输入内容： element.sendKeys(“test”); 将输入框清空： element.clear(); 获取输入框的文本内容： element.getText(); ### 2\\. 下拉选择框(Select) 找到下拉选择框的元素： Select select = newSelect(driver.findElement(By.id(\"select\"))); 选择对应的选择项： select.selectByVisibleText(“mediaAgencyA”); 或 select.selectByValue(“MA_ID_001”); 不选择对应的选择项： select.deselectAll(); select.deselectByValue(“MA_ID_001”); select.deselectByVisibleText(“mediaAgencyA”); 或者获取选择项的值： select.getAllSelectedOptions(); select.getFirstSelectedOption(); 对下拉框进行操作时首先要定位到这个下拉框，new 一个Selcet对象，然后对它进行操作 ### 3\\. 单选项(Radio Button) 找到单选框元素： WebElement bookMode =driver.findElement(By.id(\"BookMode\")); 选择某个单选项： bookMode.click(); 清空某个单选项： bookMode.clear(); 判断某个单选项是否已经被选择： bookMode.isSelected(); ### 4\\. 多选项(checkbox) 多选项的操作和单选的差不多： WebElement checkbox=driver.findElement(By.id(\"myCheckbox.\")); checkbox.click(); checkbox.clear(); checkbox.isSelected(); checkbox.isEnabled(); ### 5\\. 按钮(button) 找到按钮元素： WebElement saveButton =driver.findElement(By.id(\"save\")); 点击按钮： saveButton.click(); 判断按钮是否enable: saveButton.isEnabled (); ### 6\\. 左右选择框 也就是左边是可供选择项，选择后移动到右边的框中，反之亦然。例如： Select lang = new Select(driver.findElement(By.id(\"languages\"))); lang.selectByVisibleText(“English”); WebElement addLanguage=driver.findElement(By.id(\"addButton\")); addLanguage.click(); ### 7\\. 弹出对话框(Popup dialogs) Alert alert = driver.switchTo().alert(); alert.accept(); alert.dismiss(); alert.getText(); 后面有具体的例子解释~ ### 8\\. 表单(Form) Form中的元素的操作和其它的元素操作一样，对元素操作完成后对表单的提交可以： WebElement approve =driver.findElement(By.id(\"approve\")); approve.click(); 或 approve.submit();//只适合于表单的提交 ### 9\\. 上传文件 (Upload File) 上传文件的元素操作： WebElement adFileUpload = driver.findElement(By.id(\"WAP-upload\")); String filePath =\"C:\\test\\\\uploadfile\\\\media_ads\\\\test.jpg\"; adFileUpload.sendKeys(filePath); ### 10.拖拉(Drag andDrop) WebElement element=driver.findElement(By.name(\"source\")); WebElement target = driver.findElement(By.name(\"target\")); (new Actions(driver)).dragAndDrop(element,target).perform(); ### 11.导航 (Navigationand History) 打开一个新的页面： driver.navigate().to(\"http://www.example.com\"); 通过历史导航返回原页面： driver.navigate().forward(); driver.navigate().back(); E iframe的处理有时候我们在定位一个页面元素的时候发现一直定位不了，反复检查自己写的定位器没有任何问题，代码也没有任何问题。这时你就要看一下这个页面元素是否在一个iframe中，这可能就是找不到的原因之一。如果你在一个default content中查找一个在iframe中的元素，那肯定是找不到的。反之你在一个iframe中查找另一个iframe元素或default content中的元素，那必然也定位不到。selenium webdriver中提供了进入一个iframe的方法： WebDriverorg.openqa.selenium.WebDriver.TargetLocator.frame(String nameOrId) 也提供了一个返回default content的方法： WebDriver org.openqa.selenium.WebDriver.TargetLocator.defaultContent() 这样使我们面对iframe时可以轻松应对。 以下面的html代码为例，我们看一下处现iframe。 Html代码 main.html FrameTest this is a div! frame.html this is a frame! this is a div，too! input: Java代码 import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class FameStudy { public static void main(String[] args) { WebDriverdr = new FirefoxDriver(); Stringurl = \"\\\\Your\\\\Path\\\\to\\\\main.html\"; dr.get(url); //在defaultcontent定位id=\"id1\"的div dr.findElement(By.id(\"id1\")); //此时，没有进入到id=\"frame\"的frame中时，以下两句会报错 dr.findElement(By.id(\"div1\"));//报错 dr.findElement(By.id(\"input1\"));//报错 //进入id=\"frame\"的frame中，定位id=\"div1\"的div和id=\"input1\"的输入框。 dr.switchTo().frame(\"frame\"); dr.findElement(By.id(\"div1\")); dr.findElement(By.id(\"input1\")); //此时，没有跳出frame，如果定位defaultcontent中的元素也会报错。 dr.findElement(By.id(\"id1\"));//报错 //跳出frame,进入defaultcontent;重新定位id=\"id1\"的div dr.switchTo().defaultContent(); dr.findElement(By.id(\"id1\")); } } 小结：switch_to方法会new1个TargetLocator对象，使用该对象的frame方法可以将当前识别的”主体”移动到需要定位的frame上去。 F 如何得到弹出窗口在selenium 1.X里面得到弹出窗口是一件比较麻烦的事，特别是新开窗口没有id、name的时候。在selenium webdriver中得到新开窗口相对简单的多，它无关新开窗口的id、name等属性。以下面的html为例： Html代码 test.html Test Popup Window [Let's go!](http://www.51.com/) 下面的代码演示了如何去得到弹出的新窗口 Java代码 import java.util.Iterator; import java.util.Set; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class PopupWindowTest { /** * @author gongjf */ public static void main(String[] args) { System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); Stringurl =\"\\\\Your\\\\Path\\\\to\\\\main.html\"; dr.get(url); dr.findElement(By.id(\"51\")).click(); //得到当前窗口的句柄 StringcurrentWindow = dr.getWindowHandle(); //得到所有窗口的句柄 Sethandles = dr.getWindowHandles(); Iteratorit = handles.iterator(); while(it.hasNext()){ if(currentWindow== it.next()) continue; dr.switchTo().window(it.next()); } } } 小结：捕获或者说定位弹出窗口的关键在于获得弹出窗口的句柄。（在上面的代码里，使用windowhandle方法来获取当前浏览器窗口的句柄，使用了windowhandles方法获取所有弹出的浏览器窗口的句柄，然后通过排除当前句柄的方法来得到新开窗口的句柄。在获取新弹出窗口的句柄后，使用switchto.window(newwindow_handle)方法，将新窗口的句柄作为参数传入既可捕获到新窗口了。如果想回到以前的窗口定位元素，那么再调用1次switchto.window方法，传入之前窗口的句柄既可达到目的。 G 如何处理alert、confirm、prompt对话框alert、confirm、prompt这样的js对话框在selenium1.X时代也是难啃的骨头，常常要用autoit来帮助处理。试用了一下selenium webdriver中处理这些对话框十分方便简洁 Html代码 Dialogs.html Alert 以上html代码在页面上显示了三个按钮，点击他们分别弹出alert、confirm、prompt对话框。如果在prompt对话框中输入文字点击确定之后，将会刷新页面，显示出这些文字。 selenium webdriver 处理这些弹层的代码如下： Java代码 import org.openqa.selenium.Alert; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class DialogsStudy { /** * @author gongjf */ public static void main(String[] args) { //TODO Auto-generated method stub System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); Stringurl = \"file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Dialogs.html\";//\"/Your/Path/to/main.html\" dr.get(url); //点击第一个按钮，输出对话框上面的文字，然后叉掉 dr.findElement(By.id(\"alert\")).click(); Alertalert = dr.switchTo().alert(); Stringtext = alert.getText(); System.out.println(text); alert.dismiss(); //点击第二个按钮，输出对话框上面的文字，然后点击确认 dr.findElement(By.id(\"confirm\")).click(); Alertconfirm = dr.switchTo().alert(); Stringtext1 = confirm.getText(); System.out.println(text1); confirm.accept(); //点击第三个按钮，输入你的名字，然后点击确认，最后 dr.findElement(By.id(\"prompt\")).click(); Alertprompt = dr.switchTo().alert(); Stringtext2 = prompt.getText(); System.out.println(text2); prompt.sendKeys(\"jarvi\"); prompt.accept(); } } 小结：从以上代码可以看出dr.switchTo().alert();这句可以得到alert\\confirm\\prompt对话框的对象，然后运用其方法对它进行操作。对话框操作的主要方法有： getText() 得到它的文本值accept() 相当于点击它的”确认”dismiss() 相当于点击”取消”或者叉掉对话框sendKeys() 输入值，这个alert\\confirm没有对话框就不能用了，不然会报错。 H 如何操作cookiesWeb 测试中我们经常会接触到Cookies，一个Cookies主要属性有”所在域、name、value、有效日期和路径”,下面来讲一下怎么操作Cookies Java代码 import java.util.Set; import org.openqa.selenium.Cookie; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class CookiesStudy { /** * @author gongjf */ publicstatic void main(String[] args) { //TODO Auto-generated method stub System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); dr.get(\"http://www.51.com\"); //增加一个name =\"name\",value=\"value\"的cookie Cookiecookie = new Cookie(\"name\", \"value\"); dr.manage().addCookie(cookie); //得到当前页面下所有的cookies，并且输出它们的所在域、name、value、有效日期和路径 Setcookies = dr.manage().getCookies(); System.out.println(String.format(\"Domain-> name -> value -> expiry -> path\")); for(Cookiec : cookies) System.out.println(String.format(\"%s-> %s -> %s -> %s -> %s\", c.getDomain(),c.getName(), c.getValue(),c.getExpiry(),c.getPath())); //删除cookie有三种方法 //第一种通过cookie的name dr.manage().deleteCookieNamed(\"CookieName\"); //第二种通过Cookie对象 dr.manage().deleteCookie(cookie); //第三种全部删除 dr.manage().deleteAllCookies(); } 小结：上面的代码首先在页面中增加了一个cookie,然后遍历页面的所有cookies，并输出他们的主要属性。最后就是三种删除cookie的方法。 I 如何等待页面元素加载完成web的自动化测试中，我们经常会遇到这样一种情况：当我们的程序执行时需要页面某个元素，而此时这个元素还未加载完成，这时我们的程序就会报错。怎么办？等待。等待元素出现后再进行对这个元素的操作。在selenium-webdriver中我们用两种方式进行等待：明确的等待和隐性的等待。 明确的等待 明确的等待是指在代码进行下一步操作之前等待某一个条件的发生。最不好的情况是使用Thread.sleep()去设置一段确认的时间去等待。但为什么说最不好呢？因为一个元素的加载时间有长有短，你在设置sleep的时间之前要自己把握长短，太短容易超时，太长浪费时间。selenium webdriver提供了一些方法帮助我们等待正好需要等待的时间。利用WebDriverWait类和ExpectedCondition接口就能实现这一点。 下面的html代码实现了这样的一种效果：点击click按钮5秒钟后，页面上会出现一个红色的div块。我们需要写一段自动化脚本去捕获这个出现的div，然后高亮之。 Html代码 Wait.html Set Timeout .red_box {background-color: red; width = 20%; height: 100px; border:none;} function show_div(){ setTimeout(\"create_div()\", 5000); } function create_div(){ d =document.createElement('div'); d.className =\"red_box\"; document.body.appendChild(d); } click 下面的代码实现了高亮动态生成的div块的功能： Java代码 import org.openqa.selenium.By; importorg.openqa.selenium.JavascriptExecutor; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxDriver; importorg.openqa.selenium.support.ui.ExpectedCondition; importorg.openqa.selenium.support.ui.WebDriverWait; public class WaitForSomthing { /** * @author gongjf */ public static void main(String[] args) { //TODO Auto-generated method stub System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); Stringurl = \"file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Wait.html\";//\"/Your/Path/to/Wait.html\" dr.get(url); WebDriverWaitwait = new WebDriverWait(dr,10); wait.until(newExpectedCondition(){ @Override publicWebElement apply(WebDriver d) { returnd.findElement(By.id(\"b\")); }}).click(); WebElementelement = dr.findElement(By.cssSelector(\".red_box\")); ((JavascriptExecutor)dr).executeScript(\"arguments[0].style.border= \\\"5px solid yellow\\\"\",element); } } 上面的代码WebDriverWait类的构造方法接受了一个WebDriver对象和一个等待最长时间（10秒）。然后调用until方法，其中重写了 ExpectedCondition接口中的apply方法，让其返回一个WebElement,即加载完成的元素，然后点击。默认情况下，WebDriverWait每500毫秒调用一次ExpectedCondition，直到有成功的返回，当然如果超过设定的值还没有成功的返回，将抛出异常。 隐性等待隐性等待是指当要查找元素，而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。上面的代码就变成了这样： Java代码 import java.util.concurrent.TimeUnit; import org.openqa.selenium.By; importorg.openqa.selenium.JavascriptExecutor; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; importorg.openqa.selenium.firefox.FirefoxDriver; importorg.openqa.selenium.support.ui.ExpectedCondition; importorg.openqa.selenium.support.ui.WebDriverWait; public class WaitForSomthing { /** * @author gongjf */ public static void main(String[] args) { //TODO Auto-generated method stub System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); //设置10秒 dr.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS); Stringurl = \"file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Wait.html\";//\"/Your/Path/to/Wait.html\" dr.get(url); //注释掉原来的 /*WebDriverWaitwait = new WebDriverWait(dr,10); wait.until(newExpectedCondition(){ @Override publicWebElement apply(WebDriver d) { returnd.findElement(By.id(\"b\")); }}).click();*/ dr.findElement(By.id(\"b\")).click(); WebElementelement = dr.findElement(By.cssSelector(\".red_box\")); ((JavascriptExecutor)dr).executeScript(\"arguments[0].style.border= \\\"5px solid yellow\\\"\",element); } } 小结： 两种方法任选其一 ## J 如何利用selenium-webdriver截图 在自动化测试中常常会用到截图功能。可以截取页面全图，不管页面有多长。 下面的代码演示了如何使用webdriver进行截图： Java代码 import java.io.File; import java.io.IOException; import org.apache.commons.io.FileUtils; import org.openqa.selenium.OutputType; import org.openqa.selenium.TakesScreenshot; import org.openqa.selenium.WebDriver; importorg.openqa.selenium.firefox.FirefoxDriver; public class ShotScreen { /** * @author gongjf * @throws IOException * @throws InterruptedException */ public static void main(String[] args) throws IOException, InterruptedException { System.setProperty(\"webdriver.firefox.bin\",\"D:\\\\ProgramFiles\\\\Mozilla Firefox\\\\firefox.exe\"); WebDriverdr = new FirefoxDriver(); dr.get(\"http://www.51.com\"); //这里等待页面加载完成 Thread.sleep(5000); //下面代码是得到截图并保存在D盘下 FilescreenShotFile = ((TakesScreenshot)dr).getScreenshotAs(OutputType.FILE); FileUtils.copyFile(screenShotFile,new File(\"D:/test.png\")); } } K 封装与重用WebDriver对页面的操作，需要找到一个WebElement，然后再对其进行操作，比较繁琐： // Find the text inputelement by itsname WebElement element =driver.findElement(By.name(\"q\")); // Enter something to search for element.sendKeys(\"Cheese!\"); 我们可以考虑对这些基本的操作进行一个封装，简化操作。比如，封装代码： protected void sendKeys(Byby, String value){ driver.findElement(by).sendKeys(value); } 那么，在测试用例可以这样简化调用： sendKeys(By.name(\"q\"),”Cheese!”); 看，这就简洁多了。 类似的封装还有： package com.drutt.mm.end2end.actions; import java.util.List; import java.util.NoSuchElementException; import java.util.concurrent.TimeUnit; import org.openqa.selenium.By; import org.openqa.selenium.WebElement; importorg.openqa.selenium.remote.RemoteWebDriver; importorg.openqa.selenium.support.ui.WebDriverWait; importcom.drutt.mm.end2end.data.TestConstant; public class WebDriverAction { //protected WebDriverdriver; protectedRemoteWebDriverdriver; protectedWebDriverWaitdriverWait; protected boolean isWebElementExist(Byselector) { try { driver.findElement(selector); return true; } catch(NoSuchElementException e) { return false; } } protected String getWebText(By by) { try { return driver.findElement(by).getText(); } catch (NoSuchElementException e) { return \"Textnot existed!\"; } } protected void clickElementContainingText(By by, String text){ ListelementList = driver.findElements(by); for(WebElement e:elementList){ if(e.getText().contains(text)){ e.click(); break; } } } protected String getLinkUrlContainingText(By by, String text){ ListsubscribeButton = driver.findElements(by); String url = null; for(WebElement e:subscribeButton){ if(e.getText().contains(text)){ url =e.getAttribute(\"href\"); break; } } return url; } protected void click(Byby){ driver.findElement(by).click(); driver.manage().timeouts().implicitlyWait(TestConstant.WAIT_ELEMENT_TO_LOAD,TimeUnit.SECONDS); } protected String getLinkUrl(By by){ return driver.findElement(by).getAttribute(\"href\"); } protected void sendKeys(Byby, String value){ driver.findElement(by).sendKeys(value); } 小结：按照上面的例子你可以对各个方法进行封装，使自己的代码更加简洁！ L 在selenium2.0中使用selenium1.0的APISelenium2.0中使用WeDriver API对页面进行操作，它最大的优点是不需要安装一个selenium server就可以运行，但是对页面进行操作不如selenium1.0的Selenium RC API那么方便。Selenium2.0提供了使用Selenium RC API的方法：// 我用火狐浏览器作为例子 WebDriver driver = newFirefoxDriver(); String baseUrl=\"http://www.google.com\"; Selenium selenium = newWebDriverBackedSelenium(driver, baseUrl); // 执行selenium命令 selenium.open(\"http://www.google.com\"); selenium.type(\"name=q\",\"cheese\"); selenium.click(\"name=btnG\"); WebDriver driverInstance = ((WebDriverBackedSelenium)selenium).getUnderlyingWebDriver(); selenium.stop(); 我分别使用WebDriver API和SeleniumRC API写了一个Login的脚本，很明显，后者的操作更加简单明了。 WebDriver API写的Login脚本： public void login() { driver.switchTo().defaultContent(); driver.switchTo().frame(\"mainFrame\"); WebElement eUsername= waitFindElement(By.id(\"username\")); eUsername.sendKeys(manager@ericsson.com); WebElement ePassword= waitFindElement(By.id(\"password\")); ePassword.sendKeys(manager); WebElementeLoginButton = waitFindElement(By.id(\"loginButton\")); eLoginButton.click(); } SeleniumRC API写的Login脚本： public void login() { selenium.selectFrame(\"relative=top\"); selenium.selectFrame(\"mainFrame\"); selenium.type(\"username\",\"manager@ericsson.com\"); selenium.type(\"password\",\"manager\"); selenium.click(\"loginButton\"); }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"webdriver","slug":"webdriver","permalink":"http://www.voyax.me/tags/webdriver/"}]},{"title":" JAVA中List、Map、Set","slug":"java中list、map、set","date":"2015-01-14T08:00:20.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/61148/","link":"","permalink":"http://www.voyax.meposts/61148/","excerpt":"","text":"Collection接口Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下： Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) { Object obj = it.next(); // 得到下一个元素 } 由Collection接口派生的两个接口是List和Set。 ## List接口 List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 和下面要提到的Set不同，List允许有相同的元素。 除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 ### LinkedList类 LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...)); ArrayList类ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack 类Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Set接口Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有 e1.equals(e2)=false，Set最多有一个null元素。很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致 Object.equals(Object)=true将导致一些问题。 Map接口请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable();numbers.put(“one”, new Integer(1));numbers.put(“two”, new Integer(2));numbers.put(“three”, new Integer(3));要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”);System.out.println(“two = ” + n);由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即 obj1.equals(obj2)=true则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。Hashtable是同步的。 HashMap类HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。 WeakHashMap类WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 总结如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"MongoDB权威指南第二版（英文版）","slug":"mongodb权威指南第二版（英文版）","date":"2015-01-10T05:25:02.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/39305/","link":"","permalink":"http://www.voyax.meposts/39305/","excerpt":"","text":"一周之内希望能基本做完毕设，看书写代码！","categories":[{"name":"资源","slug":"资源","permalink":"http://www.voyax.me/categories/资源/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.voyax.me/tags/MongoDB/"}]},{"title":"小端序和大端序","slug":"小端序和大端序","date":"2015-01-10T04:59:23.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/22754/","link":"","permalink":"http://www.voyax.meposts/22754/","excerpt":"","text":"大端序（big-endian）：低地址存放高位小端序（little-endian）：地地址存放低位大小端序跟硬件的体系结构有关，所有x86系列的pc机都是小端序，跟操作系统无关大小端序判断： #include using namespace std; int main(int argc, char **argv) { short s = 0x0102; if((*(unsigned char*)&s) == 2) cout<","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"操作系统实验实现shell","slug":"操作系统实验实现shell","date":"2015-01-05T07:54:16.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/54176/","link":"","permalink":"http://www.voyax.meposts/54176/","excerpt":"","text":"这是大三的时候的一个实验，实现一个shell在大二的时候写过一个，当时没有学过编译和操作系统，很多东西并没有明白，这个版本是用lex进行词法分析，用yacc进行的语法分析，实现了一个简单的shell，当时因为急着完成任务，语法分析做得并不好，扩展起来并不方便，还有太多需要修改的地方。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"Linux编译内核及添加系统调用","slug":"linux编译内核及添加系统调用","date":"2015-01-05T07:35:22.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/32903/","link":"","permalink":"http://www.voyax.meposts/32903/","excerpt":"","text":"Linux编译内核及添加系统调用的具体实现步骤。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.voyax.me/tags/Linux/"}]},{"title":"无题","slug":"786","date":"2014-12-09T15:54:37.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/58857/","link":"","permalink":"http://www.voyax.meposts/58857/","excerpt":"","text":"看到Yimlow拿到Durham的Offer，亦喜亦惊，毫无征兆。很为她高兴，初中三年她都是我的目标，可惜高中不知为何，高中我和她当了一学期同班同学后她降到平行班，我还呆在那365天基本不说话的实验班。有次在门口见到她，想问她到底怎么了，却是终究忍住，不为其他，只是觉得她应该更好。好像自从一起回了趟初中的学校，就再没了联系，高考完了，才听说她去了武汉。现在，其实挺好，这个让我努力超越了三年的老同学还是如此强大，我为有这样一个同学而欣喜。花了10分钟看完了她的状态，依旧乐观满当当的正能量，当年座位离得太近，课间边做题边听她哼歌何等煎熬，如今却再也没有这样的课间。加油吧！不会在意我复制段吧“Anyway 选择一条不曾踏过的路 拥抱太过炽热的梦想 一步一步走来 能做的只有坚持 有家人的支持再苦再累也值得 努力为爱自己的人带来更好的生活 我相信做好本分 一切都会开花结果的”","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"耐得住寂寞当守得住繁华","slug":"耐得住寂寞当守得住繁华","date":"2014-11-11T00:01:59.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/5029/","link":"","permalink":"http://www.voyax.meposts/5029/","excerpt":"","text":"几周没有给爷爷打电话了，想问句好却不知说了这句下一句该怎么接。晚饭后去图书馆的路上接到妈打的电话，我引以为豪的重庆话引来几个与我差肩而过的人的回望，嘿，老乡，看路。下午妈带着小妹回老家，说是爷爷逮到一只野兔，我随口说这句，野兔这么小哪够这么多人吃。只是我一直都记着但凡有点好东西爷爷都要叫大家回去。爷爷马上七十了，去年三公过世，爷爷突然对我说他们6个兄弟如今就剩他和我五公了。有些东西我们都很怕，只是我们应该无所愧疚。一直以来，我的目标很简单，给家里人争气。现在，马上大学毕业，确是怕了。也许我不那么倔，不跨专业不换学校安安心心呆某航当个码农，现在会是过得很轻松，但既然选了，就要甘于承受，不要让自己失望，也不要让爱自己的人失望。 耐得住寂寞才能受得住繁华。半年以后，将是新的征程。愿所有你爱以及爱你的人安好。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"2015肖秀荣考研政治视频汇总","slug":"2015肖秀荣考研政治视频汇总","date":"2014-10-28T14:17:18.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/12899/","link":"","permalink":"http://www.voyax.meposts/12899/","excerpt":"","text":"肖秀荣免费公开课 2015肖秀荣考研政治免费公开课第一讲http://bbs.kaoshidian.com/video-2441.html2015肖秀荣考研政治免费公开课第二讲http://bbs.kaoshidian.com/video-2510.html2015肖秀荣考研政治免费公开课第三讲http://bbs.kaoshidian.com/video-2541.html2015肖秀荣考研政治免费公开课第四讲http://bbs.kaoshidian.com/video-2634.html2015考研政治大纲解读-肖秀荣公开课第五讲http://bbs.kaoshidian.com/video-2858.html 2015肖秀荣考研政治《命题人讲真题》增值视频 (上)(下：10月)http://bbs.kaoshidian.com/video-2781.html2015肖秀荣考研政治命题人1000题视频增值服务之一http://bbs.kaoshidian.com/video-2836.html2015肖秀荣考研政治命题人1000题视频增值服务之二http://bbs.kaoshidian.com/video-2837.html 2014肖秀荣政治免费公开课第一讲http://bbs.kaoshidian.com/video-701.html2014肖秀荣考研政治免费公开课第二讲http://bbs.kaoshidian.com/video-702.html2014肖秀荣考研政治免费公开课第三讲http://bbs.kaoshidian.com/video-759.html2014肖秀荣考研政治免费公开课第四讲http://bbs.kaoshidian.com/video-760.html2014肖秀荣考研政治免费公开课第五讲（上）http://bbs.kaoshidian.com/video-761.html2014肖秀荣免费公开课第五讲（下）http://bbs.kaoshidian.com/video-765.html2014肖秀荣考研政治免费公开课第六讲（上）http://bbs.kaoshidian.com/video-1112.html2014肖秀荣考研政治免费公开课第六讲（下）http://bbs.kaoshidian.com/video-1138.html 其他公开课肖秀荣2014考研政治大纲解析上http://bbs.kaoshidian.com/video-1585.html肖秀荣2014考研政治大纲解析下http://bbs.kaoshidian.com/video-1586.html2014考研政治强化班肖秀荣毛中特讲座http://bbs.kaoshidian.com/video-804.html2013考研肖秀荣考研政治押题视频http://bbs.kaoshidian.com/video-1239.html2014肖秀荣考研政治命题人1000题配套视频1http://bbs.kaoshidian.com/video-2542.html2014肖秀荣考研政治命题人1000题配套视频2http://bbs.kaoshidian.com/video-1314.html2014肖秀荣考研政治命题人1000题配套视频3http://bbs.kaoshidian.com/video-1315.html2014教研政治命题人知识点精讲精练（肖秀荣）配套视频1http://bbs.kaoshidian.com/video-1395.html2014教研政治命题人知识点精讲精练（肖秀荣）配套视频2http://bbs.kaoshidian.com/video-1396.html2014教研政治命题人知识点精讲精练（肖秀荣）配套视频3http://bbs.kaoshidian.com/video-1397.html2014考研政治命题人讲真题（肖秀荣）配套视频1http://bbs.kaoshidian.com/video-1399.html2014考研政治命题人讲真题（肖秀荣）配套视频2http://bbs.kaoshidian.com/video-1400.html2014考研政治命题人讲真题（肖秀荣）配套视频3http://bbs.kaoshidian.com/video-1401.html2014肖秀荣《命题人形势与政策》配套视频一（上）http://bbs.kaoshidian.com/video-1476.html2014肖秀荣《命题人形势与政策》配套视频一（下）http://bbs.kaoshidian.com/video-1477.html 肖秀荣2014考研政治资料、视频全汇总http://bbs.kaoshidian.com/thread-9252-1.html 2015考前辅导肖秀荣2015考研政治命题人考前终极预测http://zhibo.kaoshidian.com/course/16568.html2015考研政治肖秀荣终极预测四套卷精讲http://zhibo.kaoshidian.com/course/16645.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"请你一定等等我，不要着急白了头发©绯凉","slug":"请你一定等等我，不要着急白了头发","date":"2014-10-28T10:14:06.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/47964/","link":"","permalink":"http://www.voyax.meposts/47964/","excerpt":"","text":"在图书馆刚写完微原作业母上便打来了电话，听到她和老爹的声音时眼泪毫无征兆地一下子全涌了出来。压下情绪虚张声势地跟他们打哈哈，天南海北的一通乱侃以为自己表演的天衣无缝。却在要挂电话的时候，听到她突然顿了顿语气对我说，“宝贝儿回家吧，妈妈给你炖排骨汤。真是个傻丫头。”那一刻我使劲儿咬着牙没吭声，一句再见都没有讲就急匆匆挂断，然后靠在墙角哭成了落水狗一样。 这几个月以来的日子到底有多不好过我谁都没有说。开学一个月内频繁生病输液并不全是天气和环境的差错。睡眠食欲精神力几近临界点，可是心态根本没有同步到几年前初生牛犊不怕虎的昂扬向上。而我以为，如今的无悲无喜和人前的没心没肺，是因为把坚强修炼到了碳化硅的刚度，无坚不摧没什么大不了。可她什么都知道。在我同她插科打诨撒娇卖萌的时候，她不动声色的知晓了那些被我窖藏得严严实实的，所有的惶恐迟疑与焦虑茫然。哪怕我以为自己能瞒天过海。 如她一般的，穷尽一生再无第二人。 现今的生活，日夜颠倒开始不受控制，晚上愈发清醒，睡眠愈发不安，软弱和回忆裹着心脏生出一层又一层的茧，疲于表达的状态把人冻得像水泥一样硬邦邦。零时子夜，四周安静无声像一片荒无人烟的莽原，有时候我会想她想到整个心都揪起来，酸涩得发疼。在无数被落日与朝阳包围着的周而复始的岁月中，她亲手为我织起了一张温柔的网，托住我的年少轻狂和偏执蛮横，以心肺血脉的温热融化着所有横亘在大世界的尖锐和冰冷。然后微笑看我一步一步走远，像一尾倏而消失在人海中的鱼。 对不起，对不起是我的后知后觉。对不起，对不起是我的浅薄自大。对不起，对不起是我的挥霍无度。对不起，对不起是我的有恃无恐。对不起，对不起我可不可以说谢谢你，我可不可以说我爱你。 我不怕时光脱落在你脸上的痕迹，因为你已给我否定时光的力量。 你让我在这不安的世界中握住了一世长安。而我早已有了无畏前行的全部温暖。 有人说，成长的速度要尽可能地大于父母老去的速度。 请你一定等等我，不要着急白了头发。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"北京大学经管类、文史哲、类职场经验类讲座四十个打包下载","slug":"北京大学经管类、文史哲、类职场经验类讲座四十","date":"2014-10-25T08:58:37.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/1034/","link":"","permalink":"http://www.voyax.meposts/1034/","excerpt":"","text":"经管类讲座一：余额宝货币市场基金与互联网金融链接：http://pan.baidu.com/s/1gdCaHYb 密码：s1or 讲座二：沃顿商学院Peter Cappelli教授人才管理讲座链接：http://pan.baidu.com/s/1kTqnQF9 密码：xsbt 讲座三：2014，中国经济面对转型之痛链接：http://pan.baidu.com/s/1jGMdXmI 密码：y7cb 讲座四：东北亚能源合作与贸易链接：http://pan.baidu.com/s/1bns5Z5d 密码：gkgx 讲座五：毕业生如何进行职场规划—— 一名金融国企高管的职场感悟链接：http://pan.baidu.com/s/1ntG8lXv 密码：j7ww 讲座六：住房价格、资源错配与中国经济增长链接：http://pan.baidu.com/s/1kTFWuP5 密码：ejmm 讲座七：06年诺贝尔经济学奖得主—埃德蒙德•菲尔普斯教授北大演讲会 《中美两国市场经济的比较》链接：http://pan.baidu.com/s/1kT9kV4r 密码：f4gp 讲座八：对话林毅夫及诺贝尔经济学奖得主链接：http://pan.baidu.com/s/1gdEcPzX 密码：w2vx 讲座九：与陈平老师探讨——土地流转、国际金融和货币问题链接：http://pan.baidu.com/s/1pJ2rpIr 密码：eudj &nbsp; 文史哲类讲座一：美国城市规划教育：过去与未来链接：http://pan.baidu.com/s/1pJ6uKA3 密码：5yi7 讲座二：秩序、制度和智能——道家政治思维的奥旨链接：http://pan.baidu.com/s/1dD2BwcT 密码：417b 讲座三：孔子哲学传统及其未来发展链接：http://pan.baidu.com/s/16fqm6 密码：a5rj 讲座四：效率不高？吃颗糖果！奖励对注意以及工作记忆的作用链接：http://pan.baidu.com/s/1i3j6u1Z 密码：7kix 讲座五：面对焦虑，我们应该怎么办链接：http://pan.baidu.com/s/1pJlwap1 密码：oz6c 讲座六：饮食民俗与文化链接：http://pan.baidu.com/s/1bnpOkgB 密码：06k7 讲座七：宗教的宽容（Religious Toleration）链接：http://pan.baidu.com/s/1pJt38k7 密码：cm0h 讲座八：佛教、大学与宗教精神链接：http://pan.baidu.com/s/1eQowiUu 密码：m27j 讲座九：近代日本国家的形成——甲午战争120周年链接：http://pan.baidu.com/s/1qWDettU 密码：41lx 讲座十：自尊与自信，职业成功的起点链接：http://pan.baidu.com/s/1nOuom 密码：s58d 讲座十一：换一个视角看西方：当代哲学的最新发展链接：http://pan.baidu.com/s/1kT40YfP 密码：navs 讲座十二：社会变化浪潮中女生的素质升级——求职与感情如何双轮驱动链接：http://pan.baidu.com/s/1hqpDZiG 密码：k5vx &nbsp; 职场经验类讲座一：职场北大人——外企链接：http://pan.baidu.com/s/1ntLrX7F 密码：2xe1 讲座二：职场北大人——国企链接：http://pan.baidu.com/s/1mgNvQGS 密码：tu7h 讲座三：职场北大人——创业链接：http://pan.baidu.com/s/1bnhGKof 密码：flz1 讲座四：职场北大人——银行链接：http://pan.baidu.com/s/1i39oQXJ 密码：t286 讲座五：职场北大人系列讲座之理工科专场链接：http://pan.baidu.com/s/1o67IFKe 密码：zscs 讲座六： 职场嘉年华—职场北大人系列讲座之能源业专场链接：http://pan.baidu.com/s/1gdH00RT 密码：z172 讲座七：职场北大人系列讲座之国家部委篇链接：http://pan.baidu.com/s/1bnANaA7 密码：j8s1 讲座八：职场北大人——快消篇链接：http://pan.baidu.com/s/1eQy59Pg 密码：gnrt 讲座九： 职场北大人系列讲座之IT篇链接：http://pan.baidu.com/s/1bnrQilT 密码：9qxk 讲座十：职场北大人——咨询业专场链接：http://pan.baidu.com/s/1i3qXWjF 密码：ozlj 讲座十一：职场北大人咨询篇链接：http://pan.baidu.com/s/1gdGe2ZL 密码：dbec 讲座十二：职场北大人——投资银行专场链接：http://pan.baidu.com/s/1sj2mTvZ 密码：qkhb 讲座十三：职场北大人——人力资源篇链接：http://pan.baidu.com/s/1i37SSIT 密码：ldyr 讲座十四：职场北大人——公务员篇链接：http://pan.baidu.com/s/1mgsnInY 密码：5f7c 讲座十五： 卓越大学生涯的七项修炼—规划卓越职场生涯之路链接：http://pan.baidu.com/s/1ntFmsFR 密码：wh5o 讲座十六：对话投行、证券、咨询—求职及发展路径链接：http://pan.baidu.com/s/1o6jwlya 密码：0hrl 讲座十七：老板到底要什么——好offer离你有多远链接：http://pan.baidu.com/s/1bnhaL47 密码：sqnu 讲座十八：行业应聘实战辅导项目——面试链接：http://pan.baidu.com/s/1gd7recN 密码：mauo","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"金融","slug":"金融","permalink":"http://www.voyax.me/tags/金融/"}]},{"title":"迷茫就是才华配不上梦想","slug":"迷茫就是才华配不上梦想","date":"2014-10-02T15:16:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/11906/","link":"","permalink":"http://www.voyax.meposts/11906/","excerpt":"","text":"我曾经以为好多人的迷茫是因为没有梦想，但后来我发现我错了，其实，每个人都是有梦想的，这个梦想可大可小，都是值得自己去奔赴的东西。才华也是，有大有小。有大才华的人连吃个东西都可以吃出学问来，而普通之人的才华大多数都是小才华，需要付出很多的汗水和辛劳才能取得那么一点点的进步。但即便如此，每天能处在一点点进步之中的人，绝不会迷茫，相反地，那些看不起或者无视小进步的人，才会真正的迷茫；那些对自己的才华不自知的人，才会真正的迷茫。所以说，克服迷茫的方法，无外乎其他，就是抓住现有的生活，狠狠地向前，努力让自己做得更好，而不是站在那里，仰望天空，抱怨未来的遥远。我想倘若小陆能够认真对待每一个稿件，即便她的起点很低，三五年的时间内，也足够完成一个华丽的转变，而不是像现在一样，如同刚刚大学毕业的学生一样，抱怨生活的艰难和工作的不适。如果你有大才华，就去追求大梦想；如果你觉得自己的能力有限，才华也不够支撑起你的野心，那就安静下来，扎进小的失败和挫折中，汲取营养，如果不能成为豹子，那就成为一只漂亮高贵的梅花鹿也是好的，起码人见人爱。不要迷茫了，把当下的、手头的工作做到极致，前途肯定会一片明朗。请记得：如果需要反省，一定不是在梦想上下功夫，徘徊不定，而是要在才华上卧薪尝胆，反思它为什么不能日渐丰满。 文/蓑依","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"低头走路，埋头做事","slug":"低头走路，埋头做事","date":"2014-10-02T15:07:54.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/15504/","link":"","permalink":"http://www.voyax.meposts/15504/","excerpt":"","text":"不要说话 挺腰 埋头 做事","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"金融课外书籍，语荐","slug":"金融课外书籍，语荐","date":"2014-09-27T13:48:39.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/16674/","link":"","permalink":"http://www.voyax.meposts/16674/","excerpt":"","text":"[caption id=”attachment_716” align=”alignnone” width=”540”] 金融课外书籍[/caption] 正觉得金融知识面太窄，谢谢语同学的推荐，果然工整。 一直以来，应该感谢两个人，瑞和语，有些东西我将牢记于心。 言不及义… 祝早日康复~ &nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"满船空载月明归©板蓝根很爱做梦","slug":"满船空载月明归","date":"2014-09-27T03:33:04.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/63996/","link":"","permalink":"http://www.voyax.meposts/63996/","excerpt":"","text":"你得到什么也会失去别的什么。不过你觉得值得，你不用去反悔。你是幸福的。 你以前认为写在纸上和写在空间里有不一样，更愿意写在纸上，其实一样，因为没人愿意看。只是你潜意识更想写在空间里给某些人看。 你以前看电视，看到有亲密无间的朋友，你不相信，现在你有了甚至可以当家人的朋友才让你明白，还是有很多东西是很真实的。 你以前觉得人生很短现在也是如此，可是现在却不遗憾人生这样短。你经历了太多很多人没经历过的东西（当然不是苦难。谁说一定是苦难让人成长。苦难不过是磨去人本性而已）。 何止于米。相期以茶。 太剧烈的快乐和太剧烈地悲哀是有公共点的。同样地需要，远离人群。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"无话可说","slug":"无话可说","date":"2014-09-21T04:32:18.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/47708/","link":"","permalink":"http://www.voyax.meposts/47708/","excerpt":"","text":"一步错，满盘皆毁。 重头来，就要赢得漂亮。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"当我跨过山和大海 ©绯凉","slug":"当我跨过山和大海-绯凉","date":"2014-09-16T15:16:08.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/5270/","link":"","permalink":"http://www.voyax.meposts/5270/","excerpt":"有人问，人生最好的状态是怎样的。我看到一个答案，“清早充满热情地一跃而起，晚上心满意足问心无愧地沾床即着”，对这两句的描述无比钟意。 即使我曾说过“愿无岁月可回头”，可对有些日子却仍旧太留恋。 最初的一心一意，深信不疑，最后的情非得已，身不由己。当物换星移冬去春来时，愿我能记住路过的悲欢，然后也学着多一点勇敢，从此两个方向各自走完。 当我跨过山和大海，愿我们后会无期。还有春风十里未看，向前走不要停留。","text":"有人问，人生最好的状态是怎样的。我看到一个答案，“清早充满热情地一跃而起，晚上心满意足问心无愧地沾床即着”，对这两句的描述无比钟意。 即使我曾说过“愿无岁月可回头”，可对有些日子却仍旧太留恋。 最初的一心一意，深信不疑，最后的情非得已，身不由己。当物换星移冬去春来时，愿我能记住路过的悲欢，然后也学着多一点勇敢，从此两个方向各自走完。 当我跨过山和大海，愿我们后会无期。还有春风十里未看，向前走不要停留。 原文地址：http://primee.lofter.com/post/19dc2e_2484058 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"无题","slug":"679","date":"2014-09-14T14:37:26.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/58856/","link":"","permalink":"http://www.voyax.meposts/58856/","excerpt":"","text":"三年前，第一次踏上开往北京的列车，火车上，一个大三的学姐给说说，“大学不要颓废”，或许仅仅是当时的不屑，这句话我至今记得；我喜欢有人对我质疑，因为我知道有一天我会飞扬跋扈地证明给所有人看。只是，大学，已经进入最后一年，仍未看到光明。我为马上离开现在的这所大学而狂喜，我不喜欢这所学校，也不愿待在现在的专业。但，看着身边保研的同学，心中仍有不甘，如果我顺从大流，现在也和他们一样，暂时有了着落了吧。但，放弃了就是放弃了，如今舍弃的日后必倍数悉还。换学校跨专业很难么，有人做到我也能做到。考研加油，路漫漫其修远兮，吾将上下而求索。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"中秋旅思","slug":"中秋旅思","date":"2014-09-08T02:47:01.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/49164/","link":"","permalink":"http://www.voyax.meposts/49164/","excerpt":"","text":"孤影看分雁，千金念弊貂， 故乡秋忆月，异国夜惊潮。手未攀丹桂，以犹卷缘蕉， 登楼悲作赋，西望海天遥。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"北航6系编译pl0文档+源代码+其他经验资料","slug":"北航6系编译pl0","date":"2014-09-06T09:09:22.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/10229/","link":"","permalink":"http://www.voyax.meposts/10229/","excerpt":"","text":"去年编译大作业让我痛苦了好久，做个好事，把我的编译课程设计的最终文档（应该是，我电脑了就它了）和源代码共享出来。 先声明，我选的难度是中级，对于我这种研究生要换专业的人，不要和那些选高级的大神比。 中级满分85分，我第一次和第二次中期考核都没去，只有最后一次去了，最后得了84分，老师最后给的分应该都挺高的。最后考核的时候有个错误没有测出来，我是自己回去后才把那个bug改了，至于还有没有其他问题，我只能大问题应该没有，但保不准还抽什么风。 &nbsp; 编译课程文档 &nbsp; 编译课程设计源代码（中级） &nbsp; 北航编译课程设计往届同学经验-代码生成 &nbsp; 北航编译课程设计往届同学经验-代码优化 &nbsp; 北航编译课程设计往届同学经验-四元式与语义分析 &nbsp; 北航编译课程设计往届同学经验_语法分析&amp;错误处理","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"【转】自话","slug":"【转】自话","date":"2014-09-05T04:40:35.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/46272/","link":"","permalink":"http://www.voyax.meposts/46272/","excerpt":"","text":"以前某段时间会经常想起一句话， “事情的发生总有其意义所在”。 现在脑海里常常闪现的一句话是，“所有发生都恰如其分”。 各种偏差，无奈，挣扎，放在整个长远的人生来看， 都如小道转角处，往下再如何曲折，也都是节点一个而已。 所谓偏误，最大的偏误应该是发生在人的短视认知上吧。 很多时候人都是栽在自己手上，而非他者。 这个世界很忙，没空理你。 偶然看到一段很棒的对话， ——“怎样让世界变得更美好？” ——“让你自己变美好。” 近来处于很想把自己藏匿起来的状态。 无论是行迹，还是心情，感受，感情。 与友人交谈也是不自觉地以搞笑戏谑的面目出现。 仿佛近日已经习惯了这样的模式。 另一个自我像是进入休眠期一般，不想被唤醒，不想被侵扰。 只想静静藏起来，让阳光穿透，让尘埃掩埋。 稍稍沉默，大概只是因为正在经历一场内在变革。 无需发声无需喧闹，该体会的，自会在静默中深刻验证。 隐匿与静默的过程，通常都会积聚巨大的能量。 Z告诉我，也许我该转变方向，比如换一个生活环境。 我说不，我明白我是在按着自己往下沉。 而且我明白这是我现在该做的事。 沉到更深更深的地方，总会发现很多意想不到的东西。 暂时我并不想在广度上进行怎样的跨越， 我想要的，是在纵深的维度上，觅到另一方天地。 也许我一直是个钻牛角尖又顽固的人， 但这种特质让我建立起自己一套思考模式和行为模式， 悟出很多让自己变得通透爽朗的道理。 于是“钻牛角尖”也不存在什么好与坏了， 要看它在哪个方面发力，还有适不适合。 “你有没有发现，人在恋爱的时候，说的都是废话。” 但是这种废话让你在某段时间里感觉欢喜和愉悦， 这就已经是最大的意义。 判断对错与否，于理。 判断有无意义，于心。 原文转自：鹰婕Jane","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"on and on","slug":"on-and-on","date":"2014-09-05T04:33:20.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/51740/","link":"","permalink":"http://www.voyax.meposts/51740/","excerpt":"","text":"On and on时间的行进Over and over again开启一幕幕的画面There is no holding back time you said你曾感叹时间难以琢磨So you run your race ，made your transformation所以你奋不顾身 记录人生的蜕变and left your mark留下存在的印记The possibilities are always endless人生对你来说 没有写好的剧本Everyone of them is real每个阶段的存在都是真实的and everyone of them is still you每个真实的片段组成了你you will not stop until time fails你坚决地向前走着Let those memories never fade回忆却安静的不曾离开even if our eyes should go dim即使双眼模糊了光影For looking back ,even the ordinary has become an era lost or forgotten平凡的珍贵 唤起不凡的人生Only live and breathing吐息间on a shore时光中where time has no hold凝结片刻 成为永恒","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"索尔资料整理（照片）","slug":"索尔资料整理（照片）","date":"2014-09-04T16:39:13.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/17386/","link":"","permalink":"http://www.voyax.meposts/17386/","excerpt":"","text":"照片太多了( ⊙ o ⊙ )，不想弄了，随便贴几张~(≧▽≦)/~","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"索尔资料整理（视频）","slug":"索尔资料整理","date":"2014-09-04T15:23:22.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/4152/","link":"","permalink":"http://www.voyax.meposts/4152/","excerpt":"","text":"从今天起算是离开索尔了吧，还是有些不舍 总有些人，喜欢煽风点火，此次这些人真要失望了。 虽然我选择退出，但就像杜所说，我们是一个团队，五个人。在吴、杜、蓝的坚持下，索尔会越走越远，我也愿意在索尔需要我时，助其一臂之力。 离开索尔仅是因为很多事情我还未准备好。这两三年的时间，我要专心做我自己的事情。 废话不多说，慢慢放上我手里边的索尔的资料 1.索尔SOAR 一个传奇的诞生 &nbsp; 2.这个是第二届交流会前期的宣传视频 &nbsp; 3.【第二届索尔学习经验交流会】纪念我们的高三 &nbsp; 4.【第二届索尔学习经验交流会】视频合集 &nbsp; 5.索尔首届经验交流会的，怀念高三，奋斗 &nbsp; 6.索尔学生大本营首届经验交流会的霸气开场 &nbsp; 7.这是索尔学生大本营首届经验交流会的开场ppt","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"最后我决定离开，索尔","slug":"最后我决定离开，索尔","date":"2014-09-04T11:18:39.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/12294/","link":"","permalink":"http://www.voyax.meposts/12294/","excerpt":"","text":"两年前，我们五个人聚在一起，开会、策划，以及为这个团队取名……如今，我们有了越来越多的参与者，发展的其实还蛮不错。是时候，我觉得我应该离开了……我不知道此时的离开算不算是不合时宜，但似乎也找不到最优结果很抱歉，无论何时，总有人不好受。 人和人之间的感情，如果不是越来越好，注定是越来越生疏。 在一个团队，参与得少了，也就忘记了最初的理由。 如今，我终于决定离开 没有什么该与不该，只有是还是不是。 ”离开“这个想法是大概一个月前突出冒出来的，那个时候我应该还在实习。因为以前从未想过退出，也就可以拍着胸脯对天发誓，”我要一直做下去“，很像高考填志愿吧，填志愿的时候认准了这个学校，谁劝也不会改，到了大学，才不得不承认，自己太幼稚。一个想法的产生似乎不须要任何代价，说服自己讲想法变成现实，真的需要花费很多时间。 大学过了三年，最开始的两年我过得又傻又晕，还很痛苦；大三了，我才逐渐开始想一些很现实的问题，至于，索尔，当然也在考虑范围之类。我从来都觉得索尔是一个很好的创业平台，我甚至都不愿意用项目来衡量它，想象一下，可以做学生产品，可以做成像新东方那样的学生培训，可以做公益活动，甚至可以打造中学生的互联网平台…… 但是，你有精力吗，你有时间吗？——什么都没有，而且根本就什么都没做 很抱歉，即使前两年，我也没有像你们四位那样投入到索尔。从大一到现在，我都很想说，xx大学计算机专业真TM事多。但现在，我还应该加一句，有时候是它的问题，但做决定的是我。很多东西，还是怪自己放不下和胆子不够大，社会实践算什么、生产实习算个屁啊，但是我竟然真把它当一回事儿了。 在索尔，我获得很多，也错过了很多，正重要的或许是也欠了各位很多。现在，又该做决定了。很抱歉，我还是没能选择索尔。我不再自负地相信，八面玲珑；哪怕不甘心，总有些东西必须放弃。人大金融是我目前最重要的事情，而且，我也必须去，一年后的安排，连我自己都不知道。很现实的一个问题，明年交流会能回去吗——肯定回不去，明年暑假有时间吗——得看情况。很无语，但就是这样。现在啊，我越来越觉得要多看些书多学点东西，离开索尔，或许对我，对大家都好，我现在的想法就是，多学东西，专注；而索尔，我呆在那却什么都不做，真的是个笑话，现在离开，或许是个可以接受的选择。 最后，最后，就是祝愿了。从心眼里希望索尔一直发展下去，慢慢做大（一下崛起必定更好），我们五个，都能够有所作为。虽然我决定离开索尔，但必定不是说一刀两断，只是走在了某个体制之外了吧，如果有帮得上忙的地方，我愿意尽我所能。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"阿里巴巴2015年秋季校园招聘前端在线笔试题","slug":"阿里巴巴2015年秋季校园招聘前端在线笔试题","date":"2014-08-26T14:25:27.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/13462/","link":"","permalink":"http://www.voyax.meposts/13462/","excerpt":"","text":"因为截止日期是27号16点，所以我就先不把我抽到的题公布了。不过感觉这次的题比上次招实习生的题知识面要广些，难度吧，也没有很明显的差别，一共11道题，不过我又没有做完！！！ 虽然说我并没有打算应聘阿里的前端，报名也只是想见识这些大公司的笔试，但题我还是专门腾了一个小时在线笔试。难度虽然不大，但是真的很需要有项目经验啊，反正我被虐了，呵呵呵呵。 过段时间再把我记下的题贴上来，哪天记得哪天发吧","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"千里江山寒色远，芦花深处泊孤舟","slug":"千里江山寒色远，芦花深处泊孤舟","date":"2014-08-18T09:20:17.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/33653/","link":"","permalink":"http://www.voyax.meposts/33653/","excerpt":"","text":"…… 闲梦远，南国正清秋。 千里江山寒色远，芦花深处泊孤舟。 笛在明月楼","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"去上自习吧","slug":"去上自习吧","date":"2014-08-16T10:10:57.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/56926/","link":"","permalink":"http://www.voyax.meposts/56926/","excerpt":"","text":"就像人们说的，“出来混，总是要还的”。 前几天玩的太疯，昨天开始各种病就突然一起窜到我身上。朋友走的前一天我还开着玩笑说，“等你走了，我就要开始闭关修炼了”，这下真的不幸言中了，昨天和今天一直呆在宿舍，不想去校医院，躺在床上，翻来覆去。 今天比昨天好一点，只是下午有段时间感觉要费很大劲才能呼吸。看来以后要多去跑步了。 这样憋着，什么都不做，越来越烦越来越难受。 吃完晚饭回来，又遇到在路边拉人去唱赞美诗的，这次突然有了兴趣，或许去听听也挺好，不过我决定还是去上自习吧，去久违的通宵自习室，虽然身体还是很不舒服，但在自习室趴着睡觉肯定比宿舍好的吧。 6点多了，走吧~","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"一路向北，且听风吟","slug":"一路向北","date":"2014-08-14T16:40:08.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/10484/","link":"","permalink":"http://www.voyax.meposts/10484/","excerpt":"","text":"时间过得很快，好朋友今天离开北京，搭上回家的火车 明天下午三点左右，他的北京行程就算是结束了吧 高中到大学，如果不算女生，他是我唯一一个愿意称作为兄弟的朋友。最近几个月，我才明白，交朋友、当兄弟和性格并没有关系；一直都自认为人缘还不算差，但我真正的朋友从来没有超过3个。有些人、有些事，没有必要刻意去维护，不是清高，更非高傲，花更多的时间去爱关心自己的人，爱自己愿意为之付出的人，何必在意 在北京呆久了，我终于确定自己是个孤独症患者。厌恶现实中的虚伪，喜欢动画片中的童话 但，就像《剪刀手爱德华》的结局，童话无法讲到最后 在这个拥挤的城市，或许我在折磨自己，又或许未来会后悔。但那里有让我平静的东西 这几天过得很累很开心，就像当年晚自习结束后，回到宿舍可以毫无顾忌地问他一些别人根本不用思考就明白但偏偏我不懂的问题，脱掉那层在大学在社会将自己裹得严严实实的保护套，很坦然 闲或者心烦的时候会羡慕那些能够找人一起玩一起谈心的人。上次回家，爸妈有意无意地问我女朋友之类的问题，我半开着玩笑说，现在忙得要命，哪有时间管别人。其实我还是挺希望在北京找一个人一起努力，但是我厌恶那些虚伪、拜金的女生，如果能碰到一个单纯、朴素，能够一起奋斗的女生那就自然是求之不得的事情，没有遇到自己就要好好学习 有时想想，现在都二十多了，却一事无成，要想活得惬意倒也简单，本本分分按部就班，找个工作挣点钱也不是问题；但就像一个同学说的，希望自己以后还能保持一些自己的思想，趁现在还没有向这个社会屈服，就努力活得更像自己 送朋友到了火车站，心里边有些梗塞，不想说话……小学、初中、高中周日离开家心里边酸酸的感觉又来了，总会挺过这种痛，总会达到自己想要的地方 一路向北，加油！ &nbsp; &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"好兄弟","slug":"好兄弟","date":"2014-07-31T16:17:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/40067/","link":"","permalink":"http://www.voyax.meposts/40067/","excerpt":"","text":"","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"最近需要看的前端的书","slug":"最近需要看的前端的书","date":"2014-07-31T04:16:27.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/50510/","link":"","permalink":"http://www.voyax.meposts/50510/","excerpt":"","text":"感觉一直都忙得要命，却没有什么太多进展。 1.跨专业考研 2.实习 3.我自己想看的书、想做的事，不想见的人（除了爸爸妈妈、爷爷奶奶、外公外婆） 跨专业虽然确实跨度还挺大，也不知道学了这个东西到底对自己有多大价值，只是觉得还是有必要去学这方面的东西，并且尽可能精通。好吧，考研加油！我一定会考上的。 最近两三周一直困在实习的事情上，其实也没有什么事情，但是就是感觉没有时间做其他的事情，实习的工作本来是做前端开发，但脑子里根本没有残留下些许印象。昨天看到淘宝UED上的文章，觉得前端的东西自己还差得太远，以前一直认为前端的东西不难，差不多自己都能做的吧。但其实不是，不懂原理，效率太低，知识面太窄…… 昨晚听英语的时候，有那么一瞬间，感受到认真、专注的感觉，此时英语能够听得非常明白的。这种东西，间歇性地会在我脑海游荡，高中我最无助的时候有过，大学也有过。现在在大学，我很难让自己想初中高中那样平静，不浮躁，我一直认为我属于智商不高的那种人，但我能够比别人更有耐心与毅力；但，在大学，还缺了一点东西，就是平静。昨天办公室里一个学设计的学姐突然问我 Photoshop和像素的一些问题，其实我也不是很懂，但是我很认真地凭以前所学的去理解，最后很圆满地帮她解决了问题。这后，我想，很多事情并非我做不到，只是习惯了敷衍，换一种情景，在别人眼中这就是“眼高手低”。 好吧，我决定抓紧时间学习，考研、前端，我都要搞定。前端从头开始学，看书，不急。 下面整理一些最近需要看的前端书籍，免得以后百度前段书籍推荐。 JavaScript先读两本业界传说中的为JavaScript圣经 1.《JavaScript高级程序设计》 2.《JavaScript权威指南》 再来一本Yahoo大牛，JavaScript精神领袖Douglas Crockford的大作 3.《JavaScript.The.Good.Parts》 4.还有几本业内广受好评的：《Javascript语言精粹》《Javascript密码花园》 CSS以前没有看过一本css的书，都是在网上看的资料，这次先看两本吧 1.《精通CSS》 2.《CSS权威指南 》 &nbsp; 其实应该再加几本JQuery、Ajax、NodeJs、网站优化等方面的书，但是因为还有准备考研，暂时先看这几本吧。看完再来。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"2014人大金融专硕复试","slug":"2014人大金融专硕复试","date":"2014-07-31T03:07:47.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/18371/","link":"","permalink":"http://www.voyax.meposts/18371/","excerpt":"","text":"复试（总分350）初试过后，报学硕的各科过线且总分的前24名进入复试（认识几个370多但英语不过线的），今年要20个，刷去四人且无调剂专硕的可能，人大的其他院的情况不太了解，但财政金融学院决对公平，完全看分数。复试完等不及查分数，我去院里找老师问分数，那老师打开了一个表格查我的，我趁机看到了大部分的分数，发现最后几个人的专业课笔试全是30到40分，说到底复试就是比谁考的差的考试，有几个360多的排名还在我之上，有一个360多的笔试80（看到这个分数我当时就愣了，这得从刚初试完就开始准备吧）。我从看到复试名单开始就学习复试的四本书，主要是公司理财和金融学。每天15个时，从3月13日到3月21日，3月22日体检报道没太多时间学习。专业课笔试61分，是一份付出一份收获。这四本书有太多概念（两百个左右），所以只记了往年考过的内容，重点全放在计算上（这个差不多30分，不会这个的复试就会。。。）。 1. 笔试：这个是最重要也是最公平的， 3月23日早上 （1）半个小时英语六级听力这个和下午的口试一起算分数（总分50我刚好30分，事先只听了两个小时的六级）， （2）半个小时的英语笔试50分20个单选（很像高考题，考的是语法，这个完全没准备，乱猜），3个六级阅读（难度与考研英语一样，做的还行，一起算下来这个我也30分）。 （3）然后两个半小时的专业课笔试满分100，每本书25分， 商银：第一题考了三个名词解释，金币本位制度与金汇本位制度的区别，我国的货币层次（考过），银行承兑票据与商业承兑票据的区别。 第二题是什么是利率市场化与我国哪些机构相关，这些机构应如何做。 金融学：第一题记的是市净率（PB）的影响因素 第二题是供应裢金融的特点，以及为什么能降低商业货款的风险 公司理财：只记得一个15分的计算，公司的资产贝塔为1.5,负债2500万元,为无风险负债,发行5000万股票，税后自由现金流为1000万。无风险利率为6%，风险溢价为8%，公司税为25%。 （1） 求公司的负债权益比，及公司价格每股价格（提示一下，默认发行了5000万股，每股一元） （2） 公司调整其负债权益比为1：1，其他情况不变，求此时公司的权益贝塔及公司价值。 用到了公司理财第八版前18章的大部分内容，主要是4，5，10，15，17等（这个几乎每年都有，全靠这种计算拿分） 证券投资学：第一题是一个关于方差的计算，太多数字记不得了，公司理财和证券投资上都有相关的题目。（计算一定要拿分） 二是利率期限结构的有关理论的区别和联系（这个只考过概念，相关理论没考过） 三公司的权益贝塔与什么因素有关。 面试： 我是最前面几个进去面试的。有个研究生助理，叫我们先在外面排队，她出来叫到名字就进去，先说：各位老师，下午好。中间一位说：请坐。然后坐下面对五位老师，中间的主考说：给你一分钟把自己的情况大体介绍一下（本科学校，学的什么专业，初试考了多少分，家庭情况，毕业在哪里工作，中间老师问了这些问题），然后老师说：去抽个题开始回答问题。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"人大金融","slug":"人大金融","permalink":"http://www.voyax.me/tags/人大金融/"},{"name":"考研","slug":"考研","permalink":"http://www.voyax.me/tags/考研/"}]},{"title":"jQuery1.10.3中文手册","slug":"jquery1-10-3中文手册","date":"2014-07-19T02:57:16.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/59026/","link":"","permalink":"http://www.voyax.meposts/59026/","excerpt":"","text":"一个比较规范的jQury中文手册，版本是1.10.3 jQuery1.10.4中文版API下载","categories":[{"name":"资源","slug":"资源","permalink":"http://www.voyax.me/categories/资源/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"又是高考志愿","slug":"又是高考志愿","date":"2014-06-24T09:41:56.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/55480/","link":"","permalink":"http://www.voyax.meposts/55480/","excerpt":"","text":"三年前的这个时候，我也和绝大多数人一样纠结着专业志愿，很多人给你出主意，很多人帮你规划未来，还有一大堆故弄玄虚让人头皮发麻的资料。但最后，路还是要自己选的。 高中还是太年轻。高考之后觉得终于脱离枯燥的学校生活，终于可以大展拳脚，施展抱负，坚信“人不轻狂枉少年”。 但是，不要任性。我自己是个很好的例子，高三的时候看不惯很多事情，高考填志愿的时候，很自信地对其他人说，我就不去人大，人大什么的关系背景太深，我看不起这类学校，我要报工科学校，自己学一身本事，谁也不靠。但现在想来，真的觉得当时Too young,Too simple,Too naive。填志愿还是要考虑自己以后的出路，不要太天真，很实现。 选专业和选学校高中一直忙着做题，很少对各个大学有所了解，更不用说现在取名都很洋气的专业。所以我们大都数人都是照着自己的分数挑大学，再挑专业，至于这个专业怎么样，也就是大概查查资料，好像还不错就选了。但是选专业还是至关重要的，不要等到上了大学开始骂当时选了这么一个破专业，也不要让它成为逃避学业的理由。以后从事的工作和所学的专业确实不一定对等，但关键点在于大学所学的应该让你有一技之长，要不然还上什么大学。专业一定程度上比选学校更重要，从去年开始教育部就开始对大学有所改革，以专业排名而不再强调综合实力排名，这应该是近几十年大学教育改革的一个重点。当然，真的核心的是你在大学要学到东西，如果谁说我对什么都感兴趣我什么都能学，那专业选择不是一个问题。但是对我们大多数人来讲，经历和能力有限，再加上大学本身存在很多问题，如果专业不对口很可能导致最终自己放弃这个专业，重新开始，并不是说这不行，但需要付出更多的代价。另外千万不要想说，现在随便填一个专业，等到大学去换专业；每个学校都不一样，换专业不一定好换，换专业还是要看你成绩；拿我们专业来说，我们专业算我们学校的王牌专业之一，但即使如此，也只有年级前三名可以选；而我妹妹（和我一届）因为一去就是他们学校在重庆收的最高分，所以很轻松换成了他们学校最好的专业。 填志愿的时候还是要慎重，一定要了解好这个专业。 自己做决定无论有多少亲戚长辈或者号称有多少年经验的老专家给你提供建议，他们所提供的只能作为参考资料，且不说很多人说话不负责，每个人都习惯站在自己立场说话，在他看来有价值的对你来说不一定能有这么大吸引力，还是要看自己的兴趣。当然，自己对什么感兴趣，包括现在很多工作的人来说也很难回答，我自己的看法是，要么选你擅长的，否则选一个你不反感的。 最后说点实际的：1.重庆是平行志愿，所以你大可以先选两个比较好的但可能上不了的学校，这很有必要的。每个学校都有一个招生指标，如果报这个学校的人不多，那后面的人很可能被录取。（但一定要服从调剂，要不然可能掉档） 2.自己要想清楚，不懂的就找学长学姐问，最好是相关专业和学校的。不要因为做不了决定就心烦气躁的，不要慌，静下心把思路理清。千万不要随便填！ 3.不要等到最后几个小时才填志愿，之前可以先大概填一下，免得最后系统出问题。 最后说一点，大学其实没有像高中时候期待的那么完美，高中的成绩并不代表大学毕业后的选择，无论你是选什么学校什么专业，最重要的还是你自己的努力，大学的很多资源也是需要自己去争取的，所以，即使报的学校不怎么好，只要自己能力突出一样没有任何问题，大学管理本身很松散，任何东西都要自己去争取，想成为什么样的人要靠自己去努力。 4月份的时候我去阿里参加实习招聘，面试的时候，才发现差不多都是研究生，虽然终面没过，但是当天我们那批人，过初面只有两个研究生和我，虽然终面没过，但是一些观念有所改变，企业也并不是一味看重名校看重学历，还是能者居之。 三年前，我第一次来北京的时候，火车上遇到一个学姐，她给我说，大学千万不要颓废。希望你能选一个满意的学校和专业，大学好好加油！ &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"理解卷积","slug":"理解卷积","date":"2014-06-22T11:08:47.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/46476/","link":"","permalink":"http://www.voyax.meposts/46476/","excerpt":"","text":"最幽默的解释 卷积的物理意义 谈起卷积分当然要先说说冲击函数—-这个倒立的小蝌蚪，卷积其实就是为它诞生的。”冲击函数”是狄拉克为了解决一些瞬间作用的物理现象而提出的符号。 古人曰：”说一堆大道理不如举一个好例子”，冲量这一物理现象很能说明”冲击函数”。在t时间内对一物体作用F的力，我们可以让作用时间t很小，作用力F很大，但让Ft的乘积不变，即冲量不变。于是在用t做横坐标、F做纵坐标的坐标系中，就如同一个面积不变的长方形，底边被挤的窄窄的，高度被挤的高高的，在数学中它可以被挤到无限高，但即使它无限瘦、无限高、但它仍然保持面积不变（它没有被挤没！），为了证实它的存在，可以对它进行积分，积分就是求面积嘛！于是”卷积” 这个数学怪物就这样诞生了。说它是数学怪物是因为追求完美的数学家始终在头脑中转不过来弯，一个能瘦到无限小的家伙，竟能在积分中占有一席之地，必须将这个细高挑清除数学界。但物理学家、工程师们确非常喜欢它，因为它解决了很多当时数学家解决不了的实际问题。最终追求完美的数学家终于想通了，数学是来源于实际的，并最终服务于实际才是真。于是，他们为它量身定做了一套运作规律。于是，妈呀！你我都感觉眩晕的卷积分产生了。 &nbsp; 例子： 有一个七品县令，喜欢用打板子来惩戒那些市井无赖，而且有个惯例：如果没犯大罪，只打一板，释放回家，以示爱民如子。 有一个无赖，想出人头地却没啥指望，心想：既然扬不了善名，出恶名也成啊。怎么出恶名？炒作呗！怎么炒作？找名人呀！他自然想到了他的行政长官——县令。 无 赖于是光天化日之下，站在县衙门前撒了一泡尿，后果是可想而知地，自然被请进大堂挨了一板子，然后昂首挺胸回家，躺了一天，嘿！身上啥事也没有！第二天如 法炮制，全然不顾行政长管的仁慈和衙门的体面，第三天、第四天……每天去县衙门领一个板子回来，还喜气洋洋地，坚持一个月之久！这无赖的名气已经 和衙门口的臭气一样，传遍八方了！ 县令大人噤着鼻子，呆呆地盯着案子上的惊堂木，拧着眉头思考一个问题：这三十个大板子怎么不好使捏？……想当初，本老爷金榜题名时，数学可是得了满分，今天好歹要解决这个问题： ——人（系统！）挨板子（脉冲！）以后，会有什么表现（输出！）？ ——费话，疼呗！ ——我问的是：会有什么表现？ ——看疼到啥程度。像这无赖的体格，每天挨一个板子啥事都不会有，连哼一下都不可能，你也看到他那得意洋洋的嘴脸了（输出0）；如果一次连揍他十个板子，他可能会皱皱眉头，咬咬牙，硬挺着不哼 （输出1）；揍到二十个板子，他会疼得脸部扭曲，象猪似地哼哼（输出3）；揍到三十个板子，他可能会象驴似地嚎叫，一把鼻涕一把泪地求你饶他一命（输出5）；揍到四十个板子，他会大小便失禁，勉 强哼出声来（输出1）；揍到五十个板子，他连哼一下都不可能（输出0）——死啦！ 县令铺开坐标纸，以打板子的个数作为X轴，以哼哼的程度（输出）为Y轴，绘制了一条曲线： ——呜呼呀！这曲线象一座高山，弄不懂弄不懂。为啥那个无赖连挨了三十天大板却不喊绕命呀？ —— 呵呵，你打一次的时间间隔（Δτ=24小时）太长了，所以那个无赖承受的痛苦程度一天一利索，没有叠加，始终是一个常数；如果缩短打板子的时间间隔（建议 Δτ=0.5秒），那他的痛苦程度可就迅速叠加了；等到这无赖挨三十个大板（t=30）时，痛苦程度达到了他能喊叫的极限，会收到最好的惩戒效果，再多打 就显示不出您的仁慈了。 ——还是不太明白，时间间隔小，为什么痛苦程度会叠加呢？ ——这与人（线性时不变系统）对板子（脉冲、输入、激 励）的响应有关。什么是响应？人挨一个板子后，疼痛的感觉会在一天（假设的，因人而异）内慢慢消失（衰减），而不可能突然消失。这样一来，只要打板子的时 间间隔很小，每一个板子引起的疼痛都来不及完全衰减，都会对最终的痛苦程度有不同的贡献： t个大板子造成的痛苦程度=Σ(第τ个大板子引起的痛苦*衰减系数) [衰减系数是（t-τ）的函数，仔细品味] 数学表达为：y(t)=∫T(τ)H(t-τ) ——拿人的痛苦来说卷积的事，太残忍了。除了人以外，其他事物也符合这条规律吗？ ——呵呵，县令大人毕竟仁慈。其实除人之外，很多事情也遵循此道。好好想一想，铁丝为什么弯曲一次不折，快速弯曲多次却会轻易折掉呢？ ——恩，一时还弄不清，容本官慢慢想来——但有一点是明确地——来人啊，将撒尿的那个无赖抓来，狠打40大板！ &nbsp; 卷积及拉普拉斯变换的通俗解释–对于我这类没学过信号系统的人来说太需要了 卷积(convolution, 另一个通用名称是德文的Faltung)的名称由来，是在于当初定义它时，定义成 integ(f1(v)*f2(t-v))dv，积分区间在0到t之间。举个简单的例子，大家可以看到，为什么叫”卷积”了。比方说在(0，100)间积 分，用简单的辛普生积分公式，积分区间分成100等分，那么看到的是f1(0)和f2(100)相乘，f1(1)和f2(99)相乘，f1(2)和f2 (98)相乘，……… 等等等等，就象是在坐标轴上回卷一样。所以人们就叫它”回卷积分”，或者”卷积”了。 为 了理解”卷积”的物理意义，不妨将那个问题”相当于它的时域的信号与系统的单位脉冲响应的卷积”略作变化。这个变化纯粹是为了方便表达和理解，不影响任何 其它方面。将这个问题表述成这样一个问题：一个信号通过一个系统，系统的响应是频率响应或波谱响应，且看如何理解卷积的物理意义。 假设信号函数为f, 响应函数为g。f不仅是时间的函数(信号时有时无)，还是频率的函数(就算在某一固定时刻，还有的地方大有的地方小)；g也是时间的函数(有时候有反应， 有时候没反应)，同时也是频率的函数(不同的波长其响应程度不一样)。那我们要看某一时刻 t 的响应信号，该怎么办呢？ 这就需要卷积了。 要看某一时刻 t 的响应信号，自然是看下面两点： 1。你信号来的时候正赶上人家”系统”的响应时间段吗？ 2。就算赶上系统响应时间段，响应有多少？ 响 应不响应主要是看 f 和 g 两个函数有没有交叠；响应强度的大小不仅取决于所给的信号的强弱，还取决于在某频率处对单位强度响应率。响应强度是信号强弱和对单位强度信号响应率的乘 积。”交叠”体现在f(t1)和g(t-t1)上，g之所以是”(t-t1)”就是看两个函数错开多少。 由于 f 和 g 两个函数都有一定的带宽分布(假若不用开头提到的”表述变化”就是都有一定的时间带宽分布)，这个信号响应是在一定”范围”内广泛响应的。算总的响应信 号，当然要把所有可能的响应加起来，实际上就是对所有可能t1积分了。积分范围虽然一般在负无穷到正无穷之间；但在没有信号或者没有响应的地方，积也是白 积，结果是0，所以往往积分范围可以缩减。 这就是卷积及其物理意义啊。并成一句话来说，就是看一个时有时无(当然作为特例也可以永恒存在)的信号，跟一个响应函数在某一时刻有多大交叠。 *拉普拉斯* 拉普拉斯(1729-1827) 是法国数学家，天文学家，物理学家。他提出拉普拉斯变换(Laplace Transform) 的目的是想要解决他当时研究的牛顿引力场和太阳系的问题中涉及的积分微分方程。 拉普拉斯变换其实是一个数学上的简便算法；想要了解其”物理”意义 — 如果有的话 — 请看我举这样一个例子： 问题：请计算十万乘以一千万。 对于没学过指数的人，就只会直接相乘；对于学过指数的人，知道不过是把乘数和被乘数表达成指数形式后，两个指数相加就行了；如果要问究竟是多少，把指数转回来就是。 “拉 普拉斯变换” 就相当于上述例子中把数转换成”指数” 的过程；进行了拉普拉斯变换之后，复杂的微分方程(对应于上例中”复杂”的乘法) 就变成了简单的代数方程，就象上例中”复杂”的乘法变成了简单的加减法。再把简单的代数方程的解反变换回去(就象把指数重新转换会一般的数一样)，就解决 了原来那个复杂的微分方程。 所以要说拉普拉斯变换真有” 物理意义”的话，其物理意义就相当于人们把一般的有理数用指数形式表达一样。 另外说两句题外话： 1 。拉普拉斯变换之所以现在在电路中广泛应有，根本原因是电路中也广泛涉及了微分方程。 2。 拉普拉斯变换与Z变换当然有紧密联系；其本质区别在于拉氏变换处理的是时间上连续的问题，Z变换处理的是时间上分立的问题。 &nbsp; [**有奖讨论] 卷积运算的实际意义是什么？** 卷积运算是信号处理常规的一个运算过程。 作为一个重要的基础，请大家讨论，也就是从概念，应用方向等去谈谈它的意义。 信号处理对很多朋友来说可能比较难，作为基础，我们不能小看它的作用。 欢迎参与讨论。**:)** &nbsp; 一个我觉得比较精彩的发言。。。开个头！ &nbsp; 从数学的角度分析： &nbsp; 信号处理是将一个信号空间映射到另外一个信号空间，通常就是时域到频域，（还有z域，s域），信号的能量就是函数的范数（信号与函数等同的概念），大家都知道有个Paserval定理就是说映射前后范数不变，在数学中就叫保范映射，实际上信号处理中的变换基本都是保范映射，只要Paserval定理成立就是保范映射（就是能量不变的映射）。 &nbsp; 前面说的意思就是信号处理的任务就是寻找和信号集合对应的一个集合，然后在另外一个集合中分析信号，Fourier变换就是一种，它建立了时域中每个信号函数与频域中的每个频谱函数的一一对应关系，这是元素之间的对应，那么运算之间的对应呢，在时域的加法对应频域中的加法，这就是FT线性性的体现，那么时域的乘法对应什么呢，最后得到的那个表达式我们就把它叫卷积，就是对应的频域的卷积。 longdi **发表于** 2006-11-16 16:11 对于卷积，下面是我的理解，如果错误，敬请指出，谢谢！ &nbsp; 1。两个时域上的函数做卷积可以这样理解：一个函数表征一个线性系统的 冲激响应，这个系统可以是时变的，但一定要是线性的；另一个函数表征 输入到该系统的信号；卷积的结果表征线性系统的输出。对于非线性系统， 输出信号无法表示为输入信号与系统冲激响应的卷积，所以有些教材是叫作 信号与线性系统，强调系统的线性。 &nbsp; 2。两个时域上的函数做卷积还可以这样理解：输出表征做卷积的两个函数 在特定时刻看来的相关程度，当然此时其中一个函数已经被看作是y(tao)=x(t-tao) 了，特定时刻的输出越大，这两个函数在这一时刻看来相似程度就越好。 gable **发表于** 2006-11-24 12:13 前两天看MATLAB教程中多项式相乘时候忽然想到一点，谈一下自己的看法，有不足之处还请高人指点。 &nbsp; 拿离散信号开刀 &nbsp; 卷积的表达式为 y(n)=∑x(k)×h(n-k)或y(n)=∑x(n-k)×h(k) &nbsp; 这里的n-k表示h从负无穷移动到正无穷，每移动一个单位都同x相乘，所有的乘积项相加后就得到了y。 &nbsp; 再看一下多项式的乘法 &nbsp; (……x^2+x+1……)×(x^2+3x-3) =(……x^2+x+1……) ×x^2+(……x^2+x+1……) ×3x-(……x^2+x+1……) ×3 &nbsp; 由于多项式是固定的，少了反折和平移，但我觉得这样更容易理解卷积的数学表达式 &nbsp; 物理意义就是：任何一个信号都可以表示成单位冲击信号之和。当这个信号通过一个线性系统时，若系统的冲击响应已知，则只需将表示该信号的每一个单位冲击信号在不同时延后的冲击响应叠加，总和就是输出信号。 liukeke498 **发表于** 2006-12-11 19:48 很赞同楼上说的多项式的乘法的例子，从时域和z域的关系也可以理解。两个多项式相乘就是 (a(0)+a(1)z^(-1)+a(2)z^(-2)……+a(p)z^(-p))(b(0)+b(1)z^(-1)+b(2)*z^(-2)+….+b(q)z^(-q))=c(0)+c(1)z^(-1)+c(2)z^(-2)+….+c(p+q)z^(p+q) z域的乘积对应时域的卷积，因此乘积后的系数序列（c(0),c(1)….c(p+q))即为序列a(0)….a（p）与序列b(0)…b(q)进行线性卷积而得到 jumpyists **发表于** 2006-12-29 13:44 一点感想 2。两个时域上的函数做卷积还可以这样理解：输出表征做卷积的两个函数 在特定时刻看来的相关程度，当然此时其中一个函数已经被看作是y(tao)=x(t-tao) 了，特定时刻的输出越大，这两个函数在这一时刻看来相似程度就越好。 &nbsp; &nbsp; 这话好像有问题？相关函数和卷积是不一样的，翻翻信号与系统吧 根据我个人的理解卷积运算之所以对于线形非时变系统如此重要 其原因有两点： 1 一个线性非时变系统对于单频正弦信号或复指信号的响应仍然是单频正弦信号或复指信号只是幅度上进行了 加权，可见线性非时变系统对基本信号的响应如此简单就使人想到能否将对复杂信号的响应转化为对简单 信号的响应的求解？ 2 傅立叶级数傅立叶变换就告诉我们如何将一个信号分解为基本信号 所以对一个信号的响应求解的过程为： 首先将其分解为基本信号 然后对每个基本信号求响应 而卷积则正是这一过程的一个综合表示 所以卷积是如此的重要！！！！！ 还有一个很重要的原因是实际物理系统通常都可以近似为线性非时变系统或几个线性非时变系统的互联 所以所以卷积更更更重要了！！！！！ dragonkiss **发表于** 2006-12-29 15:22 [quote]原帖由 [i]jumpyists[/i] 于 2006-12-29 13:44 发表 2。两个时域上的函数做卷积还可以这样理解：输出表征做卷积的两个函数 在特定时刻看来的相关程度，当然此时其中一个函数已经被看作是y(tao)=x(t-tao) 了，特定时刻的输出越大，这两个函数在这一时刻看来相似程度 … [/quote] &nbsp; &nbsp; 这个问题可能是各人理解的不同，可以和原来的朋友PM沟通一下。:) longdi **发表于** 2007-1-1 23:41 我说的相关不完全是严格定义上的相关，不过我觉得可以近似 那样理解卷积。 [quote]原帖由 [i]jumpyists[/i] 于 2006-12-29 13:44 发表 2。两个时域上的函数做卷积还可以这样理解：输出表征做卷积的两个函数 在特定时刻看来的相关程度，当然此时其中一个函数已经被看作是y(tao)=x(t-tao) 了，特定时刻的输出越大，这两个函数在这一时刻看来相似程度 … [/quote] ycx198 **发表于** 2007-1-2 21:01 我比较赞同卷积的相关性的作用 在通信系统中的接收机部分MF匹配滤波器等就是本质上的相关 匹配滤波器最简单的形式就是原信号反转移位相乘积分得到的近似＝相关 相关性越好得到的信号越强 这个我们有一次大作业做的 做地做到呕吐 呵呵 还有解调中一些东西本质就是相关 有机会再说哈 偶正在研究这个聂 呵呵 longdi **发表于** 2007-1-19 21:44 2。两个时域上的函数做卷积还可以这样理解：输出表征做卷积的两个函数 在特定时刻看来的相关程度，当然此时其中一个函数已经被看作是y(tao)=x(t-tao) 了，特定时刻的输出越大，这两个函数在这一时刻看来相似程度 … 这话好像有问题？相关函数和卷积是不一样的[/quote] 程乾生老师的《信号数字处理的数学原理》（这本书本网站有的） Page240有这样的一段话： “这说明，尽管褶积与相关是从研究不同的问题提出来的，但是二者的实质是相同的， 相关是一种褶积，褶积也是一种相关。” xiaomifeng134 **发表于** 2007-1-25 22:52 对于一f(t)，把要考虑的从0到t的时间间隔等分成宽度为t1的n个小间隔，各脉冲的宽度都等于着间隔的宽度t1，各脉冲的高度分别等于他左边所在时间[(k-1)t1]的函数值。当t1甚小时这些脉冲分别用一些冲激函数来近似地表示，各冲激函数的位置就是它所代表的脉冲左侧边所在的时间，各冲激函数的强度就是它所代表的脉冲的面积。此时f(t)=f(0)t1delta(t) +…+f(kt1)t1delta(t-kt1)+…1=&lt;k&lt;=n,而对于一冲激响应为h(t)的线性系统，当输入f(t)时，输出为y(t)=f(0)t1h(t)+…+f(kt1)t1h(t-k*t1)+…当t1趋于零时，y(t)就可表示为f(t)与h(t)的卷积。 &nbsp; longdi **发表于** 2007-2-21 21:49 另外，关于相关和卷积的关系，我前面也说了自己的观点， 后来也在程乾生老师的《信号数字处理的数学原理》看到了他的观点： 程乾生老师的《信号数字处理的数学原理》（这本书本网站有的） Page240有这样的一段话： “这说明，尽管褶积与相关是从研究不同的问题提出来的，但是二者的实质是相同的， 相关是一种褶积，褶积也是一种相关。” 网络上每个人都有发表自己观点的权利，也有捍卫自己观点的权利， 当网络上缺乏一个大家公认的权威时，说服别人就成了件比较困难的事。 temp_110 **发表于** 2008-1-7 21:43 如果看成运算规则，卷积就是乘法的另一种表示。 相关在形式上和卷积一样，但是相关显然有统计学上的含义。 &nbsp; [[i] 本帖最后由 temp_110 于 2008-1-7 21:48 编辑 [/i]] quit2468 **发表于** 2008-1-17 10:49 根据定义而言卷积和相关根本就不是一个东西，硬要说联系，也就一个信号——比如说x[k]的自相关可以写成x[k]与x[-k]的卷积。 我对卷积的理解没有楼上各位那么深，我觉得单吧卷积隔离开来看什么都不是，卷积无非两个作用，一是将时域与频域的运算联系上，二是信号通过一个系统还有系统的级联就是用卷积来表示的——就像1+1+1可以用1*3表示一样，这里面乘法没有什么意义可言 bluebolt **发表于** 2008-1-19 20:06 根据定义而言卷积和相关根本就不是一个东西，硬要说联系，也就一个信号——比如说x[k]的自相关可以写成x[k]与x[-k]的卷积。 我对卷积的理解没有楼上各位那么深，我觉得单吧卷积隔离开来看什么都不是，卷积无非两个作 … 同意楼上的观点 卷积与相关不一样 若要说相同那只是在数学表达形式上类似 从物理意义上说 卷积主要用于求输入信号经过系统后的响应 得出的结果仍然是时域上的函数 相关则是求两个信号的相似程度 得出的结果可用一个归一化的参数表示 obnewux **发表于** 2008-1-27 11:29 个人也认为卷积和相关是不同的。刚做了一个项目涉及到相关。假设将信号x(n)和y(n)相关，那么为了利用FFT变换，可以这样实现。 将x(n)倒序，即将x(1),x(2),……,x(n)变为X=[x(n),x(n-1),……,x(1)]，将其作FFT为XF。对信号y(n)直接作FFT变为YF。那么 相关值就等于z=ifft(XF*YF)。 因此，只有将其中一个信号反序，再与另一个信号卷积，才可以等效于相关。 obnewux **发表于** 2008-1-27 11:36 另外，我还想问个问题： 在我们作项目的时候对于卷积处理都是如下进行的，不知道对不对。 假设输入x(i)，滤波器系数为h(i)，长度分别为m和n。x(i)通过滤波器相当于卷积，那么输出y(i)的长度应该为m+n-1。而我们在仿真中为了保证输入输出长度一致，我们取了y(i)的中间部分作为输出，即i=[1:n/2]以及i=[m+n-1-n/2:m+n-1]这部分的数据就不要了。中间部分长度刚刚是m。 不知道这样处理对不对 请大家指教。 hjihxb **发表于** 2008-2-10 17:09 卷积与相关类似在数学上表现为乘积和，但卷积需要反摺，而相关不需要， 因此相同的两个数列卷积与相关是不同的。 asdf229955 **发表于** 2008-3-25 17:47 卷积是分析数学中一种重要的运算。设: &lt;math&gt; f(x)&lt;/math&gt;,&lt;math&gt;g(x)&lt;/math&gt;是R1上的两个可积函数，作积分： &nbsp; &lt;math&gt; \\int f(\\tau) g(x - \\tau)\\, d\\tau&lt;/math&gt; 可以证明，关于几乎所有的x∈(－∞，∞) ，上述积分是存在的。这样，随着x的不同取值 ，这个积分就定义了一个新函数h(x)，称为f与g的卷积，记为h（x）＝（f g）（x）。容易验证，（f g）（x）＝（g f）（x），并且（f g）（x）仍为可积函数。这就是说，把卷积代替乘法，L1（R1）1空间是一个代数，甚至是巴拿赫代数。 &nbsp; 卷积与傅里叶变换有着密切的关系。利用一点性质，即两函数的傅里叶变换的乘积等于它们卷积后的傅里叶变换，能使傅里叶分析中许多问题的处理得到简化。 &nbsp; 由卷积得到的函数（f g）（x），一般要比f，g都光滑。特别当g为具有紧支集的光滑函数，f 为局部可积时，它们的卷积（f g）（x）也是光滑函数。利用这一性质，对于任意的可积函数 ， 都可以简单地构造出一列逼近于f 的光滑函数列fs（x），这种方法称为函数的光滑化或正则化。 &nbsp; 卷积的概念还可以推广到数列 、测度以及广义函数上去。 &nbsp; 定义 函数f 与g 的卷积记作&lt;math&gt;f \\star g&lt;/math&gt;，它是其中一个函数翻转并平移后与另一个函数的乘积对于平移量的积分。 &nbsp; &lt;math&gt;(f \\star g )(t) = \\int f(\\tau) g(t - \\tau)\\, d\\tau&lt;/math&gt; 积分区间取决于f 与g 的定义域。 &nbsp; 对于定义在离散域的函数，卷积定义为 &nbsp; &lt;math&gt;(f \\star g)[m] = \\sum_n {f[n] g[m - n]} &lt;/math&gt; &nbsp; [编辑]多元函数卷积 按照翻转、平移、积分的定义，还可以类似的定义多元函数上的积分： &nbsp; &lt;math&gt;(f \\star g )(t_1,t_2,\\cdots,t_n) = \\int\\int\\cdots\\int f(\\tau_1,\\tau_2,\\cdots,\\tau_n) g(t_1 - \\tau_1,t_2 - \\tau_2,\\cdots,t_n - \\tau_n,)\\, d\\tau_1 d\\tau_2 \\cdots d\\tau_n&lt;/math&gt; 性质 各种卷积算子都满足下列性质 &nbsp; 交换律 &lt;math&gt;f \\star g = g \\star f \\,&lt;/math&gt; 结合律 &lt;math&gt;f \\star (g \\star h) = (f \\star g) \\star h \\,&lt;/math&gt; 分配律 &lt;math&gt;f \\star (g + h) = (f \\star g) + (f \\star h) \\,&lt;/math&gt; 数乘结合律 &lt;math&gt;a (f \\star g) = (a f) \\star g = f \\star (a g) \\,&lt;/math&gt; 其中&lt;math&gt;a&lt;/math&gt;为任意实数（或复数）。 &nbsp; 微分定理 &lt;math&gt;\\mathcal{D}(f \\star g) = \\mathcal{D}f \\star g = f \\star \\mathcal{D}g \\,&lt;/math&gt; 其中Df 表示f的微分，如果在离散域中则是指差分算子，包括前向差分与后向差分两种： &nbsp; 前向差分：&lt;math&gt;\\mathcal{D}^+f(n) = f(n+1) - f(n)&lt;/math&gt; 后向差分：&lt;math&gt;\\mathcal{D}^-f(n) = f(n) - f(n-1)&lt;/math&gt; 卷积定理 卷积定理指出，函数卷积的傅里叶变换是函数傅里叶变换的乘积。即，一个域中的卷积相当于另一个域中的乘积，例如时域中的卷积就对应于频域中的乘积。 &nbsp; &lt;math&gt; \\mathcal{F}(f \\star g) = \\mathcal{F} (f) \\cdot \\mathcal{F} (g) &lt;/math&gt; 其中&lt;math&gt;\\mathcal{F}(f)&lt;/math&gt;表示f 的傅里叶变换。 &nbsp; 这一定理对拉普拉斯变换、双边拉普拉斯变换、Z变换、Mellin变换和Hartley变换（参见Mellin inversion theorem）等各种傅里叶变换的变体同样成立。在调和分析中还可以推广到在局部紧致的阿贝尔群上定义的傅里叶变换。 &nbsp; 利用卷积定理可以简化卷积的运算量。对于长度为&lt;math&gt;n&lt;/math&gt;的序列，按照卷积的定义进行计算，需要做&lt;math&gt;2n-1&lt;/math&gt;组对位乘法，其计算复杂度为&lt;math&gt;\\mathcal{O}(n^2)&lt;/math&gt;；而利用傅里叶变换将序列变换到频域上后，只需要一组对位乘法，利用傅里叶变换的快速算法之后，总的计算复杂度为&lt;math&gt;\\mathcal{O}(n\\log n)&lt;/math&gt;。这一结果可以在快速乘法计算中得到应用。 &nbsp; 在群上的卷积 若G 是有某m测度的群（例如Hausdorff空间上Harr测度下局部紧致的拓扑群），对于G 上m-Lebesgue可积的实数或复数函数f 和g，可定义它们的卷积： &nbsp; &lt;math&gt;(f \\star g)(x) = \\int_G f(y)g(xy^{-1})\\,dm(y) \\,&lt;/math&gt; 对于这些群上定义的卷积同样可以给出诸如卷积定理等性质，但是这需要对这些群的表示理论（group representation）以及调和分析的Peter-Weyl定理。 &nbsp; 应用 卷积在工程和数学上都有很多应用： &nbsp; 统计学中，加权的滑动平均是一种卷积。 概率论中，两个统计独立变量X与Y的和的概率密度是X和Y的概率密度的卷积。 声学中，回声可以用源声与一个反映各种反射效应的函数的卷积表示。 电子工程与信号处理中，任一个线性系统的输出都可以通过将输入信号与系统函数（系统的冲击响应）做卷积获得。 物理学中，任何一个线性系统（符合叠加原理）都存在卷积。 buzhiyao 发表于 2008-3-27 10:41 卷积可以看作是加权的过程，从这个意义讲就是信号处理中的滤波器， 也可以视为求两个相卷的函数的相似程度的过程，比如数学中的求内积 zbbzyp 发表于 2008-3-27 21:02 另外，我还想问个问题： 在我们作项目的时候对于卷积处理都是如下进行的，不知道对不对。 假设输入x(i)，滤波器系数为h(i)，长度分别为m和n。x(i)通过滤波器相当于卷积，那么输出y(i)的长度应该为m+n-1。而我们在仿真中为了保证输入输出长度一致，我们取了y(i)的中间部分作为输出，即i=[1:n/2]以及i=[m+n-1-n/2:m+n-1]这部分的数据就不要了。中间部分长度刚刚是m。 不知道这样处理对不对 请大家指教。 &nbsp; 这样作可能会出问题的。 在数字信号处理中，一个有限长度为m的信号，通过一个长度为n的系统（单位冲激响应）； 那么输出也应该取m点。 虽然用卷积运算会得到m＋n－1点输出数据，但是需要根据滤波器的延时进行输出信号的截取。 比如滤波器的延时为l，那么应该从第l点开始截取输出信号。 zbbzyp 发表于 2008-3-27 21:09 从连续信号处理来考虑； 卷积是通过简单的脉冲信号的系统响应，来得到复杂信号的系统响应； 连续信号可以看作是无穷多脉冲信号的叠加； 每个脉冲信号的系统响应是已知的，其幅度为脉冲的强度； 这样根据线型系统的可加性，就得到了卷积公式。 &nbsp; 卷积运算是线型系统分析的基础； 另外，时域卷积对应于频域相乘，这简化了运算。 没用的阿吉 发表于 2008-5-30 11:01 首先，注意卷积运算的前提，它必须针对线性系统。只有在满足这个前提的条件下，才能将输入信号进行分解，将输出进行叠加。 其次，同意xiaomifeng134 的说法，这个也是采用卷积运算的目的所在，是为了求解在任意激励下通过线性系统的零状态相应。至于积分的意义就不用多说了，无非就是面积而已。 最后，想说说卷积和相关。个人认为两者并无联系，纯粹形似而已。就算勉强可以理解为相关性，那也是一个函数与另一个函数的翻转函数之间的相关性。 &nbsp; 一家之言，望大家批评指正。 farmingyard 发表于 2008-5-30 13:59 卷积运算只适用于LTI（线性时不变）系统，这是总的前提！ 在LTI系统中，任何信号都能进行分解，这是最关键的！信号分解是LTI系统分析中最基本的手段，有广泛地应用！ 但是从系统响应的求解角度来看，将任意信号分解为冲击函数或冲击序列的线性组合是最为有利的！ 将信号分解为冲击函数（冲击序列）的线性组合之后，由于LTI系统满足比例性和叠加性，所以，信号经过该系统之后的响应也可以用函数的线性组合，只不过此时不再是冲击了，而是冲击响应！对于连续信号，该组合为积分形式，即卷积积分；对于离散系统，该组合为求和形式，即卷积和！ 由于刚刚学过该课程，所以说说，和大家交流一下！请指正！ SevenGirl **发表于** 2008-6-4 22:27 感觉卷积，在信号中就主要是时域、频域转换。利用卷积提取前后序列中蕴含的关系。卷积在其他领域也有很多运用，例如在编码中，有卷积码，就是运用原码中前后序列的码字确定当前编码输出，Turbo码就可以认为是一种卷积码。 farui **发表于** 2008-6-15 00:33 卷积与相关类似在数学上表现为乘积和，但卷积需要反摺，而相关不需要， 因此相同的两个数列卷积与相关是不同的。 [/quote] 没错，卷积与相关在数学上的不同，也决定了他们的物理意义是不同的 卷积可以表示一个信号通过一个线性时不变系统，而相关是用来反映两个信号的相似程度。 这是我的理解。 handchief581 **发表于** 2008-6-15 18:05 说到卷积，其意义的前提建立这两个条件之下：一是任意的数字信号都可以表示成单位脉冲之线性组合，二是该系统也是线性的。 如果说的比较通俗一点的意思就是说，如果我给一个系统一个脉冲激励，系统会给你一个相对应的响应；如果是一个由脉冲的线性组合给系统激励，那么该激励的响应就是线性组合的因子与脉冲响应的卷积。 不知道我得认识有没有错误，可能说的不是非常的严谨，可以这样去理解。 frdcmimo **发表于** 2008-6-24 20:06 楼上说的不错。实际上当一组信号通过一个器件，或者说传递函数时，它的输出是什么呢。无疑用冲击响应可以很好的描述这一过程。而当这些响应应该是线性可加的，这一过程就被描述为卷积。它绝不仅在信号处理中出现，在自动控制也是最常见的问题。当然也有很多非线性器件，比如限幅器，比如回滞器等。 卷积就不够描述了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"信号","slug":"信号","permalink":"http://www.voyax.me/tags/信号/"}]},{"title":"感恩常在，洗礼","slug":"感恩常在，洗礼","date":"2014-06-21T14:41:47.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/49893/","link":"","permalink":"http://www.voyax.meposts/49893/","excerpt":"","text":"这些真挚，朴素的照片一定会带给大家一次人性的洗礼。 我们多少人曾经假装生活在别处，我们闭上眼睛，以为不会看见，但在这些图片面前，我们能清楚地听见自己撕裂的心灵与灵魂的对话，曾经麻木的心在疼痛中慢慢复苏。 这每一张都能给人深深的震撼。我们都需要经常地反省自己，不要让本来柔软的心变得失去知觉！ 我相信爱是一种很伟大的催化剂，它能柔软你的心，也能让这个本来就不够公平的世界多一些温存。 1、同是天涯沦落人同是天涯沦落人，这一馈赠，让人看后眼泪无声无息地滑落…… 2.男儿一跪仍英雄 他——是一位西藏运输兵，军功章代表着他为祖国立下的汗马功劳，可他连自己的妻子难产死*都没来的及看上一眼。下跪， 在妻儿的墓前下跪……男儿一跪仍英雄！ 张良善永远不会忘记1992年。那年10月，他即将分娩的妻子何桂丽患感冒住进了医院。当时，要拉上山的油罐已准备好，次日一早就出发。车到狮泉河，留守处把电话打到分区，说张良善爱人第二次住院，即将分娩，是难产，挺危险的。他驾着汽车在高原飞驰，大车要5天才能走完的路，他用了1天1夜就赶完了。到叶城时，孩子已经夭折，妻子也因大出血生命垂危。他在医院守了15天，在妻子弥留之际，他含泪问爱人还有什么话要说，爱人只是摇摇头，好半天，才流着泪说，以后跑山上的路，要慢一些。他悲痛欲绝地埋葬了妻子，然后去买了两袋水泥、一些沙石，要亲手给妻子立个墓碑。墓碑做好了，还没刻完碑文，他得知营里要往阿里送一批战备物资。张良善主动请战，他说，我要用这种方式表达对爱人的悼念之情。他又一次战胜了阿里。从山上下来后，他在妻子的墓碑上刻下了碑文。 3、兄弟我走了、我会想你的 这个叫小鲁的战士退伍走的那一天，他一直训练的警犬“待发”和“大海”一直拉扯他的行李，不让他走。好容易坐上车了，“待发”突然蹿上车顶，“大海”扑车窗狂叫，车只好停下来，连司机都哭了。 4、到底，谁才是禽兽呢？ 一位斗牛士在一场斗牛里突感不舒服，第一位赶来他身边的是被他刺了几剑的牛，默默地看他。 到底，谁才是禽兽呢？ 5、“叔叔、阿姨，给……” 汶川地震期间，南京江宁区一名“奇特”的乞讨人员向灾区捐款。虽然只捐了几十元，但已是震撼人心. 6、拜见“猴王” 拍86版《西游记》的时候，六小龄童上了妆，在山上遇到个小猴子，小猴儿看见比自己体型大这么多的猴王，就敬了个礼。当然猴王也回了一个。于是就有了这张超有爱的照片，这照片当时拿了摄影的国际金奖。 7、没看错，他们是同一个国家的孩子 8、捡了几十年垃圾的九十多岁老人 生活还在继续 “29块2，算整给你29”老人苦笑着接过收废品老板的钱，缓缓地走回破烂的家。老人九十多了，在上海流浪了几十年，一生孤苦。每天都要扛近百斤的旧纸皮走一个小时路到废品站卖，除去收纸皮的本钱，自己赚不了多少。一个商人很同情老人，拿了张世博会的票给她，老人却说：可以换成一张身份证吗？ 9、爱心不分贵贱 2008年，四川大地震，深圳八位坐台小姐联合捐款100万，慈善机构收了钱，媒体好像没有报道？ 大灾大难面前，我们众志成城 。 10、请体谅这些农民工兄弟们 朋友们，当你们在回家的火车过道上看到坐着或躺着的农民工时，请不要因为拥挤厌烦他们，他们既不懂网上订票也不会打电话订票，买票的时候怎么会抢过我们呢？他们在外忙碌了一年，回家比我们更急切，请体谅他们，谢谢 11、一个回不了家的苦难孩子 三个月大的小松狮，不止一次的被赶出家门，然后找回家去，然后再被赶出，又找回去。三个月大的孩子，也许都不知道自己已经被遗弃了。然后再最后一次找回家去的时候，主人残忍的把眼睛剜瞎，于是就那样再也回不去了. 12、45分钟的意义 52岁的Mark患病，只剩不到1周的生命，他想见未出世的孩子。太太让预产期提前，女儿出生，Mark紧紧抱了她45分钟后安然离世.孩子长大后她会问：他见过我吗？那他喜欢我吗？见过，他很爱你，他觉得你是最漂亮的。 13、真正的老板 澳大利亚墨尔本一巴士公司1800名员工近日收到平均约合5.7万元的巨款,有人误以为银行出错致电询问:原来是老板Ken Grenda卖掉经营了三代的家族企业,默默给全体员工发了总额约合1亿元人民币的年终奖。他对待员工像对待家人一样,知道每位员工的名字. 14、暖人的帮助 真诚的谢意 2012年1月8日，中国，太原火车站，一位老农想乘火车去天津看望女儿，因没带身份证，带的钱也不够买票而滞留在车站广场；一名警察发现后，帮老人办理了临时身份证，掏出自己的钱补上票款买上了票。他一直把老人送上了车，并嘱咐列车员沿途照顾老人；老人临进站时跪在地上感谢这位好心的警察. 15、无以言表的母爱 无以言表的母爱,给您的母亲打一个电话，道一句平安吧! 16、相依相伴一定要分男女？ 她们一个91岁，一个88岁。戴帽子叫另一位阿宝，另一位叫对象阿贝。因为是同性恋曾经被人们骂作“反派”。阿宝说：“咱们买大袋的吧，你爱吃。”阿贝说：“你不是喜欢吃麻蓉吗？买一包豆沙、一包麻蓉。”最后她们买了两包搞促销的豆沙，一包3块2。新闻曾经报道过~~那次看哭了，不管怎么样，同性恋没有得罪谁，只是取向不同，但不要看不起同性恋，因为同性恋也是人，不做什么伤天害理的事. 17、卖孩子的金毛犬贝贝 2010年8月18，深圳，金毛犬贝贝按主人要求，叼着自己的三个孩子去卖。贝贝特别懂事，主人去买菜，它蹲在旁边等，等菜放在篮子里，它就帮主人叼回家，还会在下雨时帮主人叼伞，会把垃圾摆在门口，只要主人一声招呼，就把它们叼到垃圾筒里。贝贝知道要去卖孩子，这不是第一次了。路上，3只毛茸茸的金毛宝宝在篮子里打瞌睡，能叼27斤的贝贝几次停下来，在狗市，面对讨价还价的人，贝贝知道又要和孩子分离。。。 18、肯德基门口的感人双老 很感人的一幕：在肯德基门口一位年老的乞丐进去买了一支圆筒给自己的乞丐老伴，然后自己坐在旁边默默地看着她品尝。作为消费者，他们是有权利在里面坐着吃的。但他们没有，悄悄地坐在门外。我想，这个时候，他们在爱的面前，我们都是卑微的…… 19、电话那头说英语的孩子 20、商场被保安怒喝的老人 一位以卖菜为生的老人去商场想买一个发卡，只因为今天是他孙女的生日。这时一个保安过来用奇怪的眼光打量他,并指着门说这不是你来的地方：“滚”！老人始终面带笑告诉他要买发卡，保安竟不耐烦地T了老人一脚，并继续呵斥他出去,再不出去就揍他，最后老人无奈地走出了商场…… 21、每天守候你的家人 每天都有这么几位家人在等你回家，真的是一种幸福 22、谁剥夺了它面对生活的勇气？ 武汉市武昌区学院路，因为担心被打，小狗躲进墙洞，三年不敢出来。家住附近的张爹爹介绍，三年前，小狗亲眼看着自己的母亲被人打死，所以便躲进了路边的一个墙洞，从此不再出来，只是偶尔探出头来透透气。附近居民见其可怜，便自发给它送饭，一日三餐，一送就是三年. 23、最好的守护 有钱又怎么样。没钱有怎么样。只要心中有爱。到老了走不动了，2个人一起坐在轮椅上也是很幸福的. 24、候车室内的超度 火车站候车室，一位老人猝死，正在候车的一位僧人为老人超度。震惊君感叹：这个握手，超越一切！大师给予的是一种爱，围观的群众给予的却是另一种眼神。人还是有信仰好，愿老人安息，感谢慈悲的大师，南无阿弥陀佛。 25、父爱如山 尘世间，也许一切都会改变，但是，我相信，爸爸对我的爱，我对爸爸的爱，与青山同在，与世长存。 26、好好学习 天天向上! 这是发生在我们身边，活生生的事，他们是我们的同胞，和我们有一样肤色和血脉的老老少少啊！没有恶就不会有善，如果你自认为是好人，那你还得感谢那些坏人来衬托你。好好学习,天天向上!如果你衣食无忧，你应该感谢那些照片中人让你了解你现在的生活是如何值得珍惜。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"保持耍的本性，沧海横流方显英雄本色","slug":"保持耍的本性","date":"2014-06-20T15:58:26.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/36932/","link":"","permalink":"http://www.voyax.meposts/36932/","excerpt":"","text":"“耍”和“玩”对我来说是两个完全不同的概念，“耍”带有理性. 总有一些世界观是傻傻的矗在那里，无论多少的现实多少的嘲讽多少的鸽子都改变不了。我们总是要怀有理想的 专注、认真、敏捷 风生水起才知天高云淡,沧海横流方显英雄本色。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"梦·战","slug":"梦·战20140618","date":"2014-06-18T15:53:41.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/22221/","link":"","permalink":"http://www.voyax.meposts/22221/","excerpt":"","text":"今天的天气如同我前两天一直祈祷的一样，只是有些东西始终还是没有盼到。 早上七点四十去图书馆，竟然发现偌大的一个教室只剩下两个空座。我是否该庆幸，还留给了我个二选一的机会。 很久没有像今天如此平静，除了和食堂打饭的阿姨说过话，没有再说过一句话。晚饭的时候还是挑了中午那个靠窗的绝对没有人打扰的座位。坐在那，让我突然想起初中的时候为了考到第一名，排队、洗碗的时候我都要挑我认准的位置，虽然有些幼稚，但那是我一直坚信那是我一定能考到第一的必要条件之一。那种激情，很久没有出现过了，但是今天终有有了类似的感觉。吃完晚饭，在去图书馆的路上，很多看法有了改变，无论你选择的道路多么不可知，无论其他人怎么指指点点，都要给自己一个坚持下去的理由，还是要相信天道酬勤，要大气。 前天，和一个同学聊天，从世界杯谈到中国的教育、制度、腐败，美国的霸权、德意志战车，最终我们落点到当代人的态度，太矫情，追求什么狗屁的唯美，缺少大气、意志与气魄。我和他的观点非常和得来，我一直坚信，倘若在战争年代，他必定有指点江山、指挥百万雄师的能耐。 昨天某某说，&amp;ldquo;感觉都在北京，好像时间却老是对不上&amp;rdquo;，或许吧。我也不再敢有更多的期望,累。以前一直告诫自己期望越大失望越大，终是好了伤疤忘了疼，或许真的越走越远&amp;hellip;&amp;hellip; 你已经确定保研，我还看不到明年的结果。虽然当所有人问我万一跨专业没考上怎么办，我一直很不在意地说不要想考不上之后的打算，我一定会考上，但是心里边其实还是有担心。&lt;span style=&quot;line-height: 1.6em;&quot;&gt;无论怎样，现在什么也不想，&lt;/span&gt;&lt;span style=&quot;line-height: 1.6em;&quot;&gt;全力以赴吧&lt;/span&gt; 23:59 &amp;nbsp; 2014.06.18","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"空20140617","slug":"空20140617","date":"2014-06-17T16:44:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/7788/","link":"","permalink":"http://www.voyax.meposts/7788/","excerpt":"","text":"这个夏天，北京的天气太诡异了！说来就来的阵雨让人发怵。昨晚凌晨3点多被雷声惊醒，黑夜中，一阵阵从未有过的恐慌。躺在床上，挣扎着是否要睁开眼睛，最终索性戴上眼罩，什么也看不见。 黑暗中，一边嘲讽自己竟然会怕打雷（其实，心里边也在嘀咕，不安与恐惧或许来自最近其他的事情），一边又安静地等待着下一个惊雷的到来，这感觉如同等待死亡一次又一次的降临一般&amp;hellip;&amp;hellip;我咋想到《死神来了》。。。我下意识地摸了摸胸口，心脏快而有力的跳动着，不安中，我努力去想爷爷、奶奶、妈、爸、还有小二妹。上了大三，越来越觉得和家里边的人打电话，逗小二妹是件多么奢侈幸福的事情。 恍惚中，听到了该死的闹铃，摸索到手机后，意识模糊下，竟然成功关掉了闹钟。终于，还是在不安与愧疚中，决定起床。一看时间，尼玛！7点50了！又要迟到了！不刷牙、不洗脸，连厕所都来不及上，慌忙背上书包塞上拖鞋冲出宿舍。 结果，还是迟到了&amp;hellip;&amp;hellip; 最后一节课，人还是这么少，和我一起飞奔过去的另外一个同学，以极犀利的目光快速扫描了一遍教室，然后超得意地对我说，&amp;ldquo;36个。&amp;rdquo; 两个小时的课还是这么无聊，我自己看自己的宏观经济学，一大早来上这破课，就为了听最后的考试情报，签个到。真他妹的恶心 最近我发现越来越接不上别人的话了，看来以后该去吃早饭了，此处省略800字【NOTEBOOK】 本打算今天早睡，明天早点去图书馆占座，又泡汤了。。。 来讲个笑话 有一天，牛顿、爱因斯坦和帕斯卡（都是著名物理学家）在玩捉迷藏。当爱因斯坦数完十后发现牛顿正站在他面前一动不动。他于是抓住牛顿说我抓到你了。牛顿说没有，然后指指脚下。牛顿说你看，我正站在边长一米的方形面积上所以是牛顿每平方米。所以你抓到的不是牛顿而是帕斯卡。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"偶然发现，这不过是末日的狂欢","slug":"偶然发现，这不过是末日的狂欢","date":"2014-06-13T09:10:36.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/39148/","link":"","permalink":"http://www.voyax.meposts/39148/","excerpt":"","text":"","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"毕业季","slug":"毕业季","date":"2014-06-11T03:22:51.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/27865/","link":"","permalink":"http://www.voyax.meposts/27865/","excerpt":"","text":"最近一直忙各种考试各种乱七八糟的事，很多天没有写博客了。 9号的时候，石联系我说当天收书的情况的时候，突然意识到，又一批高三的学生毕业了，三年前，我也和他们一样 兴奋、疯狂、期待 以现在的视角去审视三年前的疯狂，&lt;span style=&quot;line-height: 1.6em;&quot;&gt;可以理解但缺少理性&lt;/span&gt; 高考确实给人有特别特别的感受 但特别并不等同价值 高考对大多数人来说都是很重要的 可惜我们仅仅能赋予它&amp;ldquo;重要&amp;rdquo;这个词 就像高中作文，摇旗呐喊&amp;ldquo;坚强&amp;rdquo;、&amp;ldquo;感恩&amp;rdquo;&amp;hellip;&amp;hellip; 你明白吗？&amp;mdash;&amp;mdash;明白 你真的懂吗？&amp;mdash;&amp;mdash;不知道 高考的结束，就像突然讲一个大蒸笼突然被掀开 我们就是那些水雾，欢腾而出 然后，然后，消失 现实与我们日日夜夜期待的，似乎不那么回事 其实倒也没什么不对，毕竟年少 年少轻狂或许是我们很好的安慰 这段时间也看到很多穿着学士服的学长学姐 打开QQ，突然想起和我在同一大学的也是津中的两个学长和学姐 学姐的QQ签名是 &lt;span style=&quot;color:#FF8C00;&quot;&gt;_&amp;ldquo;蓝桥春雪君归日，秦岭秋风我去时。&amp;rdquo;_&lt;/span&gt; 学长qq上有个很长的个人说明 &ldquo;桥过水流深处 屋外有一片枫树林 战火硝烟弥漫 过了今夜我要远行&lt;/span&gt; &lt;span style=&quot;color:#FF8C00;&quot;&gt;你摘下黄色枫叶 证明我在秋天离开 我答应你会回来 当红色枫叶再开成海&lt;/span&gt; &lt;span style=&quot;color:#FF8C00;&quot;&gt;秋风掠过战场深爱的人两散 我握着希望冲出重围&lt;/span&gt; &lt;span style=&quot;color:#FF8C00;&quot;&gt;我知道你的眼泪早已流成海&lt;/span&gt; &lt;span style=&quot;color:#FF8C00;&quot;&gt;&amp;rdquo;&lt;/span&gt; 大四才是真正地毕业季 依旧年少，但或多或少已经有了真正属于自己的梦想 守住本性，启航 附上6月5号因为某事写的送给高三的话，这也是我高三最后阶段时常激励自己的话： ![面壁十年图破壁，难酬蹈海亦英雄](http://lhyun-wordpress.qiniudn.com/%E6%AF%95%E4%B8%9A%E5%AD%A3.png) 寒假回去翻了翻高中的笔记本，里边有一首高三班主任读给我们的诗： # 放榜的日子 &lt;span style=&quot;color:#2F4F4F;&quot;&gt;人生就是在一大榜上&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;榜上有名的不一定必将欢笑&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;榜上无名的不一定必将哀伤&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;落地的麦子会长出新芽&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;盛开的花朵都将枯萎&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;得意两忘的人永远及格&lt;/span&gt; &lt;span style=&quot;color:#2F4F4F;&quot;&gt;早晨与黄昏各有短处&lt;/span&gt; &amp;nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"自己动手修鼠标滚轮","slug":"自己动手修鼠标滚轮","date":"2014-06-05T12:30:13.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/13118/","link":"","permalink":"http://www.voyax.meposts/13118/","excerpt":"","text":"前几天无线鼠标滚轮出问题了，在浏览页面滚动的时候控制不住，页面上下滑动。换了个三十几块钱的便宜鼠标，结果用了两天，真的是便宜没好货，太难用了！只好把无线鼠标拿出来，自己修理。来贴贴修理过程： 这是未拆之前的鼠标： ![自修鼠标滚轮——未拆之前](http://lhyun-wordpress.qiniudn.com/%E8%87%AA%E4%BF%AE%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE1.png) &lt;span style=&quot;line-height: 1.6em;&quot;&gt;拆开鼠标：&lt;/span&gt; &lt;span style=&quot;line-height: 1.6em;&quot;&gt;![自修鼠标滚轮——拆鼠标](http://lhyun-wordpress.qiniudn.com/%E8%87%AA%E4%BF%AE%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE2.jpg)&lt;/span&gt; 其实只是把壳打开了。。。把螺丝拧开，就可以真正看到内部结构了： ![自修鼠标滚轮——内部结构](http://lhyun-wordpress.qiniudn.com/%E8%87%AA%E4%BF%AE%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE3.png) ![自修鼠标滚轮——内部结构](http://lhyun-wordpress.qiniudn.com/%E8%87%AA%E4%BF%AE%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE4.png) 这不是略简单&amp;hellip;看见那个卡轴了吗，鼠标滚轮是有一根轴带动旋转的，而这根轴是插在这里边的，所以我鼠标的问题就是这儿了。我把两边的金属片夹紧（没有工具，牙齿咬的），同时把滚轮抽了出来，在轴上加了点502，防止打滑。 然后，鼠标完美复活啦，哈哈哈哈哈哈哈哈哈","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"爸，妈，祝好","slug":"爸，妈，祝好","date":"2014-05-30T15:51:22.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/62954/","link":"","permalink":"http://www.voyax.meposts/62954/","excerpt":"","text":"小二妹今天开心得很，妈给我打电话的时候，抢着要和我说，&amp;ldquo;今天六一儿童节，我去跳舞了&amp;rdquo;，&amp;ldquo;今天妈妈和爸爸都买了新衣服的&amp;rdquo;，&amp;ldquo;我今天吃了粽子和鱼的&amp;rdquo;，&amp;ldquo;八减八等于零&amp;rdquo;，&amp;quot;你的电话号码是xxx&amp;quot;&amp;hellip;&amp;hellip;妈妈只好在一边教二妹说，叫你哥哥吃粽子，吃好点，钱不够了去爸的卡里转&amp;hellip;&amp;hellip; 今天真的很想哭一场，但自己应该学会坚强 任何时候，唯有努力与强大才是最有力的回击 从此再不提起过去，痛苦或幸福 从图书馆回来接到妈妈的电话，心情好很多 过两天就端午了，爸，妈，别太辛苦了，注意身体 小二妹，你也要听话，早上不要老迟到 爸，妈，爷爷，奶奶，外公，外婆，祝好~ ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D1.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D2.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D3.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D4.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D5.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D6.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D7.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D8.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-9.jpg) ![父母](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-10.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-11.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-12.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-13.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-14.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-15.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-16.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-17.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-18.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-19.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-20.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-21.jpg) ![](http://lhyun-wordpress.qiniudn.com/%E7%88%B6%E6%AF%8D-22.jpg) &amp;nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"该忘记的早就忘记，该留下的永远留下","slug":"该忘记的早就忘记，该留下的永远留下","date":"2014-05-30T15:11:19.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/62788/","link":"","permalink":"http://www.voyax.meposts/62788/","excerpt":"","text":"该忘记的早就忘记 该留下的永远留下。 答应我，忍住你的痛苦，不发一言，穿过这整座城市。 &amp;mdash;&amp;mdash;海子《太阳和野花》&amp;nbsp; ![forget](http://lhyun-wordpress.qiniudn.com/forget.jpg) 我们总笑得比谁都开心 当所有人潮散去 我们比谁都落寂 暗透了，更能看得见星光 &amp;nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"Web前端自学书籍推荐","slug":"web前端自学书籍推荐","date":"2014-05-27T19:56:16.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/11649/","link":"","permalink":"http://www.voyax.meposts/11649/","excerpt":"","text":"推荐几本很不错的前端书籍，方便自学者快速入门并精通前段。 先说一下什么是前端，前端开发需要学习哪些东西。国内前端的起步较晚，也是最近四五年的时间前端开始得到重视，前几年甚至现在仍有不少人对前端怀有歧视。如果有人认为前端缺少技术，随便一个半路出家的人也可以轻松搞定前端，那么这个人一定不能算是一个前端工程师。需要强调的是前端其实也是需要扎实的计算机基础的，所以不要有速成的想法。。 去阿里实习，那个时候对于前端顶多算是入门，当时面试官问我前端应该学哪些东西，我还很自信地说最基本的是HTML，CSS，JS，同时也需要掌握后端的开发语言以及数据库、网络方面的知识。但是在终面的时候，彻底傻眼，算法、网络、操作系统、逻辑题应有尽有，而据我后来了解，大公司的前端基本都是这个节奏，你需要有全栈工程师的追求。 废话说了一大推，进入正题，这里我只是从希望对前端有大致了解或者说入门的角度推荐书籍，高手绕道： 1.Web前段快速入门——w3school w3school网站，这是自学者最快上手的教程，简单明了，相比枯燥死板的书，w3school的教程绝对实用有趣。花个半天的时间好好学习吧。 &nbsp; 2. 进阶——《编写高质量代码——WEB前端开发修炼之道》 &nbsp; W3shool上的教程虽然已经很不错了，但存在两个较大问题，一是细节不够深入，知识点太浅；二是读者难以通过它很好的理解整体的思路框架，难以形成 系统的知识体系。所以看完W3school上的东西还远远不够。 《编写高质量代码——WEB前端开发修炼之道》是我所看的前端的书中自认为写得最好的一本书，书中内容涉及网页整体框架设计，HTML，CSS，Javascript，而且讲解相当详细实用，我相信若你好好看，书中很多内容一定会让你有醍醐灌顶的感觉。 下载地址：http://pan.baidu.com/s/1bnCf1BT 3.深入——《JavaScript权威指南》+《CSS权威指南》前端必读书籍。 如果你认为前端没有编程技术含量，那么只能说你还没入门。好好去学习JS，尝试写一段让自己自豪的脚本。《JavaScript权威指南（第6版）》主要讲述的内容涵盖JavaScript语言本身，以及Web浏览器所实现的JavaScript API，同时第六版涵盖了HTML5和ECMAScript 5，而且还包括jQuery、服务器端JavaScript、图形编程以及 JavaScript式的面向对象。 认真读《CSS权威指南》这本书可以帮你解决以前很多CSS奇葩现象，对于CSS的讲解非常透彻，既可作为参考手册也可作为实践参考。 一定要自己敲代码！ 下载地址：http://pan.baidu.com/s/1o6G2Lv0 4.深入——《HTML5与CSS3权威指南》 比较惭愧，我现在没有认真读过一本H5的书籍，但HTML5是前端必须掌握的新东西（其实很早就踢出来了），先来这本书吧，中规中矩的一本，但我实在受不了作者的风格…… 下载地址：http://pan.baidu.com/s/1mg9fpSO &nbsp; 其实计算机的东西最实际的还是要自己编代码，所以当自己看得差不多了，不妨仿照网易或者新浪首页自己模仿，看能不能很轻松的实现。另外，强烈不建议用DreamWeaver,写静态的页面一个文本编辑器就足够了！ 5.SEO——《seo实战密码:60天网站流量提高20倍》 什么是SEO—— SEO（Search Engine Optimization）:汉译为搜索引擎优化。搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。 虽说网站内容为王，但良好的SEO会让你的网站有意想不到的流量与排名。国内讲SEO的书不多，而且鱼龙混杂，你百度一搜SEO，会发现大量广告！我推荐一本Zac的书《seo实战密码:60天网站流量提高20倍》，对SEO稍有了解的人应该或多或少听说过Zac和他的这本经典之作吧。 SEO看似简单，但是并不那么好做，需要花费大量时间和精力。我这个博客SEO就做得很烂，但是因为时间等原因，一直没有着手改善…… 下载地址：http://pan.baidu.com/s/1bnlbh19 以上的书籍仅是我自学前端过程中觉得写得还是很不错的，欢迎各位补上其他好书，共同进步~","categories":[{"name":"资料","slug":"资料","permalink":"http://www.voyax.me/categories/资料/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"最困难的不是生活给了你多少压迫，而是任何时候都能保持微笑","slug":"最困难的不是生活给了你多少压迫，而是任何时候","date":"2014-05-20T18:32:29.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/13406/","link":"","permalink":"http://www.voyax.meposts/13406/","excerpt":"","text":"两三天前就想写这篇文章，但是一直没有静下心，整理思路，但现在其实也还是如此，本想竭力将近几天的一些想法写得优雅，但基于各种原因，这终究是不能实现了，为了避免自己很快忘掉这些东西，还是先将它们简单记录下来吧。学会微笑。 最近心情一直很不好，周日晚上在学校外边的&amp;ldquo;地沟油一条街&amp;rdquo;买晚饭，在等的时候，却发现这些大大小小的商贩，有说有笑。这些小贩绝大多数都不是北京当地人，虽然在学校这块生意不算太差，但以北京的生活水平，一个外地的打工者，在北京还是挺辛苦和艰辛的，但这点不应该是同情他们的理由。各行各业都有各自的辛苦，对于大多数人来说，要想谋取更多的收入，还是需要付出很多，所以我从不会同情那些抱怨工作压力大、加班熬夜的人。但是很多次看到校门口的这些小贩，都感觉很痛却又很温暖。 我们都是在异地他乡拼搏的人，只是方式不同罢了，自己越来越喜欢北漂这个词，卑微而坚韧，正如那坚韧的芦苇，&amp;quot;没有华丽的花冠，亦无醉人的芳香，你就是那么淡淡的屹立着，带着孱弱身躯对抗着一切的侵袭，你在脆弱与坚强中徘徊，你在孤独与喧嚣中摇摆，你看似飘忽不定，却从未迷失。你从柔弱中焕发出无穷的韧性，那种连自己都恐怕没有意识到的坚韧，把人感染。尽管在芦花绽放后，你即知难逃悲凉的宿命，然而你却并不忧伤，也没有彷徨，你坚毅倔强的直立在寒冬，因为你明白，暂时的摇摆和痛苦是对新生命的孕育。尽管寒风凛冽，你毫无惧意。&amp;quot;只是与芦苇不同的是，它们是一群，而你只有自己，在北京，没有亲人亦没有真正的朋友，再痛，也是自己一个人承担。很多话是不能和家人说的，没有理由让他们再操心了。每当自己心情不好时，会绝望的发现连个发泄的方式都没有&amp;hellip;&amp;hellip;但是，我想以前真的是忘记了微笑。周日那天看见那些卖水果卖炒饭的小贩，当雨滴稀稀散散掉下，大多数人都仓促往往回赶时，他们还很淡定地卖自己的东西，说说笑笑。我想，他们的生活或许不比我们好吧，在他们那个年龄，远离家乡，漂泊在北京，与父母孩子分隔两地，那是怎样的无奈与艰辛，但从他们的身上却始终能感觉到那种豁达与爽朗。在这样的环境下，还能依旧保持这份乐观，是很让人敬佩的。 无论前方多难，都要保持微笑。不再奢望在困境中有人能拉自己一把，也不再奢望他人的同情，坚持、微笑、相信自己 就已足够 Come on！","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"学习习近平总书记2014年5月4日在北京大学讲话精神","slug":"学习习近平总书记2014年5月4日在北京大学讲话精神","date":"2014-05-19T13:43:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/39407/","link":"","permalink":"http://www.voyax.meposts/39407/","excerpt":"","text":"以这样的方式去&ldquo;学习&rdquo;习总书记五四在北大的讲话想必还是极好的吧，许久没有接触过我们曾无比崇尚的各种道德与精神，以至于看到&ldquo;爱国、进步、民主、科学&rdquo;时，不禁感到可笑、可耻和些许躁动。小时候很喜欢周总理的&ldquo;为中华之崛起而读书&rdquo;，虽不明白具体含义，但为自己的国家感到自豪，那时候有一种感觉，&ldquo;争气&rdquo;！长大一点，喜欢梁启超的《少年中国说》，&ldquo;少年智则国智，少年富则国富；少年强则国强，少年独立则国独立；少年自由则国自由，少年进步则国进步；少年胜于欧洲则国胜于欧洲，少年雄于地球则国雄于地球。&rdquo;我想任何一个中国人读到这一段都会热血沸腾的吧。然而，如果说我们大一大二的时候还有理想，那我们现在绝大多数人脑子里只有工作与挣钱，习总书记在讲话中提到广大青年要在&ldquo;勤学&rdquo;、&ldquo;修得&rdquo;，&ldquo;明辨&rdquo;，&ldquo;笃实&rdquo;上下功夫，其实很实在，而这些本应当都是当代青年的基本素质，但可悲的是随着受教育程度的增长，这些东西似乎与我们越离越远，在今天以数据这个硬指标说话的社会，道德什么的软指标几乎被忽略。我们这些大学生应该反思，但同时我们大学至上而下的教育体系更值得反思，有个成语叫&ldquo;上行下效&rdquo;。 苟学者在虚伪的大学中，会依稀看到微茫的希望；真的大学生，将更奋然而前行。 附上2014年5月4日习总书记的讲话内容 青年要自觉践行社会主义核心价值观 &amp;mdash;&amp;mdash;在北京大学师生座谈会上的讲话 习近平 各位同学，各位老师，同志们： 今天是五四青年节，很高兴来到北京大学同大家见面，共同纪念五四运动95周年。首先，我代表党中央，向北京大学全体师生员工，向全国各族青年，致以节日的问候！向全国广大教育工作者和青年工作者，致以崇高的敬意！ 刚才，朱善璐同志汇报了学校工作情况，几位同学、青年教师分别作了发言，大家讲得都很好，听后很受启发。这是我到中央工作以后第五次到北大，每次来都有新的体会。在洋溢着青春活力的校园里一路走来，触景生情，颇多感慨。我感到，当代大学生是可爱、可信、可贵、可为的。 五四运动形成了爱国、进步、民主、科学的五四精神，拉开了中国新民主主义革命的序幕，促进了马克思主义在中国的传播，推动了中国共产党的建立。五四运动以来，在中国共产党领导下，一代又一代有志青年&amp;ldquo;以青春之我，创建青春之家庭，青春之国家，青春之民族，青春之人类，青春之地球，青春之宇宙&amp;rdquo;，在救亡图存、振兴中华的历史洪流中谱写了一曲曲感天动地的青春乐章。 北京大学是新文化运动的中心和五四运动的策源地，是这段光荣历史的见证者。长期以来，北京大学广大师生始终与祖国和人民共命运、与时代和社会同前进，在各条战线上为我国革命、建设、改革事业作出了重要贡献。 党的十八大提出了&amp;ldquo;两个一百年&amp;rdquo;奋斗目标。我说过，现在，我们比历史上任何时期都更接近实现中华民族伟大复兴的目标，比历史上任何时期都更有信心、更有能力实现这个目标。 行百里者半九十。距离实现中华民族伟大复兴的目标越近，我们越不能懈怠、越要加倍努力，越要动员广大青年为之奋斗。 光阴荏苒，物换星移。时间之河川流不息，每一代青年都有自己的际遇和机缘，都要在自己所处的时代条件下谋划人生、创造历史。青年是标志时代的最灵敏的晴雨表，时代的责任赋予青年，时代的光荣属于青年。 广大青年对五四运动的最好纪念，就是在党的领导下，勇做走在时代前列的奋进者、开拓者、奉献者，以执着的信念、优良的品德、丰富的知识、过硬的本领，同全国各族人民一道，担负起历史重任，让五四精神放射出更加夺目的时代光芒。 同学们、老师们！ 大学是一个研究学问、探索真理的地方，借此机会，我想就社会主义核心价值观问题，同各位同学和老师交流交流想法。 我想讲这个问题，是从弘扬五四精神联想到的。五四精神体现了中国人民和中华民族近代以来追求的先进价值观。爱国、进步、民主、科学，都是我们今天依然应该坚守和践行的核心价值，不仅广大青年要坚守和践行，全社会都要坚守和践行。 人类社会发展的历史表明，对一个民族、一个国家来说，最持久、最深层的力量是全社会共同认可的核心价值观。核心价值观，承载着一个民族、一个国家的精神追求，体现着一个社会评判是非曲直的价值标准。 古人说：&amp;ldquo;大学之道，在明明德，在亲民，在止于至善。&amp;rdquo;核心价值观，其实就是一种德，既是个人的德，也是一种大德，就是国家的德、社会的德。国无德不兴，人无德不立。如果一个民族、一个国家没有共同的核心价值观，莫衷一是，行无依归，那这个民族、这个国家就无法前进。这样的情形，在我国历史上，在当今世界上，都屡见不鲜。 我国是一个有着13亿多人口、56个民族的大国，确立反映全国各族人民共同认同的价值观&amp;ldquo;最大公约数&amp;rdquo;，使全体人民同心同德、团结奋进，关乎国家前途命运，关乎人民幸福安康。 每个时代都有每个时代的精神，每个时代都有每个时代的价值观念。国有四维，礼义廉耻，&amp;ldquo;四维不张，国乃灭亡。&amp;rdquo;这是中国先人对当时核心价值观的认识。在当代中国，我们的民族、我们的国家应该坚守什么样的核心价值观？这个问题，是一个理论问题，也是一个实践问题。经过反复征求意见，综合各方面认识，我们提出要倡导富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善，积极培育和践行社会主义核心价值观。富强、民主、文明、和谐是国家层面的价值要求，自由、平等、公正、法治是社会层面的价值要求，爱国、敬业、诚信、友善是公民层面的价值要求。这个概括，实际上回答了我们要建设什么样的国家、建设什么样的社会、培育什么样的公民的重大问题。 中国古代历来讲格物致知、诚意正心、修身齐家、治国平天下。从某种角度看，格物致知、诚意正心、修身是个人层面的要求，齐家是社会层面的要求，治国平天下是国家层面的要求。我们提出的社会主义核心价值观，把涉及国家、社会、公民的价值要求融为一体，既体现了社会主义本质要求，继承了中华优秀传统文化，也吸收了世界文明有益成果，体现了时代精神。 富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善，传承着中国优秀传统文化的基因，寄托着近代以来中国人民上下求索、历经千辛万苦确立的理想和信念，也承载着我们每个人的美好愿景。我们要在全社会牢固树立社会主义核心价值观，全体人民一起努力，通过持之以恒的奋斗，把我们的国家建设得更加富强、更加民主、更加文明、更加和谐、更加美丽，让中华民族以更加自信、更加自强的姿态屹立于世界民族之林。 建设富强民主文明和谐的社会主义现代化国家，实现中华民族伟大复兴，是鸦片战争以来中国人民最伟大的梦想，是中华民族的最高利益和根本利益。今天，我们13亿多人的一切奋斗归根到底都是为了实现这一伟大目标。中国曾经是世界上的经济强国，后来在世界工业革命如火如荼、人类社会发生深刻变革的时期，中国丧失了与世界同进步的历史机遇，落到了被动挨打的境地。尤其是鸦片战争之后，中华民族更是陷入积贫积弱、任人宰割的悲惨状况。这段历史悲剧决不能重演！建设富强民主文明和谐的社会主义现代化国家，是我们的目标，也是我们的责任，是我们对中华民族的责任，对前人的责任，对后人的责任。我们要保持战略定力和坚定信念，坚定不移走自己的路，朝着自己的目标前进。 中国已经发展起来了，我们不认可&amp;ldquo;国强必霸&amp;rdquo;的逻辑，坚持走和平发展道路，但中华民族被外族任意欺凌的时代已经一去不复返了！为什么我们现在有这样的底气？就是因为我们的国家发展起来了。现在，中国的国际地位不断提高、国际影响力不断扩大，这是中国人民用自己的百年奋斗赢得的尊敬。想想近代以来中国丧权辱国、外国人在中国横行霸道的悲惨历史，真是形成了鲜明对照！ 中华文明绵延数千年，有其独特的价值体系。中华优秀传统文化已经成为中华民族的基因，植根在中国人内心，潜移默化影响着中国人的思想方式和行为方式。今天，我们提倡和弘扬社会主义核心价值观，必须从中汲取丰富营养，否则就不会有生命力和影响力。比如，中华文化强调&amp;ldquo;民惟邦本&amp;rdquo;、&amp;ldquo;天人合一&amp;rdquo;、&amp;ldquo;和而不同&amp;rdquo;，强调&amp;ldquo;天行健，君子以自强不息&amp;rdquo;、&amp;ldquo;大道之行也，天下为公&amp;rdquo;；强调&amp;ldquo;天下兴亡，匹夫有责&amp;rdquo;，主张以德治国、以文化人；强调&amp;ldquo;君子喻于义&amp;rdquo;、&amp;ldquo;君子坦荡荡&amp;rdquo;、&amp;ldquo;君子义以为质&amp;rdquo;；强调&amp;ldquo;言必信，行必果&amp;rdquo;、&amp;ldquo;人而无信，不知其可也&amp;rdquo;；强调&amp;ldquo;德不孤，必有邻&amp;rdquo;、&amp;ldquo;仁者爱人&amp;rdquo;、&amp;ldquo;与人为善&amp;rdquo;、&amp;ldquo;己所不欲，勿施于人&amp;rdquo;、&amp;ldquo;出入相友，守望相助&amp;rdquo;、&amp;ldquo;老吾老以及人之老，幼吾幼以及人之幼&amp;rdquo;、&amp;ldquo;扶贫济困&amp;rdquo;、&amp;ldquo;不患寡而患不均&amp;rdquo;，等等。像这样的思想和理念，不论过去还是现在，都有其鲜明的民族特色，都有其永不褪色的时代价值。这些思想和理念，既随着时间推移和时代变迁而不断与时俱进，又有其自身的连续性和稳定性。我们生而为中国人，最根本的是我们有中国人的独特精神世界，有百姓日用而不觉的价值观。我们提倡的社会主义核心价值观，就充分体现了对中华优秀传统文化的传承和升华。 价值观是人类在认识、改造自然和社会的过程中产生与发挥作用的。不同民族、不同国家由于其自然条件和发展历程不同，产生和形成的核心价值观也各有特点。一个民族、一个国家的核心价值观必须同这个民族、这个国家的历史文化相契合，同这个民族、这个国家的人民正在进行的奋斗相结合，同这个民族、这个国家需要解决的时代问题相适应。世界上没有两片完全相同的树叶。一个民族、一个国家，必须知道自己是谁，是从哪里来的，要到哪里去，想明白了、想对了，就要坚定不移朝着目标前进。 去年12月26日，我在纪念毛泽东同志诞辰120周年座谈会上讲话时说：站立在960万平方公里的广袤土地上，吸吮着中华民族漫长奋斗积累的文化养分，拥有13亿中国人民聚合的磅礴之力，我们走自己的路，具有无比广阔的舞台，具有无比深厚的历史底蕴，具有无比强大的前进定力。中国人民应该有这个信心，每一个中国人都应该有这个信心。我们要虚心学习借鉴人类社会创造的一切文明成果，但我们不能数典忘祖，不能照抄照搬别国的发展模式，也绝不会接受任何外国颐指气使的说教。 我说这话的意思是，实现我们的发展目标，实现中国梦，必须增强道路自信、理论自信、制度自信，&amp;ldquo;千磨万击还坚劲，任尔东南西北风&amp;rdquo;。而这&amp;ldquo;三个自信&amp;rdquo;需要我们对核心价值观的认定作支撑。 我为什么要对青年讲讲社会主义核心价值观这个问题？是因为青年的价值取向决定了未来整个社会的价值取向，而青年又处在价值观形成和确立的时期，抓好这一时期的价值观养成十分重要。这就像穿衣服扣扣子一样，如果第一粒扣子扣错了，剩余的扣子都会扣错。人生的扣子从一开始就要扣好。&amp;ldquo;凿井者，起于三寸之坎，以就万仞之深。&amp;rdquo;青年要从现在做起、从自己做起，使社会主义核心价值观成为自己的基本遵循，并身体力行大力将其推广到全社会去。 广大青年树立和培育社会主义核心价值观，要在以下几点上下功夫。 一是要勤学，下得苦功夫，求得真学问。知识是树立核心价值观的重要基础。古希腊哲学家说，知识即美德。我国古人说：&amp;ldquo;非学无以广才，非志无以成学&amp;rdquo;大学的青春时光，人生只有一次，应该好好珍惜。为学之要贵在勤奋、贵在钻研、贵在有恒。鲁迅先生说过：&amp;ldquo;哪里有天才，我是把别人喝咖啡的工夫都用在工作上的。&amp;rdquo;大学阶段，&amp;ldquo;恰同学少年，风华正茂&amp;rdquo;，有老师指点，有同学切磋，有浩瀚的书籍引路，可以心无旁骛求知问学。此时不努力，更待何时？要勤于学习、敏于求知，注重把所学知识内化于心，形成自己的见解，既要专攻博览，又要关心国家、关心人民、关心世界，学会担当社会责任。 二是要修德，加强道德修养，注重道德实践。&amp;ldquo;德者，本也。&amp;rdquo;蔡元培先生说过：&amp;ldquo;若无德，则虽体魄智力发达，适足助其为恶。&amp;rdquo;道德之于个人、之于社会，都具有基础性意义，做人做事第一位的是崇德修身。这就是我们的用人标准为什么是德才兼备、以德为先，因为德是首要、是方向，一个人只有明大德、守公德、严私德，其才方能用得其所。修德，既要立意高远，又要立足平实。要立志报效祖国、服务人民，这是大德，养大德者方可成大业。同时，还得从做好小事、管好小节开始起步，&amp;ldquo;见善则迁，有过则改&amp;rdquo;，踏踏实实修好公德、私德，学会劳动、学会勤俭，学会感恩、学会助人，学会谦让、学会宽容，学会自省、学会自律。 三是要明辨，善于明辨是非，善于决断选择。&amp;ldquo;学而不思则罔，思而不学则殆。&amp;rdquo;是非明，方向清，路子正，人们付出的辛劳才能结出果实。面对世界的深刻复杂变化，面对信息时代各种思潮的相互激荡，面对纷繁多变、鱼龙混杂、泥沙俱下的社会现象，面对学业、情感、职业选择等多方面的考量，一时有些疑惑、彷徨、失落，是正常的人生经历。关键是要学会思考、善于分析、正确抉择，做到稳重自持、从容自信、坚定自励。要树立正确的世界观、人生观、价值观，掌握了这把总钥匙，再来看看社会万象、人生历程，一切是非、正误、主次，一切真假、善恶、美丑，自然就洞若观火、清澈明了，自然就能作出正确判断、作出正确选择。正所谓&amp;ldquo;千淘万漉虽辛苦，吹尽狂沙始到金&amp;rdquo;。 四是要笃实，扎扎实实干事，踏踏实实做人。道不可坐论，德不能空谈。于实处用力，从知行合一上下功夫，核心价值观才能内化为人们的精神追求，外化为人们的自觉行动。《礼记》中说：&amp;ldquo;博学之，审问之，慎思之，明辨之，笃行之。&amp;rdquo;有人说：&amp;ldquo;圣人是肯做工夫的庸人，庸人是不肯做工夫的圣人。&amp;rdquo;青年有着大好机遇，关键是要迈稳步子、夯实根基、久久为功。心浮气躁，朝三暮四，学一门丢一门，干一行弃一行，无论为学还是创业，都是最忌讳的。&amp;ldquo;天下难事，必作于易；天下大事，必作于细。&amp;rdquo;成功的背后，永远是艰辛努力。青年要把艰苦环境作为磨炼自己的机遇，把小事当作大事干，一步一个脚印往前走。滴水可以穿石。只要坚韧不拔、百折不挠，成功就一定在前方等你。 核心价值观的养成绝非一日之功，要坚持由易到难、由近及远，努力把核心价值观的要求变成日常的行为准则，进而形成自觉奉行的信念理念。不要顺利的时候，看山是山、看水是水，一遇挫折，就怀疑动摇，看山不是山、看水不是水了。无论什么时候，我们都要坚守在中国大地上形成和发展起来的社会主义核心价值观，在时代大潮中建功立业，成就自己的宝贵人生。 同学们、老师们！ 党中央作出了建设世界一流大学的战略决策，我们要朝着这个目标坚定不移前进。办好中国的世界一流大学，必须有中国特色。没有特色，跟在他人后面亦步亦趋，依样画葫芦，是不可能办成功的。这里可以套用一句话，越是民族的越是世界的。世界上不会有第二个哈佛、牛津、斯坦福、麻省理工、剑桥，但会有第一个北大、清华、浙大、复旦、南大等中国著名学府。我们要认真吸收世界上先进的办学治学经验，更要遵循教育规律，扎根中国大地办大学。 鲁迅先生说：&amp;ldquo;北大是常为新的，改进的运动的先锋，要使中国向着好的，往上的道路走。&amp;rdquo;党的十八届三中全会吹响了全面深化改革的号角，也对深化我国高等教育改革提出了明确要求。现在，关键是把蓝图一步步变为现实。全国高等院校要走在教育改革前列，紧紧围绕立德树人的根本任务，加快构建充满活力、富有效率、更加开放、有利于学校科学发展的体制机制，当好教育改革排头兵。我也希望北京大学通过埋头苦干和改革创新，早日实现几代北大人创建世界一流大学的梦想。 教师承担着最庄严、最神圣的使命。梅贻琦先生说：&amp;ldquo;所谓大学者，非谓有大楼之谓也，有大师之谓也。&amp;rdquo;我体会，这样的大师，既是学问之师，又是品行之师。教师要时刻铭记教书育人的使命，甘当人梯，甘当铺路石，以人格魅力引导学生心灵，以学术造诣开启学生的智慧之门。 各级党委和政府要高度重视高校工作，始终关心和爱护学生成长，为他们放飞青春梦想、实现人生出彩搭建舞台。要全面深化改革，营造公平公正的社会环境，促进社会流动，不断激发广大青年的活力和创造力。要强化就业创业服务体系建设，支持帮助学生们迈好走向社会的第一步。各级领导干部要经常到学生们中去、同他们交朋友，听取他们的意见和建议。 现在在高校学习的大学生都是20岁左右，到2020年全面建成小康社会时，很多人还不到30岁；到本世纪中叶基本实现现代化时，很多人还不到60岁。也就是说，实现&amp;ldquo;两个一百年&amp;rdquo;奋斗目标，你们和千千万万青年将全过程参与。有信念、有梦想、有奋斗、有奉献的人生，才是有意义的人生。当代青年建功立业的舞台空前广阔、梦想成真的前景空前光明，希望大家努力在实现中国梦的伟大实践中创造自己的精彩人生。 我相信，当代中国青年一定能够担当起党和人民赋予的历史重任，在激扬青春、开拓人生、奉献社会的进程中书写无愧于时代的壮丽篇章！","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"DNS采用TCP和UDP传输层协议","slug":"dns采用tcp和udp传输层协议","date":"2014-05-18T05:17:14.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/9431/","link":"","permalink":"http://www.voyax.meposts/9431/","excerpt":"","text":"DNS同时占用UDP和TCP端口53是公认的，这种单个应用协议同时使用两种传输协议的情况在TCP/IP栈也算是个另类。但很少有人知道DNS分别在什么情况下使用这两种协议。&nbsp; &nbsp; # 1.先简单介绍下TCP与UDP。&amp;nbsp; &nbsp; &nbsp; TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。UDP—用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。&nbsp; # 2.TCP与UDP的区别：&amp;nbsp; &nbsp; &nbsp; &nbsp; UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与TCP不同，UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP协议称为不可靠的传输协议。相对于TCP协议，UDP协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于TCP，UDP并不能确保数据的发送和接收顺序。事实上，UDP协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生。&nbsp; &nbsp; &nbsp; &nbsp; 既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？其实不然，在有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。&nbsp; &nbsp; # 3.DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；&amp;nbsp; &nbsp; &nbsp; &nbsp; DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。&nbsp; &nbsp; # 4.为什么既使用TCP又使用UDP？&amp;nbsp; 首先了解一下TCP与UDP传送字节的长度限制：&nbsp; &nbsp; &nbsp;UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。&nbsp; 区域传送时使用TCP，主要有一下两点考虑：&nbsp; 1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。&nbsp; 2.TCP是一种可靠的连接，保证了数据的准确性。&nbsp; &nbsp; 域名解析时使用UDP协议：&nbsp; &nbsp; 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 &nbsp; * 原文转自：http://www.2cto.com/net/201206/137153.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"传输层","slug":"传输层","permalink":"http://www.voyax.me/tags/传输层/"},{"name":"网络","slug":"网络","permalink":"http://www.voyax.me/tags/网络/"}]},{"title":"x86汇编指​令​与​寻​址​方​式​习​题​与解答","slug":"x86汇编指​令​与​寻​址​方​式​习​题​与","date":"2014-05-15T14:37:26.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/12433/","link":"","permalink":"http://www.voyax.meposts/12433/","excerpt":"","text":"1.&nbsp;**假定（BX）=637DH，（SI）=2A9BH，位移量D=3237H，试确定在以下各种寻址方式下的有效地址是什么？** **（****1****）立即寻址** **（****2****）直接寻址** **（****3****）使用****BX****的寄存器寻址** **（****4****）使用****BX****的间接寻址** **（****5****）使用****BX****的寄存器相对寻址** **（****6****）基址变址寻址** **（****7****）相对基址变址寻址** **答：**（1）立即数寻址的有效地址是当前IP的内容； （2）直接寻址，若使用位移量D=3237H进行，则有效地址为3237H； （3）使用BX的寄存器寻址时，操作数在BX寄存器中，因此无有效地址； （4）使用BX的间接寻址时，有效地址在BX寄存器中，即有效地址=637DH； （5）使用BX的寄存器相对寻址的有效地址=（BX）+D=637DH+3237H=95B4H； （6）基址变址寻址的有效地址=（BX）+（SI）=637DH+2A9BH=8E18H； （7）相对基址变址寻址的有效地址=（BX）+（SI）+D=C050H； **2.&amp;nbsp;****写出把首地址为****BLOCK****的字数组的第****6****个字送到****DX****寄存器的指令。要求使用以下几种寻址方式：** **（****1****）寄存器间接寻址** **（****2****）寄存器相对寻址** **（****3****）基址变址寻址** **答：**（1）使用寄存器间接寻址，把首地址为BLOCK的字数组的第6个字送到DX寄存器的指令为： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV BX，BLOCK &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ADD BX，12 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV DX，[BX] （2）使用寄存器相对寻址，把首地址为BLOCK的字数组的第6个字送到DX寄存器的指令为： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV BX，BLOCK &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV DX，[BX+12] （3）使用基址变址寻址，把首地址为BLOCK的字数组的第6个字送到DX寄存器的指令为： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV BX，BLOCK &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV SI，12 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV DX，[BX+SI] **3.&amp;nbsp;****现有****(DS)=2000H****，****(BX)=0100H****，****(SI)=0002H****，****(20100H)****＝****12H****，****(20101H)=34H****，****(20102H)=56H****，****(20103H)=78H****，****(21200H)=2AH****，****(21201H)=4CH****，****(21202H)=B7H****，****(21203H)=65H****，试说明下列各条指令执行完后****AX****寄存器的内容。** **（****1****）****MOV&amp;nbsp; AX****，****1200H** **（****2****）****MOV&amp;nbsp; AX****，****BX** **（****3****）****MOV&amp;nbsp; AX****，****[1200H]** **（****4****）****MOV&amp;nbsp; AX****，****[BX]** **（****5****）****MOV&amp;nbsp; AX****，****[BX+1100]** **（****6****）****MOV&amp;nbsp; AX****，****[BX+SI]** **（****7****）****MOV&amp;nbsp; AX****，****[BX+SI+1100]** **答：**（1）指令MOV&amp;nbsp; AX，1200H执行完后AX寄存器的内容为1200H； &amp;nbsp; （2）指令MOV&amp;nbsp; AX，BX执行完后AX寄存器的内容为0100H； &amp;nbsp; （3）指令MOV&amp;nbsp; AX，[1200H]是将从物理地址=（DS）*10H+1200H=21200H开始的两个单元内容送AX，执行完后AX寄存器的内容为4C2AH； &amp;nbsp; （4）指令MOV&amp;nbsp; AX，[BX]是将从物理地址=（DS）*10H+（BX）=20100H开始的两个单元内容送AX，故执行完后AX寄存器的内容为3412H； &amp;nbsp; （5）指令MOV&amp;nbsp; AX，[BX+1100]是将从物理地址=（DS）*10H+（BX）+1100H=21200H开始的两个单元内容送AX，故执行完后AX寄存器的内容为4C2AH； &amp;nbsp; （6）指令MOV&amp;nbsp; AX，[BX+SI]是将从物理地址=（DS）*10H+（BX）+（SI）=20102H开始的两个单元内容送AX，故执行完后AX寄存器的内容为7856H； &amp;nbsp; （7）指令MOV&amp;nbsp; AX，[BX+SI+1100]是将从物理地址=（DS）*10H+（BX）+（SI）+1100H=21202H开始的两个单元内容送AX，故执行完后AX寄存器的内容为65B7H； **4.****假设已知****(DS)=2900H,(ES)=2100H,(SS)=1500H,(SI)=00A0H,(BX)= 0100H****，****(BP)=0010H****，数据段中变量名****VAL****的偏移地址值为****0050H****，试指出下列源操作数字段的寻址方式是什么？其物理地址值是多少？** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****1****）**** MOV AX****，****0ABH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****2****）**** MOV AX****，****BX** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****3****）**** MOV AX****，****[100H]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****4****）**** MOV AX****，****VAL** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****5****）**** MOV AX****，****[BX]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****6****）**** MOV AX****，****ES:[BX]** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****7****）**** MOV AX****，****[BP]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****8****）**** MOV AX****，****[SI]** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****9****）**** MOV AX****，****[BX+10]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****10****）**** MOV AX****，****VAL[BX]** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****11****）**** MOV AX****，****[BX][SI]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****12****）**** MOV AX****，****[BP][SI]** **答：**（1）在指令 MOV AX，0ABH 中，源操作数字段的寻址方式是立即数寻址，其物理地址值=（CS）*10H+（IP）； &amp;nbsp; （2）在指令 MOV AX，BX 中，源操作数字段的寻址方式是寄存器寻址，操作数在BX中，无物理地址； &amp;nbsp; （3）在指令 MOV AX，[100H] 中，源操作数字段的寻址方式是直接寻址，其物理地址值=（DS）*10H+100 =29000H+100H=29100； &amp;nbsp; （4）在指令 MOV AX，VAL 中，源操作数字段的寻址方式是直接寻址，其物理地址值=（DS）*10H+50H =29000H+50H=29050H； &amp;nbsp; （5）在指令 MOV AX，[BX] 中，源操作数字段的寻址方式是寄存器间接寻址，其物理地址值=（DS）*10H +（BX）=29000H+100H=29100H； &amp;nbsp; （6）在指令 MOV AX，ES：[BX] 中，源操作数字段的寻址方式是寄存器间接寻址，其物理地址值=（ES）*10H+（BX）=21000H+100H=21100H； &amp;nbsp; （7）在指令 MOV AX，[BP] 中，源操作数字段的寻址方式是寄存器间接寻址，其物理地址值=（SS）*10H +（BP）=15000H+10H=15010H； &amp;nbsp; （8）在指令 MOV AX，[SI] 中，源操作数字段的寻址方式是寄存器间接寻址，其物理地址值=（DS）*10H +（SI）=29000H+0A0H=290A0H； &amp;nbsp; （9）在指令 MOV AX，[BX+10] 中，源操作数字段的寻址方式是寄存器相对寻址，其物理地址值=（DS）*10H+（BX）+0AH= 29000H+100H+0AH =2910AH； &amp;nbsp; （10）在指令 MOV AX，VAL[BX] 中，源操作数字段的寻址方式是寄存器相对寻址，其物理地址值=（DS）*10H+（BX）+50H= 29000H+100H+50H= 29150H； &amp;nbsp; （11）在指令 MOV AX，[BX][SI] 中，源操作数字段的寻址方式是基址变址寻址，其物理地址值=（DS）*10H+（BX）+（SI） =29000H+100H+0A0H =291A0H； &amp;nbsp; （12）在指令 MOV AX，[BP][SI] 中，源操作数字段的寻址方式是基址变址寻址，其物理地址值=（SS）*10H+（BP）+（SI）=15000H+10H+0A0H =150B0H **5.****分别指出下列指令中的源操作数和目的操作数的寻址方式。** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****1****）****MOV&amp;nbsp; SI****，****200** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****2****）****MOV&amp;nbsp; CX****，****DATA[SI]** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****3****）****ADD&amp;nbsp; AX****，****[BX+DI]** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****4****）****AND&amp;nbsp; AX****，****BX** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****5****）****MOV&amp;nbsp; [SI]****，****AX** &amp;nbsp;&amp;nbsp;&amp;nbsp;**（****6****）****PUSHF** **答：**（1）目的操作数字段的寻址方式是寄存器寻址，源操作数字段的寻址方式是立即数寻址； （2）目的操作数的寻址方式是寄存器寻址，源操作数的寻址方式是寄存器相对寻址； （3）目的操作数的寻址方式是寄存器寻址，源操作数的寻址方式是基址变址寻址； （4）目的操作数的寻址方式是寄存器寻址，源操作数的寻址方式也是寄存器寻址； （5）目的操作数的寻址方式是寄存器间接寻址，源操作数的寻址方式是寄存器寻址； （6）目的操作数的寻址方式是寄存器间接寻址，源操作数的寻址方式是寄存器寻址； **6.****试述指令****MOV AX****，****2010H****和****MOV AX****，****DS:[2010H] ****的区别。** **答：**指令MOV AX，2010H是将立即数2010H送AX寄存器，而指令MOV AX，DS:[2010H]是将DS段有效地址为2010H的两个单元的内容送AX。 **7.****写出以下指令中内存操作数的所在地址。** &amp;nbsp;&amp;nbsp;**（****1****）****MOV AL****，****[BX+5]** &amp;nbsp;&amp;nbsp;**（****2****）****MOV [BP+5]****，****AX** &amp;nbsp;&amp;nbsp;**（****3****）****INC BYTE&amp;nbsp; PTR [SI+3]** &amp;nbsp;&amp;nbsp;**（****4****）****MOV DL****，****ES:[BX+DI****］** &amp;nbsp;&amp;nbsp;**（****5****）****MOV BX****，****[BX+SI+2]** **答：**（1）指令MOV AL，[BX+5]中内存操作数的所在地址=（DS）*10H+（BX）+5； &amp;nbsp; （2）指令MOV [BP+5]，AX中内存操作数的所在地址=（SS）*10H+（BP）+5和（SS）*10H+（BP）+6； &amp;nbsp; （3）指令INC BYTE PTR[SI+3]中内存操作数的所在地址=（DS）+（SI）+3； &amp;nbsp; （4）指令MOV DL，ES:[BX+DI］中内存操作数的所在地址=（ES）*10H+（BX）+（DI）； &amp;nbsp; （5）指令MOV BX，[BX+SI+2]中内存操作数的所在地址=（DS）*10H+（BX）+（SI）+2和（DS）*10H+（BX）+（SI）+3； **8.****判断下列指令书写是否正确，如有错误，指出错在何处并用正确的程序段（一条或多条指令）实现原错误指令****((8)****、****(13)****除外****)****期望实现的操作。** &amp;nbsp;&amp;nbsp;**（****1****）****MOV AL****，****BX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****9****）****MOV ES****，****3278H** &amp;nbsp;&amp;nbsp;**（****2****）****MOV AL****，****SL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****10****）****PUSH AL** &amp;nbsp;&amp;nbsp;**（****3****）****INC [BX]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****11****）****POP [BX]** &amp;nbsp;&amp;nbsp;**（****4****）****MOV 5****，****AL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;****（****12****）****MOV [1A8H]****，****23DH** &amp;nbsp;&amp;nbsp;**（****5****）****MOV [BX]****，****[SI]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****13****）****PUSH IP&amp;nbsp;** &amp;nbsp;&amp;nbsp;**（****6****）****MOV BL****，****F5H&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****14****）****MOV [AX]****，****23DH** &amp;nbsp;&amp;nbsp;**（****7****）****MOV DX****，****2000H&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****15****）****SHL AX****，****5** &amp;nbsp;&amp;nbsp;**（****8****）****POP CS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ****（****16****）****MUL AX****，****BX** **答：**（1）MOV AL,BX 错，源操作数为字类型，目的操作数为字节类型，二者不一致。应改为：MOV AX,BX 或&amp;nbsp; MOV&amp;nbsp; AL,BL ； （2）MOV AL,SL 错，SI寄存器不能分为高8位和低8位使用，即没有SL寄存器。应改为：MOV AX,SI （3）INC [BX]&amp;nbsp; 错，未指定操作数的类型。应改为：INC BYTE PTR [BX]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; （4）MOV 5,AL 错，目的操作数使用了立即数，在指令中一般不允许。应改为：MOV DS:[5],AL&amp;nbsp;&amp;nbsp; （5）MOV [BX],[SI] 错，源操作数和目的操作数均为内存单元，不允许。 应改为：MOV AX,[SI] MOV [BX],AX （6）MOV BL,F5H 错，源操作数错，以A～F开头的数字前应加0。应改为：MOV BL,0F5H （7）MOV DX,2000H 正确。 （8） POP CS 错，不能将栈顶数据弹至CS中。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; （9）MOV ES，3278H 错，立即数不能直接送ES寄存器。应改为：MOV AX,3278H MOV ES,AX （10）PUSH AL 错，栈操作不能按字节进行。应改为：PUSH AX （11）POP [BX] 正确。 （12）MOV [1A8H],23DH 错，源操作数是立即数，目的操作数必须使用寄存器指出。应改为： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV BX，1A8H &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV [BX],23DH （13）PUSH IP&amp;nbsp; 错，不能用IP寄存器做源操作数。 （14）MOV [AX],23DH 错，不能用AX寄存器间接寻址。应改为：MOV BX，AX &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; MOV [BX]，23DH （15）SHL AX,5 错，不能用大于己于1的立即数指出移位位数。应改为： MOV CL，5 SHL AX，CL （16）MUL&amp;nbsp; AX,BX 错，目的操作数AX是隐含的，不能在指令中写出。应改为：MUL BX **9.****设堆栈指针****SP****的初值为****2000H****，****AX=3000H****，****BX=5000H****，试问****:** &amp;nbsp;&amp;nbsp;**（****1****）执行指令****PUSH AX****后**** (SP)=****？** &amp;nbsp;&amp;nbsp;**（****2****）再执行****PUSH BX****及****POP AX****后**** (SP)=****？****(AX)=****？****(BX)=****？** **答：**（1）执行指令PUSH AX后 (SP)=2000H-2=1FFEH; &amp;nbsp; （2）再执行PUSH BX及POP AX后 (SP)=1FFEH, (AX)=5000H, (BX)=5000H **10.****要想完成把****[2000H]****送****[1000H]****中，用指令****:MOV [1000H]****，****[2000H]****是否正确？如果不正确，应用什么方法？** **答：**把[2000H]送[1000H]中，用指令 MOV [1000H]，[2000H]不正确，应改为：MOV AX,[2000H] MOV [1000H],AX **11.****假如想从****200****中减去****AL****中的内容，用****SUB 200****，****AL****是否正确？如果不正确，应用什么方法？** **答：**想从200中减去AL中的内容，用SUB 200，AL不正确，应改为：&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MOV BL,200&amp;nbsp;&amp;nbsp; SUB BL,AL **12****分别写出实现如下功能的程序段** **(1)****双字减法（被减数****7B1D2A79H****，减数****53E2345FH****）。** **(2)****使用移位指令实现一个字乘****18****的运算。** **(3)****使用移位指令实现一个字除以****10****的运算。** **(4)****将****AX****中间****8****位，****BX****低四位，****DX****高四位拼成一个新字。** **(5)****将数据段中以****BX****为偏移地址的连续四个单元的内容颠倒过来** **(6)****将****BX****中的四位压缩****BCD****数用非压缩****BCD****数形式顺序放在****AL****、****BL****、****CL****、****DL****中。** **答：**(1)双字减法的程序段是： &amp;nbsp;MOV AX，2A79H&amp;nbsp;&amp;nbsp; ；被减数的低位字送AX &amp;nbsp;SUB AX，345FH&amp;nbsp;&amp;nbsp; ；低位字相减，结果送AX &amp;nbsp;MOV BX，7B1DH&amp;nbsp;&amp;nbsp; ；被减数的高位字送BX &amp;nbsp;SBB BX，53E2H&amp;nbsp;&amp;nbsp; ；高位字相减处并减去低位字相减产生的借位，结果送BX (2)使用移位指令实现一个字乘18的程序段是： &amp;nbsp;MOV AX，05F7H&amp;nbsp;&amp;nbsp; ；被乘数送AX &amp;nbsp;SHL AX，1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数乘以2，结果在AX中 &amp;nbsp;MOV BX，AX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数乘以2的结果暂存到BX &amp;nbsp;MOV CL，3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数3 &amp;nbsp;SHL AX，CL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数再乘以8（共乘以16），结果在AX中 &amp;nbsp;ADD AX，BX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数再乘以18，结果在AX中 (3)使用移位指令实现一个字除以10的运算，必须将X/10拆分成多项的和，而每一项都应是非的某次幂的倒数。利用等比级数的前N项和公式，可求出A0=X/8，公比Q=-1/4，故X/10=X/8-X/32+X/128-X/512+..., 所求的程序段是： &amp;nbsp;MOV AX,FE00H&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被除数送AX &amp;nbsp;MOV CL,3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数3 &amp;nbsp;SHR AX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数除以8，结果在AX中 &amp;nbsp;MOV BX,AX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数除以8的结果暂存到BX &amp;nbsp;MOV CL,2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数2 &amp;nbsp;SHR AX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数除以4（累计除32），结果在AX中 &amp;nbsp;SUB BX,AX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被除数/8-被除数/32，结果在BX中 &amp;nbsp;MOV CL,2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数2 &amp;nbsp;SHR AX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数除以4（累计除128），结果在AX中 &amp;nbsp;ADD BX,AX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被除数/8-被除数/32+被除数/128，结果在BX中 &amp;nbsp;MOV CL,2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数2 &amp;nbsp;SHR AX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；被乘数除以4（累计除512），结果在AX中 &amp;nbsp;SUB BX,AX &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;；被除数/8-被除数/32+被除数/128-被除数/512，结果在BX中 (4) 将AX中间8位，BX低四位，DX高四位拼成一个新字的程序段是： &amp;nbsp;AND DX,0F000H&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将DX的低12位清零，高4位不变 &amp;nbsp;AND AX,0FF0H&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将AX的低4位清零，高4位清零，中间8位不变 &amp;nbsp;AND BX,0FH&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将BX的高12位清零，低4位不变 &amp;nbsp;ADD AX,BX &amp;nbsp;ADD AX,DX&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；按要求组成一个新字，结果放在AX中。 (5) 将数据段中以BX为偏移地址的连续四个单元的内容颠倒过来的程序段是： MOV AL,[BX]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；数据段中BX为偏移地址的字单元内容送AX XCHG AL,[BX+3] &amp;nbsp;&amp;nbsp;；数据段中BX+3为偏移地址的字单元内容与AX的内容交换 MOV [BX],AL&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;；数据段中BX+3为偏移地址的字单元内容送BX为偏移地址的字单元 MOV AL,[BX+1]&amp;nbsp;&amp;nbsp;&amp;nbsp; ；数据段中BX+1为偏移地址的字单元内容送AX XCHG AL,[BX+2] &amp;nbsp;&amp;nbsp;；数据段中BX+2为偏移地址的字单元内容与AX的内容交换 MOV [BX+1],AL &amp;nbsp;&amp;nbsp;&amp;nbsp;；数据段中BX+2为偏移地址的字单元内容送BX+1为偏移地址的字单元 (6)将BX中的四位压缩BCD数用非压缩BCD数形式顺序放在AL、BL、CL、DL中的程序段是： MOV DL,BL&amp;nbsp;&amp;nbsp;&amp;nbsp; ；四位压缩BCD数的低位字节送DL AND DL,0FH&amp;nbsp; &amp;nbsp;；DL的高4位清零，得四位非压缩BCD数的最低位，放入DL中 MOV CL,4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数4 SHR BX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp; ；BX中的数据逻辑右移4位，使四位压缩BCD数的次低位位于BL的低4位 MOV CH,BL&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将BL的内容暂存到CH中保留 AND CH,0FH&amp;nbsp;&amp;nbsp; ；CH的高4位清零，得四位非压缩BCD数的次低位，放CH中 MOV CL,4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数4 SHR BX,CL&amp;nbsp;&amp;nbsp;&amp;nbsp; ；BX中的数据逻辑右移4位，使四位压缩BCD数的次高位位于BL的低4位 MOV AL,BL&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将BL的内容暂存到AL中保留 AND BL,0FH&amp;nbsp;&amp;nbsp; ；BL的高4位清零，得四位非压缩BCD数的次高位，放BL中 MOV CL,4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ；设置移位位数4 SHR AL,CL&amp;nbsp;&amp;nbsp; &amp;nbsp;；使四位压缩BCD数的最高位位于AL的低4位，得四位非压缩BCD数的次高 ；位，放入BL中 MOV CL,CH&amp;nbsp;&amp;nbsp;&amp;nbsp; ；将四位非压缩BCD数的次低位移入CL中 &amp;nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://www.voyax.me/tags/汇编/"}]},{"title":"身处喧闹人群中，却与整个世界无关","slug":"身处喧闹人群中，却与整个世界无关","date":"2014-05-11T05:17:31.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/44858/","link":"","permalink":"http://www.voyax.meposts/44858/","excerpt":"","text":"原来最深的孤独不是一片黑暗，而是你，只能看到自己 身处喧闹人群中，却与整个世界无关，才是最大的寂寞 昨天和妹妹打完电话后，心里很烦，其实她说得很对，我没有必要让自己这么累，本科出去直接找工作也挺好，但自己就是这么犟；谈到她的打算时，挺羡慕她，从高中到大学，她一直过得还蛮开心的。从小玩到大的三兄妹，如今只剩下我们两个还能保持这种兄妹情谊，其他人都不再怎么有联系了…… &nbsp; &nbsp; &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"2011至2014年34所自主划线高校复试分数线汇总","slug":"2011至2014年4年34所自主划线高校复试分数基本要求","date":"2014-05-10T03:51:32.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/22681/","link":"","permalink":"http://www.voyax.meposts/22681/","excerpt":"","text":"人大2014年金融学硕收分360，和13年相平，今年清华经济类学硕也是360!&nbsp; 历年全国复试分数基本要求2014 2013 2012 2011 2010 2009 2008 2007 2006 2005 2004 2003 2002 2001 34所自主划线高校复试分数线 北京大学 2014（医学部） 13 12 11 中国人民大学 2014 13 12 11 清华大学 2014 13 12 11 北京航空航天大学 2014 13 12 11 北京理工大学 2014 13 12 11 中国农业大学 2014 13 12 11 北京师范大学 2014 13 12 11 南开大学 2014 13 12 11 天津大学 2014 13 12 11 大连理工大学 2014 13 12 11 东北大学 2014 13 12 11 吉林大学 2014 13 12 11 哈尔滨工业大学 2014 13 12 11 复旦大学 2014 13 12 11 同济大学 2014 13 12 11 上海交通大学 2014 13 12 11 南京大学 2014 13 12 11 东南大学 2014 13 12 11 浙江大学 2014 13 12 11 中国科学技术大学 2014 13 12 11 厦门大学 2014 13 12 11 山东大学 2014 13 12 11 武汉大学 2014 13 12 11 华中科技大学 2014 13 12 11 湖南大学 2014 13 12 11 中南大学 2014 13 12 11 中山大学 2014 13 12 11 华南理工大学 2014 13 12 11 四川大学 2014 13 12 11 重庆大学 2014 13 12 11 电子科技大学 2014 13 12 11 西安交通大学 2014 13 12 11 西北工业大学 2014 13 12 11 兰州大学 2014 13 12 11 来源：中国研究生招生信息网","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://www.voyax.me/tags/考研/"}]},{"title":"母亲节，默默祝福","slug":"母亲节，默默祝福","date":"2014-05-09T18:47:06.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/41092/","link":"","permalink":"http://www.voyax.meposts/41092/","excerpt":"","text":"明天是母亲节了。从小到大，我对于父亲节、母亲节，毫无概念……这是在北京上学的第三年，却越发重视这些东西。 一直以来都自认为是孝顺的，对于所谓的母亲节、父亲节之类颇有反感，以前总固执地认为，这样的节日完全是矫揉造作，平时不孝顺父母，等到某个节日才给爸妈打个电话问个好，未免恶心。 但，和父母分开久了，自己也慢慢开始关心起这些父亲节、母亲节……每周也会和家里边打电话，但毕竟分隔两地，多少还是有些牵挂。 很多时候想想家里边起早贪黑的爸妈，挺惭愧……都这么大了，还不能为他们做点什么。 去年母亲节的前一天，姐给我打了个电话，说，明天是母亲节，记得给妈打个电话。听到姐的话，我很震惊，一是难得姐姐念着我妈妈，毕竟她是舅舅的孩子，虽然她家里边出了很多事，我妈对她格外好，但也从未见她有何表示，看来很多时候，我们心里都清楚，只是，没有让某些东西表现出来；二是姐竟然也记得母亲节，而且还提醒我打电话，这并非她的一贯作风。自己其实一直都很在意爷爷奶奶爸爸妈妈，但平时在家里总是装得大大咧咧、无所谓，母亲节快乐之类的话是说不出口的，于是用很不屑的语气给姐说，明天你替我给妈打电话哈！姐在电话的另一头似答非答地答应了，第二天我自己终于还是忍不住，给家里边打了个电话，但丝毫未题母亲节之类的字眼…… 有时想想，爸妈这这些方面似乎不敢有太多的想法。 即使爸妈生日那天，我也，只是打个电话，像平常那样聊天，有一句每一句地瞎扯着……未曾有勇气说：爸（妈），生日快乐。 去年妈妈生日，我提前两天找了个在重庆的同学，麻烦他在我妈生日那天把蛋糕送到我妈手里。同学那天一大清早从学校出发赶到我家，帮我将送蛋糕送到了我妈手里。当天晚上，他给我打了个电话，说，“你妈都笑得合不拢嘴了”，听完同学的话，心里边好痛，眼泪也哗哗了冒出来，原来自己欠了他们太多…… 今年过年回家，刚到家的前两天，妈就一直说那蛋糕的事，说蛋糕太大吃不完、耽搁了同学、小妹吃了多少多少……我知道，即使过了几个月，妈现在还高兴着…… 明天又是母亲节，很多话还是说不出口，今天凌晨一时兴起以博客的形式记下一点东西，只是希望爷爷奶奶、外公外婆、爸爸妈妈都健健康康的，哦，当然还有小二妹~~ 大家都要平平安安、开开心心的。 拜佛许愿的时候，心里想的说出来就不灵验了，一些话既然说不出口，那就希望心里想的都能变成现实，默默祝福 一想到孝，母亲之类的，就会想起史铁生的那篇文章，以及当年语文书里边的“树欲静而风不止，子欲养而亲不待”，最后贴上史铁生《秋天的怀念》： 秋天的怀念 史铁生 双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推着你去走走。”她总是这么说。母亲喜欢花，可自从我的腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。 那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海的菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”“你要是愿意，就明天?”她说。我的回答已经让她喜出望外了。“好吧，就明天。”我说。她高兴得一会坐下，一会站起：“那就赶紧准备准备。”“唉呀，烦不烦？几步路，有什么好准备的！”她也笑了，坐在我身边，絮絮叨叨地说着：“看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……”她忽然不说了。对于“跑”和“踩”一类的字眼儿。她比我还敏感。她又悄悄地出去了。 她出去了。就再也没回来。 邻居们把她抬上车时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。 邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……” 又是秋天，妹妹推我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开得烂漫。我懂得母亲没有说完的话。妹妹也懂。我俩在一块儿，要好好儿活…… Your browser does not support the audio element.","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"5月8日，世界微笑日 今天你笑了吗","slug":"5月8日，世界微笑日-今天你笑了吗","date":"2014-05-08T12:36:31.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/55305/","link":"","permalink":"http://www.voyax.meposts/55305/","excerpt":"5月8日是世界微笑日，用你的微笑去改变这个世界，别让这个世界改变了你的笑容。 Your smile looks adorable.You should wear it more often. [caption id=”” align=”alignnone” width=”500”] smile[/caption]","text":"5月8日是世界微笑日，用你的微笑去改变这个世界，别让这个世界改变了你的笑容。 Your smile looks adorable.You should wear it more often. [caption id=”” align=”alignnone” width=”500”] smile[/caption] 在人人上看见一好友发的照片，乐死我了 [caption id=”attachment_277” align=”alignnone” width=”429”] 抓了只耗子，花了20块钱，送他上了天[/caption]","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"北京航空航天大学计算机图形学试卷及答案","slug":"北京航空航天大学计算机图形学试卷及答案","date":"2014-05-07T16:38:08.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/46893/","link":"","permalink":"http://www.voyax.meposts/46893/","excerpt":"","text":"1、 用C语言写出Bresenham画线算法（书p33），并阐述该算法的思想。（书p31） 避免了DDA算法中费时的取整运算 借助一个误差量（表征直线与当前实际绘制像素点的距离）来确定下一个像素点的位置 2、 求点A（1，3，2）绕轴B（0，0，0），C（1，1，-1）旋转90度后（逆时针）的坐标。 &nbsp; 3、 试分析三维图形的显示流程（即需要经过哪些变换），（ppt 4 变换 39页）OpenGL &nbsp; 设一个点的世界坐标系下坐标为：P 设世界坐标向视坐标变换的矩阵为：T视 设投影矩阵为：T投 设视口变换矩阵为：Tw 则：Pw= Tw T投T视P， 令T= Tw T投T视,则： Pw=TP 中与变换有关的矩阵有哪几个，各描述了哪些变换？ （ppt 4 变换倒数那几页） ModelView 和 Projection glTranslatef(dx,dy,dz); 平移 glRotatef(angle,vx,vy,vz);旋转 glScalef(sx,sy,sz);缩放 gluLookAt(ex, ey, ez, ax, ay, az, px , py , pz);设置视点、被观测点和向上方向 glOrtho(xmin,xmax,ymin,ymax,near,far);设置投影矩阵（正） glFrustum(xmin,xmax,ymin,ymax,near,far);透视 gluPerspective(fovy,aspect,near,far);透视 &nbsp; 4、 给出实现缩放操作的交互控制方法，并简要叙述程序的流程。(书p124) OnLButtonDown(msg) { m_LeftButtonDown = TRUE; m_LeftDownPos = GetMouseLocation(); oldWidth = GetViewWidth(); }…. 1、 设标志m_LeftButtonDown为真，表示已经处于缩放状态； 2、 记下此时鼠标指针的位置，放在m_LeftDownPos中，用来在鼠标移动事件中计算两次鼠标位置的纵向移动距离，从而计算出应对视图缩放的尺度。 3、 将此时的场景的失款记入oldWidth中 4、 Z缓冲器算法的作用是什么？（消隐）其中有几个缓冲器（2个，帧缓冲区和Z缓冲区）？分别存放什么（帧缓冲区存放每个像素点的亮度值，Z缓冲区存放每个像素的深度值）？写出算法策略。 （书p147） 帧缓冲区置成背景色； Z缓冲区置成某初始值，改值i场景在观察坐标系下的最小z值还小； For（各个多边形） { 扫描转换改多边形； For（多边形所覆盖的每一个像素（x，y）） { 计算该像素所对应多边形上的点再观察坐标系下的z坐标值Z(x,y); If (Z(x,y) &gt;Z缓冲区在（x，y）处的值) { Z缓冲区中（x，y）处深度值替换为Z(x,y)； 帧缓冲区中（x,y）处亮度值替换为多边形在（x,y）处亮度值 } } } 5、详细比较Phong光照模型和Gouraud光照模型的优缺点。 Gouraud光照模型：通过对多边形顶点颜色进行线性插值来获得其内部各点颜色， Phong光照模型：通过对多边形顶点的法矢量进行线性插值来获得其内部各点的法矢量 1）Phong着色方法计算量远大于Gouraud着色方法 2） Phong着色方法绘制的图形比Gouraud方法更真实 体现在两个场合：高光区域的扩散 不产生高光区域 &nbsp; 贝赛尔曲线 它通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形。其中起重要作用的是位于曲线中央的控制线。这条线是虚拟的，中间 与贝塞尔曲线交叉，两端是控制端点。移动两端的端点时贝塞尔曲线改变曲线的曲率（弯曲的程度）；移动中间点（也就是移动虚拟的控制线）时，贝塞尔曲线在起 始点和终止点锁定的情况下做均匀移动。 贝塞尔曲线与B样条的区别 B样条方法是在保留Bezier方法的优点，同时克服其由于整体表示带来不具有局部性质的缺点，及解决在描述复杂形状时带来的连接问题下提出来的。 常用的cad设计中之所以选用3次B样条而不用更高次是因为次数越高，控制点影响的曲线段数就越多，不利于局部控制；而三次Bezier曲线意味着必须有4个控制顶点。 他们的区别主要有以下4点： 1、Bezier曲线的基函数次数等于控制顶点数减1。B样条曲线基函数次数与控制顶点数无关； 2、Bezier曲线的基函数是Beinstein基函数，它是个多项式函数。B样条曲线的基函数是多项式样条。 3、Bezier曲线是一种特殊表示形式的参数多项式曲线。B样条曲线则是一种特殊表示形式的参数样条曲线。 4、Bezier曲线缺乏局部性质，即修改任意一个控制顶点都会对曲线整体产生影响。B样条曲线具有性质，即修改一个控制顶点只会对几段曲线产生影响 &nbsp; void CAbcView::Bresenhamline(int x0,int y0,int x1,int y1) { CDC *hDC=GetDC(); COLORREF color=RGB(255,255,0); int x, y, i; if (x0 == x1) k = 2; else k = (float)(y1 - y0)/(x1 - x0); if (k &gt;= 0 &amp;&amp; k &lt;= 1) { if (x0 &gt; x1) { swap(&amp;x0, &amp;x1); swap(&amp;y0, &amp;y1); } dx = x1 - x0; dy = y1 - y0; e = 2*dy - dx; x = x0; y = y0; for (i = 0; i &lt;= dx; i++) { hDC-&gt;SetPixel(x,y,color); x++; if (e &gt;= 0) { y++; e = e + 2 dy - 2 dx; } else e = e + 2 * dy; } } else if (k &gt;= -1 &amp;&amp; k &lt; 0) { if (x0 &gt; x1) { swap(&amp;x0, &amp;x1); swap(&amp;y0, &amp;y1); } dx = x1 - x0; dy = y1 - y0; e = 2*dy- dx; x = x0; y = y0; for (i = 0; i &lt;= dx; i++) { hDC-&gt;SetPixel(x,y,color); x++; if (e &lt;= 0) { y–; e = e + 2 dy + 2 dx; } else e = e + 2 * dy; } } else if (k &gt; 1) { if (y0 &gt; y1) { swap(&amp;x0, &amp;x1); swap(&amp;y0, &amp;y1); } dx = x1 - x0; dy = y1 - y0; e = 2*dx - dy; x = x0; y = y0; for (i = 0; i &lt;= dy; i++) { hDC-&gt;SetPixel(x,y,color); y++; if (e &gt;= 0) { x++; e = e + 2 dx - 2 dy; } else e = e + 2 * dx; } } else { if (y0 &gt; y1) { swap(&amp;x0, &amp;x1); swap(&amp;y0, &amp;y1); } dx = x1 - x0; dy = y1 - y0; e = 2*dx- dy; x = x0; y = y0; for (i = 0; i &lt;= dy; i++) { hDC-&gt;SetPixel(x,y,color); y++; if (e &lt;= 0) { x–; e = e + 2 dx + 2 dy; } else e = e + 2 * dx; } } } &nbsp; void CAbcView::swap(int m,int n) { &nbsp; int t; t=*m; m=n; *n=t; &nbsp; }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://www.voyax.me/tags/计算机图形学/"}]},{"title":"【转】Matlab画平滑曲线的两种方法（ 拟合或插值后再用plot即可）","slug":"【转】matlab画平滑曲线的两种方法（-拟合或插值后再","date":"2014-05-02T09:48:40.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/7378/","link":"","permalink":"http://www.voyax.meposts/7378/","excerpt":"","text":"自然状态下，用plot画的是折线，而不是平滑曲线。 有两种方法可以画平滑曲线，第一种是拟合的方法，第二种是用spcrv，其实原理应该都一样就是插值。下面是源程序，大家可以根据需要自行选择，更改拟合的参数。 clc,clear;a = 1:1:6; %横坐标b = [8.0 9.0 10.0 15.0 35.0 40.0]; %纵坐标plot(a, b, ‘b’); %自然状态的画图效果hold on;%第一种，画平滑曲线的方法c = polyfit(a, b, 2); %进行拟合，c为2次拟合后的系数d = polyval(c, a, 1); %拟合后，每一个横坐标对应的值即为dplot(a, d, ‘r’); %拟合后的曲线 plot(a, b, ‘‘); %将每个点 用画出来hold on;%第二种，画平滑曲线的方法values = spcrv([[a(1) a a(end)];[b(1) b b(end)]],3);plot(values(1,:),values(2,:), ‘g’); 效果： &nbsp; 原文转自：http://blog.csdn.net/yanzi1225627/article/details/8248099","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://www.voyax.me/tags/Matlab/"}]},{"title":"静 孤 信","slug":"静-孤-信","date":"2014-05-02T04:33:39.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/17164/","link":"","permalink":"http://www.voyax.meposts/17164/","excerpt":"没必要总是心想着带着一个同伴，只有食草动物才需要结伴，人迟早需要自己独当一面，所以孤独者才是成熟的。很多神明都傲立于众人的，所以孤独者是最接近神明的存在。现充们宣扬着自己的快乐起是也只是麻痹自己。 &nbsp; 要知道那些讴歌青春的现充们都是骗子，如果真的现充的生活那么好，他们肯定不愿意分享的。愿意跟你出去的女生肯定是温柔的，但我们这些屌丝经常会误解这份温柔，待你温柔必定待他人也温柔，只是习惯了罢了千万别误会。。人家上次已经用间接的方式作出了解释，不懂得即时抽身是不明智的。 &nbsp; 人生若有知己相伴固然妙不可言，但那可遇而不可求，也许既不可遇又不可求，可求的只有你自己，你要俯下身去，朝着幽暗深处的自己伸出手去。","text":"没必要总是心想着带着一个同伴，只有食草动物才需要结伴，人迟早需要自己独当一面，所以孤独者才是成熟的。很多神明都傲立于众人的，所以孤独者是最接近神明的存在。现充们宣扬着自己的快乐起是也只是麻痹自己。 &nbsp; 要知道那些讴歌青春的现充们都是骗子，如果真的现充的生活那么好，他们肯定不愿意分享的。愿意跟你出去的女生肯定是温柔的，但我们这些屌丝经常会误解这份温柔，待你温柔必定待他人也温柔，只是习惯了罢了千万别误会。。人家上次已经用间接的方式作出了解释，不懂得即时抽身是不明智的。 &nbsp; 人生若有知己相伴固然妙不可言，但那可遇而不可求，也许既不可遇又不可求，可求的只有你自己，你要俯下身去，朝着幽暗深处的自己伸出手去。这些文字是从花园摘来的，如若有冒犯的地方，还望及时与我联系 &nbsp; 给自己的只有三个字：静 孤 信 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"NURBS非统一有理B样条曲线概念理解","slug":"nurbs非统一有理b样条曲线概念理解","date":"2014-04-29T02:05:37.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/42745/","link":"","permalink":"http://www.voyax.meposts/42745/","excerpt":"","text":"NURBS是Non-Uniform Rational B-Splines的缩写，是非统一有理B样条的意思。具体解释是： .Non-Uniform(非统一）：是指一个控制顶点的影响力的范围能够改变。当创建一个不规则曲面的时候这一点非常有用。同样，统一的曲线和曲面在透视投影下也不是无变化的，对于交互的3D建模来说这是一个严重的缺陷。 .Rational(有理）：是指每个NURBS物体都可以用数学表达式来定义。 .B-Spline(B样条）：是指用路线来构建一条曲线，在一个或更多的点之间以内插值替换的。 简单地说，NURBS就是专门做曲面物体的一种造型方法。NURBS造型总是由曲线和曲面来定义的，所以要在NURBS表面里生成一条有棱角的边是很困难的。就是因为这一特点，我们可以用它做出各种复杂的曲面造型和表现特殊的效果，如人的皮肤，面貌或流线型的跑车等。一条NURBS曲线中有四个重要的定义项目：degree值,Control points控制点，knots节点和evaluation rule评定的规则。 degree 值 degree的值是一个正整数。这个值通常为1，2，3或5。RHINO的线段和复合线段的degree的值为1。圆degree的值为2，而大部分RHINO的自由曲线的degree的值为3或5。RHINO所使用的NURBS曲线的degree的值可以设置从1到32。而通常我们把这些degree的值，称之为Linear，Quadratic, Cubic， Quintic。 Linear代表着degree的值为1，Quadratic代表着degree的值为2， Cubic代表着degree的值为3 ，Quintic代表着degree的值为5。 你可以参阅参考文献里关于NURBS曲线的order部分。NURBS曲线的order是个正整数，且等于degree+1。所以degree的值等于order –1。在改变NURBS曲线的degree的值的过程中，你有可能只增加degree的值而不影响到NURBS曲线的形状。但是，你无法在减小degree的值的过程中不影响到NURBS曲线的形状。RHINO所提供的工具能让你自由地设定NURBS曲线的degree的值，从1到32。 Control points 控制点 Control points最少是degree+1个点。移动控制点，是改变NURBS曲线最简单的方法。RHINO提供了很多方法来移动控制点。如果需要有较大弹性的自由曲面，你可以只使用鼠标来快速的移动和改变控制点，以绘制你的模型。而相对于准确性要求较高的曲线，RHINO则提供了其它精确性高的工具，以供使用。 Control points有一个相关的值—Weight。除了少数例子外，weight的值通常是正数。Control points是一串至少是degree+1个点，此曲线状况称之为non-rational；而如果weight的值并不完全相同时，此曲线状况称之为rational。NURBS曲线中的R为rational的缩写。但这只是代表这条曲线有可能是rational。在范例里，有大部分的NURBS曲线都是non-rational。只有一些NURBS曲线是rational，如：圆，椭圆等明显的案例。RHINO提供一些工具来检测和更改Control points的weight值。 knots节点 knots节点是一串degree+N-1的数字，其中N为Control points的数字编号。有时我称这串数字为knot vector。在这里的vector并不是指3-D向量或方向性。这串节点数字必须符合一些技术上的条件。这里列出了几项符合knot技术上所需要的条件值。基本的条件为：这连串的数字必须相同，或顺序越后的数字越大，而且如果数字重复了，重复的次数不可以超过degree的值。例如一degree的值为3的NURBS曲线，其Control points的数量为11，而这串数字为0，0，0，1，2，2，2，3，7，7，9，9，9，符合knot数字串的要求。但假如knot数字值为0，0，0，1，2，2，2，2，7，7，9，9，9，这就不符合技术上所需要的条件值了。因为有4 个2，已超出了degree的值3的数量。相同的knot数字值的数量，我们称之为multiplicity.在上一个范例中，符合了knot技术上所需要的条件值，其knot值为0的有multiplicity 3，其knot值为1的有multiplicity 1，其knot值为2的有multiplicity 3，其knot值为7的有multiplicity 2，其knot值为9的有multiplicity 3。当knot的multiplicity值与其degree的值一样时，我们将之称为Full – multiplicity。在上一个范例中，knot的值为0，2，9，都是Full – multiplicity。当knot的multiplicity值为1时，我们将之称为Simple – multiplicity。在上一个范例中，knot的值为1，3，都是Simple – multiplicity。假如一曲线其knot的值开始于Full – multiplicity，然后接着Simple – multiplicity，结尾又是Full – multiplicity，而且其值之间的间隔相同，那这个knot称之为uniform。例如一NURBS曲线，其degree的值为3，Control points的数量为7，knot的值为0，0，0，1，2，3，4，4，4，那此曲线就可称之为uniform曲线。而假如knot的值为0，0，0，1，2，5，6，6，6，那此曲线就不是uniform曲线，我们称之为non-uniform。NURBS里的NU字母就是non-uniform的缩写。表示knots节点在NURBS曲线中是允许non-uniform的情形。相同的knot数字值的数量，如果集中在值的中央部位，那这一NURBS曲线是较不圆滑的。例如有一曲线其knot值的中央有一Full – multiplicity，那就是表示此NURBS曲线会被弯成一锐角。因此，有些人会想要以增加或减少knots的数量，然后调整Control points使得曲线变得更加平顺或更锐利。RHINO提供了工具让你自由的增加或减少knots的数量。之前有提到过knots的值为degree+N-1，其N为Control points的值。所以当你增加knots的数量，同时也增加了Control points的数量；减少knots的数量，同时也减少了Control points的数量。knots的数量可以被增加，而不会影响到NURBS曲线的外形。而在一般情况下，减少数量会影响到NURBS曲线的外形。RHINO提供了一个减少knots的进阶工具，当你删除Control points时，它会自动调整knots的位置到最适当的位置。 Knots和control points 一般人常会误解，在NURBS曲线里的一个Control points会对应一个knot。而这种情况通常只会发生在degree的值为1的NURBS曲线上（通常是polylines）。在degree的值较高的NURBS曲线上，是由degree+1个Control points群组对应2倍degree值的knots群组。例如：假设我们有一个degree值为3的NURBS曲线，其Control points为7和knots为0，0，0，1，2，5，8，8，8。这时，前四个Control points和前六个knots为一组。而第二到第五个Control points和knots 0，0，1，2，5，8，为一组。而第三到第六个Control points和knots 0，1，2，5，8，8为一组。最后四个Control points和最后六个knots为一组。现在还有些软件使用旧版本的NURBS转换法。旧版本的NURBS转换法在计算knots值时，须在总额为degree+N+1 knots再额外多加两个knots值。当RHINO在输入或输出NURBS几何资料到这些软件时，会自动地增加或减少两个多余的knots值以符合其正确性。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://www.voyax.me/tags/计算机图形学/"}]},{"title":"【转】Windows编程的图形基础HDC, HPEN, HBRUSH","slug":"【转】windows编程的图形基础hdc-hpen-hbrush","date":"2014-04-28T14:34:24.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/1271/","link":"","permalink":"http://www.voyax.meposts/1271/","excerpt":"","text":"在windows编程中，要在设备（显示器）上显示相应的图像，这里先针对简单的对象，比如line, polygon, 矩形，椭圆等，实现的具体过程如下： 首先要获得设备句柄，有了设备句柄你才可以在相应设备上输出图形，用GetDC和RealseDC函数来获得和释放设备句柄。然后在BeginPaint和EndPaint函数（）中执行相应的绘画。 每个设备都有其相应的属性，例如在设备中的输出字体，就有相应的字体属性，有字体颜色，大小，还有TextAlign等属性，通过SetTextAlign及对应的GetTextAlign函数来设定。 当设备要输出对一些线段或一些多边形时，就要有相应的Pen和Brush。Pen，Brush等也有相应的句柄和相应的属性，它们的属性不属于设备属性的值。而Pen，Brush等是属于设备的属性。比如Pen画的线，就有线的宽度和长度和画笔样式，它是一个逻辑画笔，通过CreatePen、 CreatePenIndirect或ExtCreatePen函数中指定这些特征来建立一个逻辑画笔，这些函数传回一个逻辑画笔的句柄，然后设备把这画笔句柄选进设备内容。我们认为，设备内容中目前选中的画笔就是设备内容的一个属性。但是。清除画笔对象是必要的，因为画笔定义占用了分配的内存空间。而在结尾清除设备上下文的句柄也是必要的，他们也占据了一定的内存空间。 下面来谈谈HPEN和HBRUSH 首先当然是申明一个HPEN，HPEN hPen，我们可以通过调用GetStockObject(WHITE_PEN),CreatePen(iPenStyle,iWidth, crColor), 和CreatePenIndirect(CONST LOGPEN*lplgpn)其返回值都是HPEN,他们的区别就是，stock Pen，就是系统库存的pen颜色，他们是WHITE_PEN, BLACK_PEN, NULL_PEN这些样式可以直接从GetStockObject()函数获得。而其中CreatePenIndirect()就是把pen的一些样式属性比如penStyle，width，color的值放入LOGPEN结构体中，从而构建HPEN。 设备上下文通过SelectObject(hdc, hPen)函数把相应的pen选入设备上下文属性中。 在不用这些pen后，应调用DeleteObject(hPen)把他们清理掉。 而HBRUSH的情况和HPEN的情况类似，Windows还有五个函数，可以让您建立逻辑画刷，然后就可使用SelectObject将画刷选进设备内容。与逻辑画笔一样，逻辑画刷也是GDI对象。您建立的所有画刷都必须被删除。 hBrush = CreateSolidBrush (crColor) ; hBrush = CreateHatchBrush (iHatchStyle,crColor) ; CreatePatternBrush CreateDIBPatternBrushPt hBrush = CreateBrushIndirect(&amp;logbrush) ; 变量logbrush是一个型态为LOGBRUSH（「逻辑画刷」 ）的结构 一旦您取得到了画刷句柄，就可以使用SelectObject将该画刷选进设备内容： SelectObject (hdc, hBrush) ; 然后，您可以使用DeleteObject函数删除所建立的画刷： DeleteObject (hBrush) ; 其中以上函数的详细信息可以参见MSDN。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"在最深的绝望里，终会看见最美的风景","slug":"在最深的绝望里，终会看见最美的风景","date":"2014-04-27T10:47:29.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/30093/","link":"","permalink":"http://www.voyax.meposts/30093/","excerpt":"","text":"一直一直想写，一直一直想骂。周一到周日全天候专业课，跨专业考研。。。其他人都在学习。。。好吧，我是真闲。。。 其实，偶尔有从世上消失的想法，但多多少少还是有些不甘的吧 越长大越孤单，终于明白 ，不是太冷酷，而是太在意 昨天晚上看见两儿小孩在单双杆边玩，羡慕、嫉妒 我是好久没有真心笑过了 皮笑肉不笑，哈哈哈哈哈哈哈哈哈 世界这么大，你我却是如此渺小 曾经多么坚信“人定胜天”，满口“面壁十年图破壁，难酬蹈海亦英雄”，走了这么久，却发现回到了原点 虚伪，冷漠，自私，矫情 尘归尘土归土，少他妈痴心妄想；梦想？去你妹的吧 这个世界唯有两个东西值得我珍惜，家人、生命，如果非要再加一个，那算是友情吧；但是什么又是友情呢！除了父母又真的有人在乎过你吗？ 我所说的生命，并非苟且于世事，若我的生命能换来家人的幸福，我现在离开电脑，从六楼跳下去我也不会犹豫的 越有情，越容易受伤 冷血无情ps铁石心肠日后要作为褒义词了吧 无论多么不满，不管多么忧伤，你要有本事让太阳绕着地球转看看？不要给我说参考系，我只能说你是个脑残 忘掉一切一切的虚假，忘掉一切一切的幻想 冷静、专注 路漫漫其修远兮，吾将上下而求索 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"好好的，好好的","slug":"好好的，好好的","date":"2014-04-24T15:04:56.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/40771/","link":"","permalink":"http://www.voyax.meposts/40771/","excerpt":"","text":"这两天看见你微信发的状态，本想给你打个电话，但想想自己算什么，凭什么给你打电话，而且不得不承认自己不会安慰人，于是选择了这样一种方式。 如果你对我发链接反感（至少大部分人都会这样），真的很抱歉，抱歉。 并不是为了提高什么点击率，也不想很虚伪的说些无关痛痒的安慰的话；只希望你过得好好的，好好的，无论其他的怎么样，至少有个比较好的心情。 每个人在很心痛的时候并不是不知道其他人所说大道理，当自己安慰别人的时候自己也知道说些开导的话的吧。如果你没有心情继续看后面这些连我自己都弄不清逻辑的文字的画，希望你能想安慰别人那样安慰自己，无论什么事情，总会过去，一觉醒来又是新的一天。 有些事情由不得我们控制，但是真要是一些让自己伤心欲绝的事情发生，我们除了接受又能怎样，但是无论如何，我们都应该让自己好好的，只有你好好的，爱你的人才会好好的；你好好的，才有能力让你爱的人好好的。当然，自己的痛只有自己知道，哪怕自己再难受，面对外面的世界，我们又不得不隐藏自己的悲伤；但是，你爱的人以及爱你的人只有看着你好好的，才会好好的，对于一些东西大家彼此都明白，说不痛，是假的。可以哭，可以悲伤，但是最终还是要过去，去操场跑步发泄一下或者找个人好好聊一聊或者痛痛快快哭一场……无论做什么，别憋在心里了，你难受，其他人也难受，发泄出来就好多了；扛不住的时候就不要自己一个人扛了，还有这么多爱你的人愿意为你分担的。 中途接了个电话。。。不知道说什么了…………… 自己的痛虽然不是别人说几句或者怎样就能好的，但为了你爱的人，尽快让自己开心起来吧：） 给你看一个之前我看到的一个很感人的的事哈 从我以前的笔记本里抄了一段话： 不要因为难过，就忘了散发芳香。在哪里存在，就在哪里绽放，不管我们面对什么处境，不管我们内心多么矛盾，我们总有选择。我们是什么样的人，取决于我们做什么样的人。不知道写什么了，很多东西说出来会变味没想到写出来还是一样……不要想太多了，晚上好好睡一觉吧，要是不介意的话，睡不着无聊的时候随时给我发微信，相信我肯定会马上回你的","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"2014年阿里里巴巴前端工程师面试总结","slug":"2014年阿里里巴巴前端工程师面试总结","date":"2014-04-19T02:10:33.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/28350/","link":"","permalink":"http://www.voyax.meposts/28350/","excerpt":"真的很抱歉，最终没能通过阿里巴巴前端工程师的终面。线上笔试和一面都比较轻松的通过，但是终面真的就无能为力了，写这篇文章并非要学大牛传授所谓的经验，况且我也没经验可说，仅作为自己的一个记录，时时提醒自己，脚踏实地地学习，无论何时也不要懈怠。 阿里巴巴前端工程师的面试只有两面，一面主要问前端的东西，例如html、css、js，当然还是有其他方面的知识，但是那些只占很少很少部分，几乎可以忽略。一面中，面试官问了我一个问题，“你觉得前端应该学些什么”，我霹雳啪啦说了一串，包括后端的一些东西，对我的答案，面试官还是比较认同的，但是最后说了句，前端其实就是html、css、js。当他帮我明确了这个概念，我对二面有了比较大的希望，因为就这三个来说，我认为考查点不多，而且自己还是会很多东西。 一面面了一个多小时，一面通过后，还是很开心的。面试的学生中，绝大多数都是研究生，前两天我的很多同学陆陆续续下去面试算法和研发，但是没有一个通过一面；而前端更是，本科生本来做前端的就不多，我映像中那天通过一面的人最多也就6个，除我之外都是研究生，所以想一想，感觉自己还是蛮厉害的嘛，通过二面应该也不是问题的吧。 但是二面也就是终面完全和我想的不同，二面没有问html、css、js而是谈一些算法、网络等专业课的知识，问如何解决因网络延迟造成的过期请求，如何尽可能实现电子时钟的精确性……对于最后的这两个问题，我只能说呵呵了，当时心里就很不爽，你明知道我现在大三，网络都还没怎么学呢，你就偏偏拿这些东西考我，想赶人走就明说，何必故意让人难堪。很无奈的表明我不会后，面试官说，这些东西不在于学校老师教没教，很多人很早前自己就会把这些东西学得很熟。听完这句话，心里边真的很不爽，这不是故意为难我吗，在计算机这个行业，想难倒一个人太容易了…… 很郁闷地离开了阿里，在回学校的地铁上，反复想反复想，最后不得不承认还是自己实力不够强，不能怪别人。上了大学很长时间都是自我感觉良好，但其实你算个屁啊，你有踏踏实实地学习过吗，你有专专心心的研究某个东西而废寝忘食吗，自己以前做的那些，所有人都能做到，而现在的问题是，你又凭什么觉得比别人优秀！ 要相比别人强，你就得去做别人不愿意、不敢做的事，你就得比别人细心，比别人努力，而这些细节的地方往往都被我忽略掉了，从现在起，脚踏实地，静心好好学习，不要浮躁，一定要认真、专注，在大学最后一年半的时间里，好好加油，问心无愧！","text":"真的很抱歉，最终没能通过阿里巴巴前端工程师的终面。线上笔试和一面都比较轻松的通过，但是终面真的就无能为力了，写这篇文章并非要学大牛传授所谓的经验，况且我也没经验可说，仅作为自己的一个记录，时时提醒自己，脚踏实地地学习，无论何时也不要懈怠。 阿里巴巴前端工程师的面试只有两面，一面主要问前端的东西，例如html、css、js，当然还是有其他方面的知识，但是那些只占很少很少部分，几乎可以忽略。一面中，面试官问了我一个问题，“你觉得前端应该学些什么”，我霹雳啪啦说了一串，包括后端的一些东西，对我的答案，面试官还是比较认同的，但是最后说了句，前端其实就是html、css、js。当他帮我明确了这个概念，我对二面有了比较大的希望，因为就这三个来说，我认为考查点不多，而且自己还是会很多东西。 一面面了一个多小时，一面通过后，还是很开心的。面试的学生中，绝大多数都是研究生，前两天我的很多同学陆陆续续下去面试算法和研发，但是没有一个通过一面；而前端更是，本科生本来做前端的就不多，我映像中那天通过一面的人最多也就6个，除我之外都是研究生，所以想一想，感觉自己还是蛮厉害的嘛，通过二面应该也不是问题的吧。 但是二面也就是终面完全和我想的不同，二面没有问html、css、js而是谈一些算法、网络等专业课的知识，问如何解决因网络延迟造成的过期请求，如何尽可能实现电子时钟的精确性……对于最后的这两个问题，我只能说呵呵了，当时心里就很不爽，你明知道我现在大三，网络都还没怎么学呢，你就偏偏拿这些东西考我，想赶人走就明说，何必故意让人难堪。很无奈的表明我不会后，面试官说，这些东西不在于学校老师教没教，很多人很早前自己就会把这些东西学得很熟。听完这句话，心里边真的很不爽，这不是故意为难我吗，在计算机这个行业，想难倒一个人太容易了…… 很郁闷地离开了阿里，在回学校的地铁上，反复想反复想，最后不得不承认还是自己实力不够强，不能怪别人。上了大学很长时间都是自我感觉良好，但其实你算个屁啊，你有踏踏实实地学习过吗，你有专专心心的研究某个东西而废寝忘食吗，自己以前做的那些，所有人都能做到，而现在的问题是，你又凭什么觉得比别人优秀！ 要相比别人强，你就得去做别人不愿意、不敢做的事，你就得比别人细心，比别人努力，而这些细节的地方往往都被我忽略掉了，从现在起，脚踏实地，静心好好学习，不要浮躁，一定要认真、专注，在大学最后一年半的时间里，好好加油，问心无愧！ &nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"Web前端面试备考资料","slug":"web前端面试备考资料","date":"2014-04-15T11:18:08.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/8863/","link":"","permalink":"http://www.voyax.meposts/8863/","excerpt":"","text":"周四参加阿里前端面试，这里将准备过程中觉得有价值的面试题做个整理。 # 你真的了解HTML吗？（雅虎面试题)有这么一段HTML，请挑毛病： 哥写的不是HTML，是寂寞。 我说：不要迷恋哥，哥只是一个传说这是原来雅虎一道笔试题（文字变了变），用了很多年了，还没有一个人完全答对过。出这道题的动机是，太多人觉得HTML太简单，但它恰恰又是前端开发中最基础最重要的部分。HTML结构设计的合不合理，直接影响到代码易不易维护，灵不灵活，同时事关网页性能，协作效率。碰到不少人认为前端开发就是javascript开发，大错特错啊。javascript, html, css这三个前端开发的基础支柱，性质完全不同又紧密关联，对它们的正确理解，合理应用是专业与非专业的区别。有些后端工程师可以写出很漂亮的JS，但他们真的不懂怎么合理的把js, html, css结合起来应用。对html的准确把握，不像学一般的编程语言那样，而是建立在丰富实践经验和体会的基础上，是前端的工程师的基本功。言归正传。这道题的考点：## 考点1：html和 xhtml的区别这行代码在html 4.01 strict下是完全正确的，在xhtml 1.0 strict下是错误一堆的。所以明显是一个考点。在xhtml下所有标签是闭合的，p,br需要闭合, 标签不允许大写，P要小写。同时nbsp和br必须包含在容器里。html下这些都不是错。p在html里是可选闭合标签，是可以不用闭合的。这个考点告诉你xhtml是多么苛刻。这是基本考点，答对，你能拿到60分。## 考点2：考样式分离用nbsp控制缩进是不合理的。应该用CSS干这事。所以应该删掉nbsp## 考点3：合理使用标签br是强制折行标签，p是段落。原题用连续的br制造两个段落的效果，效果是达到了，但显然用的不合理，段落间距后期无法再控制。正确的做法是用两个p表现两个段落。“我说”后面是正常的文字折行用br是合理的。上面全答对，你就能拿到100分。对原题改进的结果：html 4.01:哥写的不是HTML，是寂寞。我说： 不要迷恋哥，哥只是一个传说xhtml 1.0:哥写的不是HTML，是寂寞。我说： 不要迷恋哥，哥只是一个传说加分：合理的用语义化标签在前面的基础上合理的用语义化标签，对内容进行必要的标记，是加分的。但过度的使用标签，就画蛇添足了。如“我说”的话，可以用q标签标注。哥写的不是HTML，是寂寞。我说： 不要迷恋哥，哥只是一个传说我觉得这就够了，如果再进一步，“我”用cite标注，“HTML” 用abbr或acronym标注（至于再讨论abbr和acronym的区别就太较真了），也OK。再复杂就没必要了。 哥写的不是HTML，是寂寞。 我说： 不要迷恋哥，哥只是一个传说 #介绍所知道的CSS hack技巧由于不同的浏览器对CSS的支持及解析结果不一样，还由于CSS中的优先级的关系。我们就可以根据这个来针对不同的浏览器来写不同的CSS。CSS Hack大致有3种表现形式，CSS类内部Hack、选择器Hack以及HTML头部引用(if IE)Hack，CSS Hack主要针对类内部Hack：比如 IE6能识别下划线”“和星号” “，IE7能识别星号” “，但不能识别下划线”“，而firefox两个都不能认识。选择器Hack：比如 IE6能识别html .class{}，IE7能识别+html .class{}或者*:first-child+html .class{}HTML[1]头部引用(if IE)Hack：针对所有IE：&lt; ![endif]–&gt;，针对IE6及以下版本：&lt; ![endif]–&gt;，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。书写顺序，一般是将识别能力强的浏览器的CSS写在前面。下面如何写里面说得更详细些。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"无题","slug":"无题","date":"2014-04-12T18:35:17.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/58858/","link":"","permalink":"http://www.voyax.meposts/58858/","excerpt":"我在晨光之中颂叹吟咏，为了衰朽在寒冷深夜里的梦想我在晨曦之中疯癫欢唱，为了沉寂在寂静从前中的悲欢 自断大龙自毁辛劳 如果燃尽我的最后，还能带来我曾泼洒心血的地方的一线光辉，也是好事吧我从火中归来，前路还是漫漫无际的长途只有自己还在纠结吧。。。又能怎么样呢强笑、强笑，说无所谓的人，多数更在乎吧 做不到，逃不了，挺不住，强笑","text":"我在晨光之中颂叹吟咏，为了衰朽在寒冷深夜里的梦想我在晨曦之中疯癫欢唱，为了沉寂在寂静从前中的悲欢 自断大龙自毁辛劳 如果燃尽我的最后，还能带来我曾泼洒心血的地方的一线光辉，也是好事吧我从火中归来，前路还是漫漫无际的长途只有自己还在纠结吧。。。又能怎么样呢强笑、强笑，说无所谓的人，多数更在乎吧 做不到，逃不了，挺不住，强笑 青年，要一直快乐啊！","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"链接器工具错误 LNK2026 模块对于 SAFESEH 映像是不安全的","slug":"链接器工具错误-lnk2026-模块对于-safeseh-映像是不安全的","date":"2014-04-07T11:48:02.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/38054/","link":"","permalink":"http://www.voyax.meposts/38054/","excerpt":"#### 错误消息模块对于 SAFESEH 映像是不安全的/SAFESEH.aspx) 已指定，但某一模块与安全异常处理功能不兼容。如果要将此模块用于 /SAFESEH，则需要使用 Visual C++ .NET 2003（或更高版本）编译器重新编译该模块。","text":"#### 错误消息模块对于 SAFESEH 映像是不安全的/SAFESEH.aspx) 已指定，但某一模块与安全异常处理功能不兼容。如果要将此模块用于 /SAFESEH，则需要使用 Visual C++ .NET 2003（或更高版本）编译器重新编译该模块。#### 说明在指定 /SAFESEH 后，只有在链接器还可以生成映像的安全异常处理程序表的情况下，该链接器才会生成一个映像。该表指定其异常处理程序适合于该映像的操作系统。只有在对 x86 目标进行链接时，/SAFESEH 才有效。已说明异常处理程序的平台不支持 /SAFESEH。例如，在 x64 和 Itanium 上，所有异常处理程序都在 PDATA 中说明。ML64.exe 支持添加批注，这些批注将 SEH 信息（XDATA 和 PDATA）发出到映像中，允许您通过 ml64 函数展开。有关更多信息，请参见 MASM for x64 (ml64.exe).aspx)。如果未指定 /SAFESEH，链接器将生成具有安全异常处理程序表的映像（如果所有模块都与安全异常处理功能兼容）。如果任意模块与安全异常处理功能不兼容，则最终的映像将不会包含安全异常处理程序表。如果 /SUBSYSTEM.aspx) 指定 WINDOWSCE 或某一 EFI_ 选项，则链接器将不尝试生成具有安全异常处理程序表的映像，因为上述任何子系统都不可以利用这些信息。如果指定了 */SAFESEH:NO，则链接器将不会生成具有安全异常处理程序表的映像，即使所有模块都与安全异常处理程序功能兼容。链接器无法生成映像的最常见的原因是：该链接器的一个或多个输入文件（模块）与安全异常处理程序功能不兼容。模块与安全异常处理程序不兼容的一个常见原因是：该模块是通过来自以前版本的 Visual C++ 的编译器创建的。通过使用 .SAFESEH.aspx)，还可以将函数注册为结构化的异常处理程序。在 Microsoft Visual C++ 2005 中，无法将现有的二进制文件标记为具有安全异常处理程序（或不具有异常处理程序）；必须在生成时添加关于安全异常处理的信息。链接器能否生成安全异常处理程序表取决于使用 C 运行时库的应用程序。如果使用 /NODEFAULTLIB.aspx) 进行链接，并希望得到一张安全异常处理程序表，则需要提供加载配置结构（例如可在 loadcfg.c CRT 源文件中找到的结构），此结构包含为 Visual C++ 定义的所有项。#### 解决方案### 在 Visual Studio 开发环境中设置此链接器选项1. 打开此项目的“属性页”对话框。有关详细信息，请参见设置 Visual C++ 项目属性.aspx)。2. 单击“链接器”文件夹。3. 单击“命令行”属性页。4. 将/SAFESEH:NO键入“附加选项”框中。&nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"Gedit中文乱码","slug":"gedit中文乱码","date":"2014-04-07T04:53:43.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/64885/","link":"","permalink":"http://www.voyax.meposts/64885/","excerpt":"","text":"缺省配置下，用 Ubuntu 的文本编辑器（Gedit）打开GB18030（繁体中文用户请将这里的出现的GB18030替换成BIG5或BIG5-HKSCS）类型的中文编码文本文件时，将会出现乱码。 出现这种情况的原因是，Gedit 使用一个编码匹配列表，只有在这个列表中的编码才会进行匹配，不在这个列表中的编码将显示为乱码。您要做的就是将 GB18030 加入这个匹配列表。 Gedit 3.x 版本设置 （适用于Ubuntu 11.10及以后） 命令方式gsettings set org.gnome.gedit.preferences.encodings auto-detected “[‘GB18030’, ‘UTF-8’, ‘CURRENT’, ‘ISO-8859-15’, ‘UTF-16’]” 图形方式 运行dconf-editor 展开/org/gnome/gedit/preferences/encodings auto-detected的Value中加入 ‘GB18030’ ，加在UTF-8前面； Gedit 2.x 版本设置 （适用于Ubuntu 11.04及以前）命令方式gconftool-2 –set –type=list –list-type=string /apps/gedit-2/preferences/encodings/auto_detected “[GB18030,UTF-8,CURRENT,ISO-8859-15,UTF-16]” 图形方式 运行gconf-editor 展开/apps/gedit-2/preferences/encodings 在auto_detected键中新增GB18030，并使它位于UTF-8前面，确定。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.voyax.me/tags/Linux/"}]},{"title":"集线器和交换机的区别","slug":"集线器、交换机的区别","date":"2014-04-05T16:39:18.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/43505/","link":"","permalink":"http://www.voyax.meposts/43505/","excerpt":"","text":"作为局域网组建的重要设备：交换机和集线器，都起着局域网的数据传送&ldquo;枢纽&rdquo;的作用，交换机和集线器到底有什么区别？ &lt;span style=&quot;color: #ff0000;&quot;&gt;交换机&lt;/span&gt;，集线器是当今局域网络的重要连接设备。 &lt;span style=&quot;color: #ff0000;&quot;&gt;集线器（HUB&lt;/span&gt;）是计算机网络中连接多个计算机或其他设备的连接设备,是对网络进行集中管理的最小单元。 交换机的英文名称之为&amp;ldquo;Switch&amp;rdquo;，它是集线器的升级换代产品，从外观上来看的话，它与集线器基本上没有多大区别，都是带有多个端口的长方形盒状体。 交换机是按照通信两端传输信息的需要，用人工或设备自动完成的方法把要传输的信息送到符合要求的相应路由上的技术统称。广义的交换机就是一种在通信系统中完成信息交换功能的设备。 所谓交换机其实是从集线器技术发展而来的。如果用最简单的语言叙述交换机与集线器的区别，那就应该是智能与非智能的差别。集线器说白了只是连接多个计算机的设备，它只能起到信号放大、传输的作用，但不能对信号中的碎片进行处理，所以在传输过程中非常容易出错。而交换机则可以看作是一种智能型的集线器，它除了包括集线器的所有特性外，还具有自动寻址、交换、处理的功能。并且在传递过程中，只有发送源与接受源独立工作，其间不与其它端口发生关系，从而达到防止数据丢失和提高吞吐量的目的。 下来我将从**&lt;span style=&quot;color: #ff0000;&quot;&gt;交换机与集线器的概念，种类，特点，OSI体系结构，工作方式&lt;/span&gt;**等基本问题上对二者的区别进行分析说明。 &lt;!--more--&gt; &lt;span style=&quot;color: #ff0000;&quot;&gt;**1.交换机和集线器的概念&amp;nbsp;**&lt;/span&gt; **&lt;span style=&quot;color: #ff0000;&quot;&gt;1.1.交换机&lt;/span&gt;** 交换机的英文名称之为&amp;ldquo;Switch&amp;rdquo;，它是集线器的升级换代产品，从外观上来看的话，它与集线器基本上没有多大区别，都是带有多个端口的长方形盒状体。交换机是按照通信两端传输信息的需要，用人工或设备自动完成的方法把要传输的信息送到符合要求的相应路由上的技术统称。广义的交换机就是一种在通信系统中完成信息交换功能的设备。 **&lt;span style=&quot;color: #ff0000;&quot;&gt;1.2.集线器 &lt;/span&gt;** 集线器（HUB）是计算机网络中连接多个计算机或其他设备的连接设备,是对网络进行集中管理的最小单元。英文HUB就是中心的意思,像树的主干一样,它是各分支的汇集点。许多种类型的网络都依靠集线器来连接各种设备并把数据分发到各个网段。HUB基本上是一个共享设备,其实质是一个中继器,主要提供信号放大和中转的功能,它把一个端口接收的全部信号向所有端口分发出去。 &lt;!--more--&gt; **&lt;span style=&quot;color: #ff0000;&quot;&gt;2.交换机和集线器的种类&amp;nbsp;&lt;/span&gt;** 交换机和集线器从不同的方面和角度有着不同的分类。 **&lt;span style=&quot;color: #ff0000;&quot;&gt;2.1.HUB集线器的种类&amp;nbsp;&lt;/span&gt;** 集线器有多种类型,各个种类具有特定的功能、提供不同等级的服务。 &lt;span style=&quot;color: #ff6600;&quot;&gt;2.1.1.依据总线带宽的不同&lt;/span&gt;,HUB分为10M、100M和10M/100M自适应三种； 若按配置形式的不同可分为独立型、模块化和堆叠式三种。 &lt;span style=&quot;color: #ff6600;&quot;&gt;2.1.2.根据端口数目的不同&lt;/span&gt;主要有8口、16口和24口几种。 &lt;span style=&quot;color: #ff6600;&quot;&gt;2.1.3.根据工作方式&lt;/span&gt;可分为智能型和非智能型两种。目前所使用的HUB基本是前三种分类的组合,如我们常在广告中看到的10M/100M自适应智能型、可堆叠式HUB等。 &lt;span style=&quot;color: #ff6600;&quot;&gt;2.1.4.依据工作方式&lt;/span&gt;区分有较普遍的意义,可以进一步划分为被动集线器、主动集线器、智能集线器和交换集线器四种。 **&lt;span style=&quot;color: #ff0000;&quot;&gt;2．2.交换机的分类&amp;nbsp;&lt;/span&gt;** &lt;span style=&quot;color: #ff9900;&quot;&gt;2．2．1.按照现在复杂的网络构成方式&lt;/span&gt;，网络交换机被划分为接入层交换机、汇聚层交换机和核心层交换机。其中，核心层交换机全部采用机箱式模块化设计，目前已经基本都设计了与之相配备的1000BASE-T模块，核心层交换机的选购在本文中不做讨论。接入层支持1000BASE-T的以太网交换机基本上是固定端口式交换机，以10/100Mbps端口为主，并且以固定端口或扩展槽方式提供1000BASE-T的上连端口。汇聚层1000BASE-T交换机同时存在机箱式和固定端口式2种设计，可以提供多个1000BASE-T 端口，一般也可以提供1000BASE-X等其他形式的端口。接入层和汇聚层交换机共同构成完整的中小型局域网解决方案。 &lt;span style=&quot;color: #ff9900;&quot;&gt;2．2．2\\. 按照OSI的7层网络模型&lt;/span&gt;，交换机又可以分为第二层交换机、第三层交换机、第四层交换机等等，一直到第七层交换机。基于MAC地址工作的第二层交换机最为普遍，用于网络接入层和汇聚层。基于IP地址和协议进行交换的第三层交换机普遍应用于网络的核心层，也少量应用于汇聚层。部分第3层交换机也同时具有第四层交换功能，可以根据数据帧的协议端口信息进行目标端口判断。第四层以上的交换机称之为内容型交换机，主要用于互联网数据中心，不在本文讨论范围之内。 &lt;span style=&quot;color: #ff9900;&quot;&gt;2．2．3.按照交换机的可管理性&lt;/span&gt;，又可以分为可管理型交换机和非可管理型交换机，它们的区别在于对SNMP、RMON等网管协议的支持。可管理型交换机便于网络监控，但成本也相对较高。大中型网络在汇聚层应该选择可管理型交换机，在接入层视应用需要而定，核心层交换机全部是可管理型交换机。 &lt;!--more--&gt; **&lt;span style=&quot;color: #ff0000;&quot;&gt;3.交换机和集线器的特点&amp;nbsp;&lt;/span&gt;** **&lt;span style=&quot;color: #ff0000;&quot;&gt;3.1．Hub的特点&amp;nbsp;&lt;/span&gt;** 在星型结构中，它是连接的中间结点，它起放大信号的作用。所有设备共享Hub的带宽，也就是说，如果hub的带宽是10M，连结了10了设备，每个设备就是1M，Hub所有端口共享一个MAC地址。 **&lt;span style=&quot;color: #ff0000;&quot;&gt;3.2．switch 的特点&amp;nbsp;&lt;/span&gt;** 用于星型结构时，它作为中心结点起放大信号的作用，端口不共享带宽，如果是一个10M的switch，那么每个端口的带宽就是10M，每个端口拥有自己的MAC地址。 交换机的主要功能包括物理编址、网络拓扑结构、错误校验、帧序列以及流量控制。目前一些高档交换机还具备了一些新的功能，如对VLAN（虚拟局域网）的支持、对链路汇聚的支持，甚至有的还具有路由和防火墙的功能。 交换机除了能够连接同种类型的网络之外，还可以在不同类型的网络（如以太网和快速以太网）之间起到互连作用。如今许多交换机都能够提供支持快速以太网或FDDI等的高速连接端口，用于连接网络中的其它交换机或者为带宽占用量大的关键服务器提供附加带宽。 它是一个网络设备，拥有路由器的一部分功能，它可以决定接收到的数据向什么地方发送，它的速度比路由器要快。 &lt;!--more--&gt; &lt;span style=&quot;color: #ff0000;&quot;&gt;**4.交换机和集线器的主要区别&amp;nbsp;**&lt;/span&gt; 通过从上面各方面的分析我们可以知道交换机和集线器的主要区别分为四个方面，分别是在OSI体系结构，数据传输方式，带宽占用方式和传输模式上。 **&lt;span style=&quot;color: #ff0000;&quot;&gt;4.1．OSI体系结构上的区别 &lt;/span&gt;** 集线器属于OSI的第一层物理层设备，而交换机属于OSI的第二层数据链路层设备。也就意味着集线器只是对数据的传输起到同步、放大和整形的作用，对数据传输中的短帧、碎片等无法进行有效的处理，不能保证数据传输的完整性和正确性；而交换机不但可以对数据的传输做到同步、放大和整形，而且可以过滤短帧、碎片等。 &lt;span style=&quot;color: #ff0000;&quot;&gt;**4.2．数据传输方式上的区别&amp;nbsp;**&lt;/span&gt; 目前，80％的局域网（LAN）是以太网，在局域网中大量地使用了集线器（HUB）或交换机（Switch）这种连接设备。利用集线器连接的局域网叫共享式局域网，利用交换机连接的局域网叫交换式局域网。 &lt;span style=&quot;color: #ff0000;&quot;&gt;4.2.1．工作方式不同&lt;/span&gt; 我们先来谈谈网络中的共享和交换这两个概念。在此，我们打个比方，同样是10个车道的马路，如果没有给道路标清行车路线，那么车辆就只能在无序的状态下抢道或占道通行，容易发生交通堵塞和反向行驶的车辆对撞，使通行能力降低。为了避免上述情况的发生，就需要在道路上标清行车线，保证每一辆车各行其道、互不干扰。共享式网络就相当于前面所讲的无序状态，当数据和用户数量超出一定的限量时，就会造成碰撞冲突，使网络性能衰退。而交换式网络则避免了共享式网络的不足，交换技术的作用便是根据所传递信息包的目的地址，将每一信息包独立地从端口送至目的端口,避免了与其它端口发生碰撞，提高了网络的实际吞吐量。 共享式以太网存在的主要问题是所有用户共享带宽，每个用户的实际可用带宽随网络用户数的增加而递减。这是因为当信息繁忙时，多个用户都可能同进&amp;ldquo;争用&amp;rdquo;一个信道，而一个通道在某一时刻只充许一个用户占用，所以大量的经常处于监测等待状态，致使信号在传送时产生抖动、停滞或失真，严重影响了网络的性能。 交换式以太网中，交换机供给每个用户专用的信息通道，除非两个源端口企图将信息同时发往同一目的端口，否则各个源端口与各自的目的端口之间可同时进行通信而不发生冲突。 &lt;span style=&quot;color: #ff0000;&quot;&gt;4.2.2．工作机理不同&lt;/span&gt; 集线器的工作机理是广播（broadcast），无论是从哪一个端口接收到什么类型的信包，都以广播的形式将信包发送给其余的所有端口，由连接在这些端口上的网卡（NIC）判断处理这些信息，符合的留下处理，否则丢弃掉，这样很容易产生广播风暴，当网络较大时网络性能会受到很大的影响。从它的工作状态看，HUB的执行效率比较低（将信包发送到了所有端口），安全性差（所有的网卡都能接收到，只是非目的地网卡丢弃了信包）。而且一次只能处理一个信包，在多个端口同时出现信包的时候就出现碰撞，信包按照串行进行处理，不适合用于较大的网络主干中。 交换机的工作就完全不同，它通过分析Ethernet包的包头信息（其中包含了原MAC地址、目标MAC地址、信息长度等），取得目标MAC地址后，查找交换机中存储的地址对照表（MAC地址对应的端口），确认具有此MAC地址的网卡连接在哪个端口上，然后仅将信包送到对应端口，有效的有效的抑制广播风暴的产生。 这就是Switch 同HUB最大的不同点。而Switch内部转发信包的背板带宽也远大于端口带宽，因此信包处于并行状态，效率较高，可以满足大型网络环境大量数据并行处理的要求。 &lt;span style=&quot;color: #ff0000;&quot;&gt;**4.3．带宽占用方式上的区别&amp;nbsp;**&lt;/span&gt; 集线器不管有多少个端口，所有端口都是共享一条带宽，在同一时刻只能有二个端口传送数据，其他端口只能等待，同时集线器只能工作在半双工模式下；而对于交换机而言，每个端口都有一条独占的带宽，这样在速率上对于每个端口来说有了根本的保障。当二个端口工作时并不影响其他端口的工作，同时交换机不但可以工作在半双工模式下而且可以工作在全双工模式下。 &lt;span style=&quot;color: #ff0000;&quot;&gt;**4.4．传输模式上的区别&amp;nbsp;**&lt;/span&gt; 集线器只能采用半双工方式进行传输的，因为集线器是共享传输介质的，这样在上行通道上集线器一次只能传输一个任务，要么是接收数据，要么是发送数据。而交换机则不一样，它是采用全双工方式来传输数据的，因此在同一时刻可以同时进行数据的接收和发送，这不但令数据的传输速度大大加快，而且在整个系统的吞吐量方面交换机比集线器至少要快一倍以上，因为它可以接收和发送同时进行，实际上还远不止一倍，因为端口带宽一般来说交换机比集线器也要宽许多倍。 举个简单的例子，比如说让两组人同时给对方互相传输一个文件，从一个人传到另一个的时间为1分钟。如果是用集线器的话，需要的时间是4分钟。数据先从一个人传到对方那里，然后对方再传回来。接着才能是另一组做相同的工作，这样算下来就是4分钟。但是用交换机的话速度就快多了，在相同情况下只需要1分钟就足够了。由于每个端口都是独立的，所以这两组人可以同时传输数据，再因为交换机可以工作在全双工下，所以每两个人也可以同时传输，换句话说这4个人是在同一个时间内完成的工作。所以我们也可以把集线器和交换机的处理能力看做串行处理与并行处理。 &lt;!--more--&gt; 5.总结 综上所述，集线器的功能只是一个多端口的转发器，无论从哪个端口传出来的讯号都会整形再生放大后向所有的端口广播出去，并且所有的端口都会挤用同一个共享信带的带宽，造成数据量大时所有端口的带宽大幅减少；而交换机相当于多端口桥，它为用户提供的是独占的点对点的连接，数据包只发向目的端口而不会向所有端口发送，这样减少了信号在网络发生碰撞，而且交换机上的所有端口均有独享的信道带宽。 交换机是继集线器基础上开发的一新的网络连接设备，拥有着更好更强大的功能和优点，而且还有着很高的性价比，更适应当今网络的需求。通过以上分析，我们不难看出交换机与集线器相比的明显优势。我相信在不久的以后交换机将会彻底替代集线器。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.voyax.me/tags/计算机网络/"}]},{"title":"我不会安慰人，只是希望你们好好的","slug":"我不会安慰人，只是希望你们好好的","date":"2014-04-05T07:02:36.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/36051/","link":"","permalink":"http://www.voyax.meposts/36051/","excerpt":"","text":"最近看着同学发的一些心情不是很好的状态，很想在下边留言说点什么，却发现自己学不会煽情，学不会安慰；今天中午妈给我打了个电话，听到妈说话的第一个字的语气，我就感到有什么不好的事情，妈妈边哭边和我说着今天家里发生的不愉快的事情，我很明白，虽然我远在北京，但此时我是她唯一觉得可以依靠的人；我一边听，一边想着说点什么安慰妈妈，就像以前她安慰我一样，可是……可是，我一句话也想不出，只有“嗯……嗯……”表示我还听着电话……我不知道自己是怎样结束这通电话的，只是很恨自己，竟然一句安慰的话都说不出，妈妈此时还有多伤心…… 从小时候起，我就一直不太会在大家面前表现自己，很多东西心里边明白得很，却很难说出口，慢慢地，我习惯了别人对我的安慰，而对于别人的痛苦，我却措手无策，不是不关心，而是太在意……对于很多人的抱怨和不开心，若我愿意，也可以没心没肺地说“没关系，过去了就过去了嘛，开心点……”之类的话，但又有何用，别人经历的事情自然比你更清楚，这样的搪塞，没有丝毫意义，但除了这些，我又究竟能为你什么…… 一直处于一个很尴尬的状态，很想安慰别人，帮助别人，一遍又一遍看着别人发的状态，一遍又一遍回想说的别人说的那些话，却始终不会主动发消息或者打电话。 因为太在意，担心所说的话会成为伤害；因为太在意，害怕说出口后便无话可说；因为太在意，只能选择沉默…… 一个同学说过一句话：我希望自己是一颗大树，努力地吸取营养，给人依靠。 我不会说安慰的话，只希望我所爱的人都要好好的，好好的","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"【转】OpenGL基础图形编程","slug":"【转】opengl基础图形编程","date":"2014-04-03T16:19:28.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/52520/","link":"","permalink":"http://www.voyax.meposts/52520/","excerpt":"","text":"**一、OpenGL与3D图形世界 1.1、OpenGL使人们进入三维图形世界我们生活在一个充满三维物体的三维世界中，为了使计算机能精确地再现这些物体，我们必须能在三维空间描绘这些物体。我们又生活在一个充满信息的世界中，能否尽快地理解并运用这些信息将直接影响事业的成败，所以我们需要用一种最直接的形式来表示这些信息。最近几年计算机图形学的发展使得三维表现技术得以形成，这些三维表现技术使我们能够再现三维世界中的物体，能够用三维形体来表示复杂的信息，这种技术就是可视化（Visualization）技术。可视化技术使人能够在三维图形世界中直接对具有形体的信息进行操作，和计算机直接交流。这种技术已经把人和机器的力量以一种直觉而自然的方式加以统一，这种革命性的变化无疑将极大地提高人们的工作效率。可视化技术赋予人们一种仿真的、三维的并且具有实时交互的能力，这样人们可以在三维图形世界中用以前不可想象的手段来获取信息或发挥自己创造性的思维。机械工程师可以从二维平面图中得以解放直接进入三维世界，从而很快得到自己设计的三维机械零件模型。医生可以从病人的三维扫描图象分析病人的病灶。军事指挥员可以面对用三维图形技术生成的战场地形，指挥具有真实感的三维飞机、军舰、坦克向目标开进并分析战斗方案的效果。更令人惊奇的是目前正在发展的虚拟现实技术，它能使人们进入一个三维的、多媒体的虚拟世界，人们可以游历远古时代的城堡,也可以遨游浩翰的太空。所有这些都依赖于计算机图形学、计算机可视化技术的发展。人们对计算机可视化技术的研究已经历了一个很长的历程，而且形成了许多可视化工具，其中SGI公司推出的GL三维图形库表现突出，易于使用而且功能强大。利用GL开发出来的三维应用软件颇受许多专业技术人员的喜爱，这些三维应用软件已涉及建筑、产品设计、医学、地球科学、流体力学等领域。随着计算机技术的继续发展，GL已经进一步发展成为OpenGL，OpenGL已被认为是高性能图形和交互式视景处理的标准，目前包括ATT公司UNIX软件实验室、IBM公司、DEC公司、SUN公司、HP公司、Microsoft公司和 SGI公司在内的几家在计算机市场占领导地位的大公司都采用了OpenGL图形标准。值得一提的是，由于Microsoft公司在 Windows NT中提供OpenGL图形标准，OpenGL将在微机中广泛应用，尤其是OpenGL三维图形加速卡和微机图形工作站的推出，人们可以在微机上实现三维图形应用，如CAD设计、仿真模拟、三维游戏等，从而更有机会、更方便地使用OpenGL及其应用软件来建立自己的三维图形世界。 1.2、OpenGL提供直观的三维图形开发环境**OpenGL实际上是一种图形与硬件的接口。它包括了120个图形函数，开发者可以用这些函数来建立三维模型和进行三维实时交互。与其他图形程序设计接口不同，OpenGL提供了十分清晰明了的图形函数，因此初学的程序设计员也能利用OpenGL的图形处理能力和1670万种色彩的调色板很快地设计出三维图形以及三维交互软件。OpenGL强有力的图形函数不要求开发者把三维物体模型的数据写成固定的数据格式，这样开发者不但可以直接使用自己的数据，而且可以利用其他不同格式的数据源。这种灵活性极大地节省了开发者的时间，提高了软件开发效益。长期以来，从事三维图形开发的技术人员都不得不在自己的程序中编写矩阵变换、外部设备访问等函数，这样为调制这些与自己的软件开发目标关系并不十分密切的函数费脑筋，而OpenGL正是提供一种直观的编程环境，它提供的一系列函数大大地简化了三维图形程序。例如： OpenGL提供一系列的三维图形单元供开发者调用。 OpenGL提供一系列的图形变换函数。 OpenGL提供一系列的外部设备访问函数，使开发者可以方便地访问鼠标、键盘、空间球、数据手套等这种直观的三维图形开发环境体现了OpenGL的技术优势，这也是许多三维图形开发者热衷于OpenGL的缘由所在。1.3、OpenGL成为目前三维图形开发标准OpenGL成为目前三维图形开发标准在计算机发展初期，人们就开始从事计算机图形的开发。直到计算机硬软件和计算机图形学高度发达的九十年代，人们发现复杂的数据以视觉的形式表现时是最易理解的，因而三维图形得以迅猛发展，于是各种三维图形工具软件包相继推出，如PHIGS、PEX、 RenderMan等。这些三维图形工具软件包有些侧重于使用方便，有些侧重于渲染效果或与应用软件的连接，但没有一种三维工具软件包在交互式三维图形建模能力、外部设备管理以及编程方便程度上能够OpenGL相比拟。OpenGL经过对GL的进一步发展，实现二维和三维的高级图形技术，在性能上表现得异常优越，它包括建模、变换、光线处理、色彩处理、动画以及更先进的能力，如纹理影射、物体运动模糊等。OpenGL的这些能力为实现逼真的三维渲染效果、建立交互的三维景观提供了优秀的软件工具。OpenGL在硬件、窗口、操作系统方面是相互独立的。许多计算机公司已经把 OpenGL集成到各种窗口和操作系统中，其中操作系统包括UNIX、Windows NT、DOS等，窗口系统有X窗口、Windows等。为了实现一个完整功能的图形处理系统，设计一个与OpenGL相关的系统结构为：其最底层是图形硬件，第二层为操作系统，第三层为窗口系统，第四层为OpenGL，第五层为应用软件。OpenGL是网络透明的，在客户 — 服务器（Client-Server）体系结构中，OpenGL允许本地和远程绘图。所以在网络系统中，OpenGL在X窗口、Windows或其它窗口系统下都可以以一个独立的图形窗口出现。OpenGL作为一个性能优越的图形应用程序设计界面（API）而适合于广泛的计算环境，从个人计算机到工作站和超级计算机，OpenGL都能实现高性能的三维图形功能。由于许多在计算机界具有领导地位的计算机公司纷纷采用OpenGL作为三维图形应用程序设计界面，OpenGL应用程序具有广泛的移植性。因此，OpenGL已成为目前的三维图形开发标准，是从事三维图形开发工作的技术人员所必须掌握的开发工具。 二、OpenGL概念建立 # &lt;&gt;function StorePage(){d=document;t=d.selection?(d.selection.type!=’None’?d.selection.createRange().text:’’):(d.getSelection?d.getSelection():’’);void(keyit=window.open(‘http://www.365key.com/storeit.aspx?t=&#39;+escape(d.title)+&#39;&amp;u=&#39;+escape(d.location.href)+&#39;&amp;c=&#39;+escape(t),&#39;keyit&#39;,&#39;scrollbars=no,width=475,height=575,left=75,top=20,status=no,resizable=yes&#39;));keyit.focus(); 2.1、OpenGL基本理解OpenGL是一个与硬件图形发生器的软件接口，它包括了100多个图形操作函数，开发者可以利用这些函数来构造景物模型、进行三维图形交互软件的开发。正如上一章所述，OpenGL是一个高性能的图形开发软件包。OpenGL支持网络，在网络系统中用户可以在不同的图形终端上运行程序显示图形。 OpenGL作为一个与硬件独立的图形接口，它不提供与硬件密切相关的设备操作函数，同时，它也不提供描述类似于飞机、汽车、分子形状等复杂形体的图形操作函数。用户必须从点、线、面等最基本的图形单元开始构造自己的三维模型。当然，象OpenInventor那样更高一级的基于OpenGL的三维图形建模开发软件包将提供方便的工具。因此OpenGL的图形操作函数十分基本、灵活。例如OpenGL中的模型绘制过程就多种多样，内容十分丰富，OpenGL提供了以下的对三维物体的绘制方式： 网格线绘图方式（wireframe）这种方式仅绘制三维物体的网格轮廓线。 深度优先网格线绘图方式（depth_cued）用网格线方式绘图，增加模拟人眼看物体一样，远处的物体比近处的物体要暗些。 反走样网格线绘图方式（antialiased）用网格线方式绘图，绘图时采用反走样技术以减少图形线条的参差不齐。 平面消隐绘图方式（flat_shade）对模型的隐藏面进行消隐，对模型的平面单元按光照程度进行着色但不进行光滑处理。 光滑消隐绘图方式（smooth_shade）对模型进行消隐按光照渲染着色的过程中再进行光滑处理，这种方式更接近于现实。 加阴影和纹理的绘图方式（shadows、textures）在模型表面贴上纹理甚至于加上光照阴影，使得三维景观象照片一样。 运动模糊的绘图方式（motion-blured）模拟物体运动时人眼观察所感觉的动感现象。 大气环境效果（atmosphere-effects）在三维景观中加入如雾等大气环境效果，使人身临其境。 深度域效果（depth-of-effects）类似于照相机镜头效果，模型在聚焦点处清晰，反之则模糊。这些三维物体绘图和特殊效果处理方式，说明OpenGL已经能够模拟比较复杂的三维物体或自然景观，这就是我们所面对的OpenGL。2.2、OpenGL工作流程整个OpenGL的基本工作流程如下图：其中几何顶点数据包括模型的顶点集、线集、多边形集，这些数据经过流程图的上部，包括运算器、逐个顶点操作等；图像数据包括象素集、影像集、位图集等，图像象素数据的处理方式与几何顶点数据的处理方式是不同的，但它们都经过光栅化、逐个片元（Fragment）处理直至把最后的光栅数据写入帧缓冲器。在OpenGL中的所有数据包括几何顶点数据和象素数据都可以被存储在显示列表中或者立即可以得到处理。OpenGL中，显示列表技术是一项重要的技术。OpenGL要求把所有的几何图形单元都用顶点来描述，这样运算器和逐个顶点计算操作都可以针对每个顶点进行计算和操作，然后进行光栅化形成图形碎片；对于象素数据，象素操作结果被存储在纹理组装用的内存中，再象几何顶点操作一样光栅化形成图形片元。整个流程操作的最后，图形片元都要进行一系列的逐个片元操作，这样最后的象素值BZ送入帧缓冲器实现图形的显示。2.3、OpenGL图形操作步骤在上一节中说明了OpenGL的基本工作流程，根据这个流程可以归纳出在OpenGL中进行主要的图形操作直至在计算机屏幕上渲染绘制出三维图形景观的基本步骤：1）根据基本图形单元建立景物模型，并且对所建立的模型进行数学描述（OpenGL中把：点、线、多边形、图像和位图都作为基本图形单元）。2）把景物模型放在三维空间中的合适的位置，并且设置视点（viewpoint）以观察所感兴趣的景观。3）计算模型中所有物体的色彩，其中的色彩根据应用要求来确定，同时确定光照条件、纹理粘贴方式等。4）把景物模型的数学描述及其色彩信息转换至计算机屏幕上的象素，这个过程也就是光栅化（rasterization）。在这些步骤的执行过程中，OpenGL可能执行其他的一些操作，例如自动消隐处理等。另外，景物光栅化之后被送入帧缓冲器之前还可以根据需要对象素数据进行操作。 三、WindowsNT下的OpenGL 3.1、Windows NT下的OpenGL函数如前面的章节所述，Windows NT下的OpenGL同样包含100多个库函数，这些函数都按一定的格式来命名，即每个函数都以gl开头。Windows NT下的OpenGL除了具有基本的OpenGL函数外，还支持其他四类函数： 相应函数 具体说明 OpenGL实用库 43个函数，每个函数以glu开头。 OpenGL辅助库 31个函数，每个函数以aux开头。 Windows专用库函数（WGL） 6个函数，每个函数以wgl开头。 Win32 API函数 5个函数，函数前面没有专用前缀。在OpenGL中有115个核心函数，这些函数是最基本的，它们可以在任何OpenGL的工作平台上应用。这些函数用于建立各种各样的形体，产生光照效果，进行反走样以及进行纹理映射，进行投影变换等等。由于这些核心函数有许多种形式并能够接受不同类型的参数，实际上这些函数可以派生出300 多个函数。OpenGL的实用函数是比OpenGL核心函数更高一层的函数，这些函数是通过调用核心函数来起作用的。这些函数提供了十分简单的用法，从而减轻了开发者的编程负担。OpenGL的实用函数包括纹理映射、坐标变换、多边形分化、绘制一些如椭球、圆柱、茶壶等简单多边形实体（本指南将详细讲述这些函数的具体用法）等。这部分函数象核心函数一样在任何OpenGL平台都可以应用。OpenGL的辅助库是一些特殊的函数，这些函数本来是用于初学者做简单的练习之用，因此这些函数不能在所有的OpenGL平台上使用，在Windows NT环境下可以使用这些函数。这些函数使用简单，它们可以用于窗口管理、输入输出处理以及绘制一些简单的三维形体。为了使OpenGL的应用程序具有良好的移植性，在使用OpenGL辅助库的时候应谨慎。6个WGL函数是用于连接OpenGL与Windows NT的，这些函数用于在Windows NT环境下的OpenGL窗口能够进行渲染着色，在窗口内绘制位图字体以及把文本放在窗口的某一位置等。这些函数把Windows与OpenGL揉合在一起。最后的5个Win32函数用于处理象素存储格式和双缓冲区，显然这些函数仅仅能够用于Win32系统而不能用于其它OpenGL平台。3.2、OpenGL基本功能OpenGL能够对整个三维模型进行渲染着色，从而绘制出与客观世界十分类似的三维景象。另外OpenGL还可以进行三维交互、动作模拟等。具体的功能主要有以下这些内容。 模型绘制OpenGL能够绘制点、线和多边形。应用这些基本的形体，我们可以构造出几乎所有的三维模型。OpenGL通常用模型的多边形的顶点来描述三维模型。如何通过多边形及其顶点来描述三维模型，在指南的在后续章节会有详细的介绍。 模型观察在建立了三维景物模型后，就需要用OpenGL描述如何观察所建立的三维模型。观察三维模型是通过一系列的坐标变换进行的。模型的坐标变换在使观察者能够在视点位置观察与视点相适应的三维模型景观。在整个三维模型的观察过程中，投影变换的类型决定观察三维模型的观察方式，不同的投影变换得到的三维模型的景象也是不同的。最后的视窗变换则对模型的景象进行裁剪缩放，即决定整个三维模型在屏幕上的图象。 颜色模式的指定OpenGL 应用了一些专门的函数来指定三维模型的颜色。程序员可以选择二个颜色模式，即RGBA模式和颜色表模式。在RGBA模式中，颜色直接由RGB值来指定；在颜色表模式中，颜色值则由颜色表中的一个颜色索引值来指定。程序员还可以选择平面着色和光滑着色二种着色方式对整个三维景观进行着色。 光照应用用OpenGL绘制的三维模型必须加上光照才能更加与客观物体相似。OpenGL提供了管理四种光（辐射光、环境光、镜面光和漫反射光）的方法，另外还可以指定模型表面的反射特性。 图象效果增强OpenGL提供了一系列的增强三维景观的图象效果的函数，这些函数通过反走样、混合和雾化来增强图象的效果。反走样用于改善图象中线段图形的锯齿而更平滑，混合用于处理模型的半透明效果，雾使得影像从视点到远处逐渐褪色，更接近于真实。 位图和图象处理OpenGL还提供了专门对位图和图象进行操作的函数。 纹理映射三维景物因缺少景物的具体细节而显得不够真实，为了更加逼真地表现三维景物，OpenGL提供了纹理映射的功能。OpenGL提供的一系列纹理映射函数使得开发者可以十分方便地把真实图象贴到景物的多边形上，从而可以在视窗内绘制逼真的三维景观。 实时动画为了获得平滑的动画效果，需要先在内存中生成下一幅图象，然后把已经生成的图象从内存拷贝到屏幕上，这就是OpenGL的双缓存技术（double buffer）。OpenGL提供了双缓存技术的一系列函数。 交互技术目前有许多图形应用需要人机交互，OpenGL提供了方便的三维图形人机交互接口，用户可以选择修改三维景观中的物体。3.3、Windows NT下OpenGL的结构OpenGL的作用机制是客户（client）/服务器（sever）机制，即客户（用OpenGL绘制景物的应用程序）向服务器（即OpenGL内核）发布OpenGL命令，服务器则解释这些命令。大多数情况下，客户和服务器在同一机器上运行。正是OpenGL的这种客户/服务器机制，OpenGL可以十分方便地在网络环境下使用。因此Windows NT下的OpenGL是网络透明的。正象Windows的图形设备接口（GDI）把图形函数库封装在一个动态链接库（Windows NT下的GDI32.DLL）内一样，OpenGL图形库也被封装在一个动态链接库内（OPENGL32.DLL）。受客户应用程序调用的OpenGL函数都先在OPENGL32.DLL中处理，然后传给服务器WINSRV.DLL。OpenGL的命令再次得到处理并且直接传给Win32的设备驱动接口（Device Drive Interface,DDI），这样就把经过处理的图形命令送给视频显示驱动程序。下图简要说明这个过程：**图3-1 OpenGL在Windows NT下运行机制 ** 在三维图形加速卡的GLINT图形加速芯片的加速支持下，二个附加的驱动程序被加入这个过程中。一个OpenGL可安装客户驱动程序（Installable Client Driver,ICD）被加在客户这一边，一个硬件指定DDI（Hardware-specific DDI）被加在服务器这边，这个驱动程序与Wind32 DDI是同一级别的。 图3-2 在三维图形加速下OpenGL运行机制四、OpenGL基础程序结构 用OpenGL编写的程序结构类似于用其他语言编写的程序。实际上，OpenGL是一个丰富的三维图形函数库，编写OpenGL程序并非难事，只需在基本C语言中调用这些函数，用法同Turbo C、Microsoft C等类似，但也有许多不同之处。本指南所有的程序都是在Windows NT的Microsoft Visual C++集成环境下编译连接的，其中有部分头文件和函数是为这个环境所用的，例如判别操作系统的头文件“glos.h”。此外，为便于各类读者同时快速入门，在短时间内掌握OpenGL编程的基本方法和技巧，指南中例子尽量采用标准ANSI C调用OpenGL函数来编写，而且所有例程都只采用OpenGL附带的辅助库中的窗口系统。此外，这样也便于程序在各平台间移植，尤其往工作站UNIX 操作系统移植时，也只需改动头文件等很少很少的部分。下面列出一个简单的OpenGL程序： 例4-1 OpenGL简单例程（Simple.c） #include &lt;GL/gl.h&gt; #include &lt;GL/glaux.h&gt; #include “glos.h” void main(void){auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);auxInitPosition(0,0,500,500);auxInitWindow(“simple”); glClearColor(0.0,0.0,0.0,0.0);glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0,0.0,0.0);glRectf(-0.5,-0.5,0.5,0.5); glFlush();_sleep(1000);} 这个程序运行结果是在屏幕窗口内画一个红色的方块。下面具体分析整个程序结构：首先，在程序最开始处是OpenGL头文件：&lt;GL/gl.h&gt;、&lt;GL/glaux.h&gt;。前一个是gl库的头文件，后一个是辅助库的头文件。此外，在以后的几章中还将说明OpenGL的另外两个头文件，一个是&lt;GL/glu.h&gt;实用库的头文件，另一个是&lt;GL/glx.h&gt;X窗口扩充库的头文件（这个常用在工作站上）。接下来是主函数main()的定义：一般的程序结构是先定义一个窗口： auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);auxInitPosition(0,0,500,500);auxInitWindow(“simple”); auxInitDisplayMode(AUX_SINGLE|AUX_RGBA)设置窗口显示模式为RGBA方式，即彩色方式，并且图形缓存为单缓存（SINGLE BUFFER）。 auxInitPosition(0, 0, 500, 500)定义窗口的初始位置，前两个参数(0, 0)为窗口的左上角点的屏幕坐标，后两个参数(500,500)为窗口的宽度和高度。auxInitWindow(“simple”)是窗口初始化，字符参数是窗口名称。然后是窗口内清屏： glClearColor(0.0,0.0,0.0,0.0); glClear(GL_COLOR_BUFFER_BIT); 第一句将窗口清为黑色，第二句将颜色缓冲区清为glClearColor(0.0, 0.0, 0.0, 0.0)命令所设置的颜色，即同窗口背景颜色一致。再接着是在窗口内画一个物体： glColor3f(1.0,0.0,0.0);glRectf(-0.5,-0.5,0.5,0.5); 很明显，第一句设置物体颜色，函数中前三个参数分别为R、G、B值，最后一个参数是Alpha值，范围都从0至1；第二句绘制一个二维矩形。注意：OpenGL是针对三维图形而言，因此用作OpenGL编程绘制物体必须意识到任何一个物体都是三维的，具有空间性，而显示于屏幕上的物体都是三维物体在二维平面上的投影。从表面上看，上述程序代码很简单，实际上已经用到了缺省的投影形式（正射投影）。再看glFlush()函数，表示强制绘图完成。最后一句_sleep(1000)，参数单位为毫秒，整句意思是保持现有状况一秒钟，然后结束程序运行。这个函数是VC++的库函数。总而言之，OpenGL程序基本结构为定义窗口、清理窗口、绘制物体、结束运行。 五、OpenGL的数据类型和函数名 OpenGL的数据类型定义可以与其它语言一致，但建议在ANSI C下最好使用以下定义的数据类型，例如GLint、GLfloat等。具体类型见表5-1。 前缀 数据类型 相应C语言类型 OpenGL类型b 8-bit integer signed char GLbytes 16-bit integer short GLshorti 32-bit integer long GLint,GLsizeif 32-bit floating-point float GLfloat,GLclampfd 64-bit floating-point double GLdouble,GLclampdub 8-bit unsigned integer unsigned char GLubyte,GLbooleanus 16-bit unsigned integer unsigned short GLushortui 32-bit unsigned integer unsigned long GLuint,GLenum,GLbitfield **表5-1 命令前缀和参数数据类型 ** OpenGL的库函数命名方式很有规律，了解这种规律后阅读和编写程序都比较容易方便。首先，每个库函数有前缀gl、glu、glx或aux，表示此函数分属于基本库、实用库、X窗口扩充库或辅助库，其后的函数名头字母大写，后缀是参数类型的简写，取i、f，参见表5-1。例： glVertex2i(2,4);glVertex3f(2.0,4.0,5.0); 注意：有的函数参数类型后缀前带有数字2、3、4。2代表二维，3代表三维，4代表alpha值（以后介绍）。有些OpenGL函数最后带一个字母v，表示函数参数可用一个指针指向一个向量（或数组）来替代一系列单个参数值。下面两种格式都表示设置当前颜色为红色，二者等价。 glColor3f(1.0,0.0,0.0);float color_array[]={1.0,0.0,0.0};glColor3fv(color_array); 除了以上基本命名方式外，还有一种带“”星号的表示方法，例如glColor()，它表示可以用函数的各种方式来设置当前颜色。同理，glVertex*v()表示用一个指针指向所有类型的向量来定义一系列顶点坐标值。最后，OpenGL也定义GLvoid类型，如果用C语言编写，可以用它替代void类型。六、OpenGL辅组库的基本使用 OpenGL是一个开放的系统，它是独立于任何窗口系统或操作系统的。尽管它包含了许多图形函数，但它却没有窗口函数，也没有从键盘和鼠标读取事件的函数，所以要初学者写出一个完整的图形程序是相当困难的。另外，OpenGL图形函数中只提供基本的几何原形：点、线、多边形，因此要创建基本的三维几何体如球、锥体等，也很不容易。而OpenGL辅助库就是为解决这些基本问题专门设计的，它提供了一些基本的窗口管理函数和三维图形绘制函数，能帮助初学者尽快进入OpenGL世界，掌握关键的三维图形技术，体会其中奇妙的乐趣。但是，对于复杂的应用，这些函数远远不够，只能作为参考。6.1、辅助库函数分类这一节内容可以作为手册查阅，初学者不必深究。辅助库函数大致分为六类： 6.1.1 窗口初始化和退出相关函数有三个，它们在第一章已提到，这里将详细介绍： void auxInitWindow(GLbyte *titleString) 打开一个由auxInitDisplayMode()和auxInitPosition()指定的窗口。函数参数是窗口标题，窗口背景缺省颜色是RGBA下的黑色或颜色表（color_index）下的0号调色板的颜色。按下Escape键可以完成关掉窗口、结束程序、全部清屏三项功能。 void auxInitDisplayMode(GLbitfield mask) 设置窗口显示模式。基本模式有RGBA或颜色表、单或双缓存，也可指定其他附加模式：深度、模板或累积缓存（depth,stencil,and/or accumulation buffer）。参数mask是一组位标志的联合（取或），AUX_RGBA或AUX_INDEX、AUX_SINGLE或AUX_DOUBLE，以及其它有效标志AUX_DEPTH、AUX_STENCIL或AUX_ACCUM。 void auxInitPosition(GLint x,GLint y,GLsizei width,GLsizei height) 设置窗口位置及大小。参数（x, y）为窗口的左上角点的屏幕坐标，参数（width, height）为窗口的宽度和高度，单位为象素，缺省值为（0, 0, 100, 100）。 6.1.2 窗口处理和事件输入当窗口创建后，且在进入主函数循环之前，应当登记以下列出的回调函数（callback function）： void auxReshapeFunc(void(*function)(GLsizei,GLsizei)) 定义窗口改变时形状重定函数。参数function是一个函数指针，这个函数带有两个参数，即窗口改变后的新宽度和新高度。通常，function是 glViewport()，显示裁减后的新尺寸，重定义投影矩阵，以便使投影后图像的比例与视点匹配，避免比例失调。若不调用 auxReshapeFunc()，缺省重定物体形状的函数功能是调用一个二维的正射投影矩阵。运用辅助库，窗口将在每个事件改变后自动重新绘制。 void auxKeyFunction(GLint key,void(*function)(void)) 定义键盘响应函数。参数function就是当按下key键时所调用的函数指针，辅助库为参数key定义了几个常量：AUX_0至AUX_9、 AUX_A至AUX_Z、AUX_a至AUX_z、AUX_LEFT、AUX_RIGHT、AUX_UP、AUX_DOWN（方向键）、 AUX_ESCAPE、AUX_SPACE或AUX_RETURN。 void auxMouseFunc(GLint button,Glint mode,void(function)(AUX_EVENTREC )) 定义鼠标响应函数。参数function就是当鼠标以mode方式作用于button时所调用的函数。参数button有 AUX_LEFTBUTTON、AUX_MIDDLEBUTTON或AUX_RIGHTBUTTON（以右手为标准）。参数mode代表鼠标触击状态，击中时为AUX_MOUSEDOWN，释放时为AUX_MOUSEUP。参数function必须带一个参数，它是指向结构AUX_EVENNTREC的指针。当函数auxMouseFunc()被调用时将为这个结构分配相应的内存。通常用法类似如下： void function(AUX_EVENTREC *event){GLint x,y;x=event-&gt;data[AUX_MOUSEX];y=event-&gt;data[AUX_MOUSEY];…} 6.1.3 颜色表装入因为OpenGL本身没有窗口系统，所以依赖于窗口系统的颜色映射就没法装入颜色查找表。如果采用颜色表模式，就要用到辅助库提供的用RGB值定义的单个颜色索引函数： void auxSetOneColor(GLint index,GLfloat red,GLfloat green,GLfloat blue) 设置自定义颜色的索引。参数index即索引号，参数red、green、blue分别为红、绿、蓝值，范围在（0～1）内。 6.1.4 三维物体绘制每组三维物体包括两种形式：网状体（wire）和实心体（solid）。网状体没有平面法向，而实心体有，能进行光影计算，有光照时采用实心体模型。下面这些函数的 参数都是定义物体大小的，可以改变。 功能 函数 绘制球 void auxWireSphere(GLdouble radius)void auxSolidSphere(GLdouble radius) 绘制立方体 void auxWireCube(GLdouble size)void auxSolidCube(GLdouble size) 绘制长方体 void auxWireBox(GLdouble width,GLdouble height,GLdouble depth)void auxSolidBox(GLdouble width,GLdouble height,GLdouble depth) 绘制环形圆纹面 void auxWireTorus(GLdouble innerRadius,GLdouble outerRadius)void auxSolidTorus(GLdouble innerRadius,GLdouble outerRadius) 绘制圆柱 void auxWireCylinder(GLdouble radius,GLdouble height)void auxSolidCylinder(GLdouble radius,GLdouble height) 绘制二十面体 void auxWireIcosahedron(GLdouble radius)void auxSolidIcosahedron(GLdouble radius) 绘制八面体 void auxWireOctahedron(GLdouble radius)void auxSolidOctahedron(GLdouble radius) 绘制四面体 void auxWireTetrahedron(GLdouble radius)void auxSolidTetrahedron(GLdouble radius) 绘制十二面体 void auxWireDodecahedron(GLdouble radius)void auxSolidDodecahedron(GLdouble radius) 绘制圆锥 void auxWireCone(GLdouble radius,GLdouble height)void auxSolidCone(GLdouble radius,GLdouble height) 绘制茶壶 void auxWireTeapot(GLdouble size)void aucSolidTeapot(GLdouble size) 表6-1以上物体均以各自中心为原点绘制，所有坐标都已单位化，可以缩放。 6.1.5 背景过程管理 void auxIdleFunc(void *func) 定义空闲状态执行函数。参数func是一个指针，指向所要执行的函数功能。当它为零时，func执行无效。 6.1.6 程序运行 void auxMainLoop(void(*displayFunc)(void)) 定义场景绘制循环函数。displayFunc指针指向场景绘制函数。当窗口需要更新或场景发生改变时，程序便调用它所指的函数，重新绘制场景。6.2、辅助库应用示例下面举一个辅助库的应用例子，testaux.c： 例6-1 辅助库应用例程 testaux.c #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w,GLsizei h);void CALLBACK display(void); void myinit(void){glClearColor(0.0,0.0,0.0,0.0);glClear(GL_COLOR_BUFFER_BIT);} void CALLBACK myReshape(GLsizei w,GLsizei h){glViewport(0,0,w,h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if(w&lt;=h)glOrtho(-1.5,1.5,-1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w,-10.0,10.0);elseglOrtho(-1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w,-1.5,1.5,-10.0,10.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void CALLBACK display(void){glColor3f(1.0,1.0,0.0);auxWireSphere(1.0);glFlush();} void main(void){auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);auxInitPosition(0,0,500,500);auxInitWindow(“AUX_SAMPLE”);myinit();auxReshapeFunc(myReshape);auxMainLoop(display);} 图6-1 网状球体以上程序运行结果是在屏幕窗口内绘制一个黄色的网状球体，这个程序充分体现了辅助库的基本应用方法。首先，在主函数中用辅助库函数定义一个窗口auxInitWindow()，然后初始化颜色myinit()，这些在第一章中已说明。接下来是两个十分重要的函数 auxReshapeFunc()和auxMainLoop()，参数都是一个函数指针，指向的都是回调函数（回调函数定义用CALLBACK说明）。前者是窗口形状重定函数，参数指针指向函数myReshape()，它的两个参数就是窗口的新宽度和新高度。然后用glViewport(0, 0, w, h)重定视口，并且在新视口内重新定义投影矩阵， glMatrixMode(GL_PROJECTION);glLoadIdentity();if(w&lt;=h)glOrtho(-1.5,1.5,-1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w,-10.0,10.0);elseglOrtho(-1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w,-1.5,1.5,-10.0,10.0); 即先用glMatrixMode()说明当前矩阵操作与投影有关GL_PROJECTION，再用glLoadIdentity()将矩阵清为单位矩阵，避免受其它矩阵操作的干扰；然后调用glOrtho()对物体进行正射投影，并且用判断语句给出了两种情况，使投影后图像的比例与视点匹配，避免比例失调。再下来调用glMatrixMode()将矩阵操作改为对观察物体有关的方式GL_MODELVIEW，同样用 glLoadIdentity()清矩阵。后者是主函数循环函数，参数指针指向函数display()，即绘制物体。当窗口需要更新或物体发生改变时，程序便调用它重新绘制。以上例子是辅助库的最基本应用，复杂的应用将在后续的章节中详细介绍。 七、OpenGL建模 OpenGL基本库提供了大量绘制各种类型图元的方法，辅助库也提供了不少描述复杂三维图形的函数。这一章主要介绍基本图元，如点、线、多边形，有了这些图元，就可以建立比较复杂的模型了。7.1、描述图元OpenGL是三维图形的函数库，它所定义的点、线、多边形等图元与一般的定义不太一样，存在一定的差别。对编程者来说，能否理解二者之间的差别十分重要。一种差别源于基于计算机计算的限制。OpenGL中所有浮点计算精度有限，故点、线、多边形的坐标值存在一定的误差。另一种差别源于位图显示的限制。以这种方式显示图形，最小的显示图元是一个象素，尽管每个象素宽度很小，但它们仍然比数学上所定义的点或线宽要大得多。当用OpenGL 进行计算时，虽然是用一系列浮点值定义点串，但每个点仍然是用单个象素显示，只是近似拟合。OpenGL图元是抽象的几何概念，不是真实世界中的物体，因此须用相关的数学模型来描述。 7.1.1 齐次坐标（Homogeneous Coordinate）在空间直角坐标系中，任意一点可用一个三维坐标矩阵[x y z]表示。如果将该点用一个四维坐标的矩阵[Hx Hy Hz H]表示时，则称为齐次坐标表示方法。在齐次坐标中，最后一维坐标H称为比例因子。在OpenGL中，二维坐标点全看作三维坐标点，所有的点都用齐次坐标来描述，统一作为三维齐次点来处理。每个齐次点用一个向量(x, y, z, w)表示，其中四个元素全不为零。齐次点具有下列几个性质：1）如果实数a非零，则(x, y, x, w)和(ax, ay, az, aw)表示同一个点，类似于x/y = (ax)/( ay)。2）三维空间点(x, y, z)的齐次点坐标为(x, y, z, 1.0)，二维平面点(x,y)的齐次坐标为(x, y, 0.0, 1.0)。3）当w不为零时，齐次点坐标(x, y, z, w)即三维空间点坐标(x/w, y/w, z/w)；当w为零时，齐次点(x, y, z, 0.0)表示此点位于某方向的无穷远处。注意：OpenGL中指定w大于或等于0.0。 7.1.2 点(Point)用浮点值表示的点称为顶点（Vertex）。所有顶点在OpenGL内部计算时都作为三维点处理，用二维坐标(x, y)定义的点在OpenGL中默认z值为0。所有顶点坐标用齐次坐标(x, y, z, w) 表示，如果w不为0.0，这些齐次坐标表示的顶点即为三维空间点(x/w, y/w, z/w)。编程者可以自己指定w值，但很少这样做。一般来说，w缺省为1.0。 7.1.3 线(Line)在OpenGL中，线代表线段（Line Segment），不是数学意义上的那种沿轴两个方向无限延伸的线。这里的线由一系列顶点顺次连结而成，有闭合和不闭合两种。见图7-1所示。 图7-1 线段的两种连结方式7.1.4 多边形(Polygon)OpenGL中定义的多边形是由一系列线段依次连结而成的封闭区域。这些线段不能交叉，区域内不能有空洞，多边形必须在凸多边形，否则不能被OpenGL函数接受。合法和非法多边形图示见图7-2。 图7-2 合法和非法多边形OpenGL多边形可以是平面多边形，即所有顶点在一个平面上，也可以是空间多边形。更复杂的多边形将在提高篇中介绍。7.2、绘制图元 7.2.1 定义顶点在OpenGL中，所有几何物体最终都由有一定顺序的顶点集来描述。函数glVertex{234}{sifd}v可以用二维、三维或齐次坐标定义顶点。举例如下： glVertex2s(2,3);glVertex3d(0.0,1.0,3.1414926535);glVertex4f(2.4,1.0,-2.2,2.0);GLfloat pp[3]={5.0,2.0,10.2};glVertex3fv(pp); 第一例子表示一个空间顶点(2, 3, 0)，第二个例子表示用双精度浮点数定义一个顶点，第三个例子表示用齐次坐标定义一个顶点，其真实坐标为(1.2, 0.5, -1.1)，最后一个例子表示用一个指针（或数组）定义顶点。 7.2.2 构造几何图元在实际应用中，通常用一组相关的顶点序列以一定的方式组织起来定义某个几何图元，而不采用单独定义多个顶点来构造几何图元。在OpenGL中，所有被定义的顶点必须放在glBegain()和glEnd()两个函数之间才能正确表达一个几何图元或物体，否则，glVertex*()不完成任何操作。如： glBegin(GL_POLYGON);glVertex2f(0.0,0.0);glVertex2f(0.0,3.0);glVertex2f(3.0,3.0);glVertex2f(4.0,1.5);glVertex2f(3.0,0.0);glEnd(); 以上这段程序定义了一个多边形，如果将glBegin()中的参数GL_POLYGON改为GL_POINTS，则图形变为一组顶点（5个），见图7-3所示。 图7-3 绘制多边形或一组顶点点函数glBegin(GLenum mode)标志描述一个几何图元的顶点列表的开始，其参数mode表示几何图元的描述类型。所有类型及说明见表7-1所示，相应的图示见图7-4。 类型 说明 GL_POINTS 单个顶点集 GL_LINES 多组双顶点线段 GL_POLYGON 单个简单填充凸多边形 GL_TRAINGLES 多组独立填充三角形 GL_QUADS 多组独立填充四边形 GL_LINE_STRIP 不闭合折线 GL_LINE_LOOP 闭合折线 GL_TRAINGLE_STRIP 线型连续填充三角形串 GL_TRAINGLE_FAN 扇形连续填充三角形串 GL_QUAD_STRIP 连续填充四边形串 表7-1 几何图元类型和说明&nbsp; 图7-4 几何图元类型函数glEnd()标志顶点列表的结束。从图7-4中可看出，可以采用许多方法构造几何图元，这些方法仅仅依赖于所给的顶点数据。在glBegin()和glEnd()之间最重要的信息就是由函数glVertex*()定义的顶点，必要时也可为每个顶点指定颜色、法向、纹理坐标或其他，即调用相关的函数，见表7-2所示，具体用法以后会逐步介绍。 函数 函数意义 glVertex*() 设置顶点坐标 glColor*() 设置当前颜色 glIndex*() 设置当前颜色表 glNormal*() 设置法向坐标 glEvalCoord*() 产生坐标 glCallList(),glCallLists() 执行显示列表 glTexCoord*() 设置纹理坐标 glEdgeFlag*() 控制边界绘制 glMaterial*() 设置材质 表7-2 在glBegin()和glEnd()之间可调用的函数看如下几句： glBegin(GL_POINTS);glColor3f(1.0,0.0,0.0); / red color /glVertex(…);glColor3f(0.0,1.0,0.0); / green color /glColor3f(0.0,0.0,1.0); / blue color /glVertex(…);glVertex(…);glEnd(); 颜色等的设置只对当前点或后续点有效。上一例中第一个点是红色，第二个点和第三个点都是蓝色。其中设置绿色时，之后没有顶点操作，而是设置蓝色，故只有当前蓝色对紧跟其后的两个顶点有效。为了更好地理解构造几何图元函数的用法，下面举一个简单的例子： 例7-3 几何图元构造例程（drawgeom.c） #include “glos.h” #include&lt;GL/gl.h&gt; #include&lt;GL/glaux.h&gt; void myinit(void);void DrawMyObjects(void);void CALLBACK myReshape(GLsizei w,GLsizei h);void CALLBACK display(void); void myinit(void){glClearColor(0.0,0.0,0.0,0.0);glClear(GL_COLOR_BUFFER_BIT);glShadeModel(GL_FLAT);} void CALLBACK myReshape(GLsizei w,GLsizei h){glViewport(0,0,w,h);glMatrixMode(GL_PROJECTION);glLoadIdentity(); if(w&lt;=h)glOrtho(-20.0,20.0,-20.0(GLfloat)h/(GLfloat)w, 20.0(GLfloat)h/(GLfloat)w,-50.0,50.0);elseglOrtho(-20.0(GLfloat)h/(GLfloat)w, 20.0(GLfloat)h/(GLfloat)w,-20.0,20.0,-50.0,50.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void CALLBACK display(void){glColor3f(1.0,1.0,0.0);DrawMyObjects();glFlush();} void DrawMyObjects(void){/ draw some points /glBegin(GL_POINTS);glColor3f(1.0,0.0,0.0);glVertex2f(-10.0,11.0);glColor3f(1.0,1.0,0.0);glVertex2f(-9.0,10.0);glColor3f(0.0,1.0,1.0);glVertex2f(-8.0,12.0);glEnd(); / draw some line_segments /glBegin(GL_LINES);glColor3f(1.0,1.0,0.0);glVertex2f(-11.0,8.0);glVertex2f(-7.0,7.0);glColor3f(1.0,0.0,1.0);glVertex2f(-11.0,9.0);glVertex2f(-8.0,6.0);glEnd(); / draw one opened_line /glBegin(GL_LINE_STRIP);glColor3f(0.0,1.0,0.0);glVertex2f(-3.0,9.0);glVertex2f(2.0,6.0);glVertex2f(3.0,8.0);glVertex2f(-2.5,6.5);glEnd(); / draw one closed_line /glBegin(GL_LINE_LOOP);glColor3f(0.0,1.0,1.0);glVertex2f(7.0,7.0);glVertex2f(8.0,8.0);glVertex2f(9.0,6.5);glVertex2f(10.3,7.5);glVertex2f(11.5,6.0);glVertex2f(7.5,6.0);glEnd(); / draw one filled_polygon /glBegin(GL_POLYGON);glColor3f(0.5,0.3,0.7);glVertex2f(-7.0,2.0);glVertex2f(-8.0,3.0);glVertex2f(-10.3,0.5);glVertex2f(-7.5,-2.0);glVertex2f(-6.0,-1.0);glEnd(); / draw some filled_quandrangles /glBegin(GL_QUADS);glColor3f(0.7,0.5,0.2);glVertex2f(0.0,2.0);glVertex2f(-1.0,3.0);glVertex2f(-3.3,0.5);glVertex2f(-0.5,-1.0);glColor3f(0.5,0.7,0.2);glVertex2f(3.0,2.0);glVertex2f(2.0,3.0);glVertex2f(0.0,0.5);glVertex2f(2.5,-1.0);glEnd(); / draw some filled_strip_quandrangles /glBegin(GL_QUAD_STRIP);glVertex2f(6.0,-2.0);glVertex2f(5.5,1.0);glVertex2f(8.0,-1.0);glColor3f(0.8,0.0,0.0);glVertex2f(9.0,2.0);glVertex2f(11.0,-2.0);glColor3f(0.0,0.0,0.8);glVertex2f(11.0,2.0);glVertex2f(13.0,-1.0);glColor3f(0.0,0.8,0.0);glVertex2f(14.0,1.0);glEnd(); / draw some filled_triangles /glBegin(GL_TRIANGLES);glColor3f(0.2,0.5,0.7);glVertex2f(-10.0,-5.0);glVertex2f(-12.3,-7.5);glVertex2f(-8.5,-6.0);glColor3f(0.2,0.7,0.5);glVertex2f(-8.0,-7.0);glVertex2f(-7.0,-4.5);glVertex2f(-5.5,-9.0);glEnd(); / draw some filled_strip_triangles /glBegin(GL_TRIANGLE_STRIP);glVertex2f(-1.0,-8.0);glVertex2f(-2.5,-5.0);glColor3f(0.8,0.8,0.0);glVertex2f(1.0,-7.0);glColor3f(0.0,0.8,0.8);glVertex2f(2.0,-4.0);glColor3f(0.8,0.0,0.8);glVertex2f(4.0,-6.0);glEnd(); / draw some filled_fan_triangles /glBegin(GL_TRIANGLE_FAN);glVertex2f(8.0,-6.0);glVertex2f(10.0,-3.0);glColor3f(0.8,0.2,0.5);glVertex2f(12.5,-4.5);glColor3f(0.2,0.5,0.8);glVertex2f(13.0,-7.5);glColor3f(0.8,0.5,0.2);glVertex2f(10.5,-9.0);glEnd();} void main(void){auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);auxInitPosition(0,0,500,500);auxInitWindow(“Geometric Primitive Types”);myinit();auxReshapeFunc(myReshape);auxMainLoop(display);} 以上程序运行结果就是图7-4所示的内容，这个例子很好地说明了几何图元的类型及颜色等函数的用法。希望读者自己仔细分析每个物体的绘制方法，体会其中的关键之处，达到举一反三的效果。当然，还可利用上一章辅助库中提供的基本三维图元构造比较复杂的物体，你不妨也试一试。 八、OpenGL变换 OpenGL变换是本篇的重点内容，它包括计算机图形学中最基本的三维变换，即几何变换、投影变换、裁剪变换、视口变换，以及针对OpenGL的特殊变换概念理解和用法，如相机模拟、矩阵堆栈等。学好了这章，才开始真正走进三维世界。8.1、从三维空间到二维平面 8.1.1 相机模拟在真实世界里，所有的物体都是三维的。但是，这些三维物体在计算机世界中却必须以二维平面物体的形式表现出来。那么，这些物体是怎样从三维变换到二维的呢？下面我们采用相机（Camera）模拟的方式来讲述这个概念，如图8-1所示。 图8-1 相机模拟实际上，从三维空间到二维平面，就如同用相机拍照一样，通常都要经历以下几个步骤 （括号内表示的是相应的图形学概念）：第一步，将相机置于三角架上，让它对准三维景物（视点变换，Viewing Transformation）。第二步，将三维物体放在适当的位置（模型变换，Modeling Transformation）。第三步，选择相机镜头并调焦，使三维物体投影在二维胶片上（投影变换，Projection Transformation）。第四步，决定二维像片的大小（视口变换，Viewport Transformation）。这样，一个三维空间里的物体就可以用相应的二维平面物体表示了，也就能在二维的电脑屏幕上正确显示了。 8.1.2 三维图形显示流程运用相机模拟的方式比较通俗地讲解了三维图形显示的基本过程，但在具体应用OpenGL函数库编程时，还必须了解三维图形世界中的几个特殊坐标系的概念，以及用这些概念表达的三维图形显示流程。计算机本身只能处理数字，图形在计算机内也是以数字的形式进行加工和处理的。大家都知道，坐标建立了图形和数字之间的联系。为了使被显示的物体数字化，要在被显示的物体所在的空间中定义一个坐标系。这个坐标系的长度单位和坐标轴的方向要适合对被显示物体的描述，这个坐标系称为世界坐标系。计算机对数字化的显示物体作了加工处理后，要在图形显示器上显示，这就要在图形显示器屏幕上定义一个二维直角坐标系，这个坐标系称为屏幕坐标系。这个坐标系坐标轴的方向通常取成平行于屏幕的边缘，坐标原点取在左下角，长度单位常取成一个象素的长度，大小可以是整型数。为了使显示的物体能以合适的位置、大小和方向显示出来，必须要通过投影。投影的方法有两种，即正射投影和透视投影。有时为了突出图形的一部分，只把图形的某一部分显示出来，这时可以定义一个三维视景体（Viewing Volume）。正射投影时一般是一个长方体的视景体，透视投影时一般是一个棱台似的视景体。只有视景体内的物体能被投影在显示平面上，其他部分则不能。在屏幕窗口内可以定义一个矩形，称为视口（Viewport），视景体投影后的图形就在视口内显示。为了适应物理设备坐标和视口所在坐标的差别，还要作一适应物理坐标的变换。这个坐标系称为物理设备坐标系。根据上面所述，三维图形的显示流程应如图8-2所示。 图8-2 三维图形的显示流程8.1.3 基本变换简单分析下面举一个简单的变换例子，cube.c： 例8-4 简单变换例程（cube.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h);void CALLBACK display(void); void CALLBACK display (void){glClear(GL_COLOR_BUFFER_BIT);glColor3f (1.0, 1.0, 1.0);glLoadIdentity (); / clear the matrix /glTranslatef (0.0, 0.0, -5.0); / viewing transformation /glScalef (1.0, 2.0, 1.0); / modeling transformation /auxWireCube(1.0); / draw the cube /glFlush();} void myinit (void){glShadeModel (GL_FLAT);} void CALLBACK myReshape(GLsizei w, GLsizei h){glMatrixMode (GL_PROJECTION); / prepare for and then /glLoadIdentity (); / define the projection /glFrustum (-1.0, 1.0, -1.0, 1.0, 1.5, 20.0); / transformation /glMatrixMode (GL_MODELVIEW); / back to modelview matrix /glViewport (0, 0, w, h); / define the viewport /} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Perspective 3-D Cube”);myinit ();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果就是绘制一个三维的正面透视立方体。其中已经用到了相机模拟中提到的四种基本变换，即视点变换、模型变换、投影变换和视口变换。 图8-3 三维的正面透视立方体下面简单分析一下整个程序过程：1）视点变换。视点变换是在视点坐标系中进行的。视点坐标系于一般的物体所在的世界坐标系不同，它遵循左手法则，即左手大拇指指向Z正轴，与之垂直的四个手指指向X正轴，四指弯曲90度的方向是Y正轴。而世界坐标系遵循右手法则的。如图8-4所示。当矩阵初始化glLoadIdentity()后，调用glTranslatef()作视点变换。函数参数(x, y, z)表示视点或相机在视点坐标系中移动的位置，这里z=-5.0，意思是将相机沿Z负轴移动5个单位。通常相机位置缺省值同场景中的物体一样，都在原点处，而且相机初始方向都指向Z负轴。这里相机移走后，仍然对准立方体。如果相机需要指向另一方向，则调用glRotatef()可以改变。 图8-4 视点坐标系与世界坐标系2）模型变换。模型变换是在世界坐标系中进行的。在这个坐标系中，可以对物体实施平移 glTranslatef()、旋转glRotatef()和放大缩小glScalef()。例子里只对物体进行比例变换，glScalef(sx, sy, sz)的三个参数分别是X、Y、Z轴向的比例变换因子。缺省时都为1.0，即物体没变化。程序中物体Y轴比例为2.0，其余都为1.0，就是说将立方体变成长方体。3）投影变换。投影变换类似于选择相机的镜头。本例中调用了一个透视投影函数 glFrustum()，在调用它之前先要用glMatrixMode()说明当前矩阵方式是投影GL_PROJECTION。这个投影函数一共有六个参数，由它们可以定义一个棱台似的视景体。即视景体内的部分可见，视景体外的部分不可见，这也就包含了三维裁剪变换。4）视口变换。视口变换就是将视景体内投影的物体显示在二维的视口平面上。通常，都调用函数glViewport()来定义一个视口，这个过程类似于将照片放大或缩小。总而言之，一旦所有必要的变换矩阵被指定后，场景中物体的每一个顶点都要按照被指定的变换矩阵序列逐一进行变换。注意：OpenGL 中的物体坐标一律采用齐次坐标，即(x, y, z, w)，故所有变换矩阵都采用4X4矩阵。一般说来，每个顶点先要经过视点变换和模型变换，然后进行指定的投影，如果它位于视景体外，则被裁剪掉。最后，余下的已经变换过的顶点x、y、z坐标值都用比例因子w除，即x/w、y/w、z/w，再映射到视口区域内，这样才能显示在屏幕上。8.2、几何变换实际上，上述所说的视点变换和模型变换本质上都是一回事，即图形学中的几何变换。只是视点变换一般只有平移和旋转，没有比例变换。当视点进行平移或旋转时，视点坐标系中的物体就相当于在世界坐标系中作反方向的平移或旋转。因此，从某种意义上讲，二者可以统一，只是各自出发点不一样而已。读者可以根据具体情况，选择其中一个角度去考虑，这样便于理解。 8.2.1 两个矩阵函数解释这里先解释两个基本OpenGL矩阵操作函数，便于以后章节的讲述。函数解释如下： void glLoadMatrix{fd}(const TYPE *m) 设置当前矩阵中的元素值。函数参数*m是一个指向16个元素(m0, m1, …, m15)的指针，这16个元素就是当前矩阵M中的元素，其排列方式如下： M = | m0 m4 m8 m12 || m1 m5 m9 m13 || m2 m6 m10 m14 || m3 m7 m11 M15 |void glMultMatrix{fd}(const TYPE *m) 用当前矩阵去乘m所指定的矩阵，并将结果存放于m中。当前矩阵可以是用glLoadMatrix() 指定的矩阵，也可以是其它矩阵变换函数的综合结果。当几何变换时，调用OpenGL的三个变换函数glTranslate()、glRotate()和glScale*()，实质上相当于产生了一个近似的平移、旋转和比例矩阵，然后调用glMultMatrix()与当前矩阵相乘。但是直接调用这三个函数程序运行得快一些，因OpenGL自动能计算矩阵。 8.2.2 平移平移变换函数如下： void glTranslate{fd}(TYPE x,TYPE y,TYPE z) 三个函数参数就是目标分别沿三个轴向平移的偏移量。这个函数表示用这三个偏移量生成的矩阵乘以当前矩阵。当参数是(0.0,0.0,0.0)时，表示对函数glTranslate*()的操作是单位矩阵，也就是对物体没有影响。平移示意如图8-5所示。 图8-5 平移示意图8.2.3 旋转旋转变换函数如下： void glRotate{fd}(TYPE angle,TYPE x,TYPE y,TYPE z) 函数中第一个参数是表示目标沿从点(x, y, z)到原点的方向逆时针旋转的角度，后三个参数是旋转的方向点坐标。这个函数表示用这四个参数生成的矩阵乘以当前矩阵。当角度参数是0.0时，表示对物体没有影响。旋转示意如图8-6所示。 图8-6 旋转示意图8.2.3 缩放和反射缩放和反射变换函数如下： void glScale{fd}(TYPE x,TYPE y,TYPE z) 三个函数参数值就是目标分别沿三个轴向缩放的比例因子。这个函数表示用这三个比例因子生成的矩阵乘以当前矩阵。这个函数能完成沿相应的轴对目标进行拉伸、压缩和反射三项功能。当参数是(1.0, 1.0, 1.0)时，表示对函数glScale*()操作是单位矩阵，也就是对物体没有影响。当其中某个参数为负值时，表示将对目标进行相应轴的反射变换，且这个参数不为1.0，则还要进行相应轴的缩放变换。最好不要令三个参数值都为零，这将导致目标沿三轴都缩为零。缩放和反射示意如图8-7所示。 图8-7 缩放和反射示意图8.2.5 几何变换举例以上介绍了三个基本几何变换函数，下面举一个简单的例子进一步说明它们的用法。程序如下： 例 8-5 几何变换例程（geomtrsf.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void draw_triangle(void);void CALLBACK display(void);void CALLBACK myReshape(GLsizei w, GLsizei h); void draw_triangle(void){glBegin(GL_LINE_LOOP);glVertex2f(0.0, 25.0);glVertex2f(25.0, -25.0);glVertex2f(-25.0, -25.0);glEnd();} void CALLBACK display(void){glClearColor (0.0, 0.0, 0.0, 1.0);glClear (GL_COLOR_BUFFER_BIT); / draw an original triangle /glLoadIdentity ();glColor3f (1.0, 1.0, 1.0); / white /draw_triangle (); / translating a triangle along X_axis /glLoadIdentity ();glTranslatef (-20.0, 0.0, 0.0);glColor3f(1.0,0.0,0.0); / red /draw_triangle (); / scaling a triangle along X_axis by 1.5 and along Y_axis by 0.5 /glLoadIdentity();glScalef (1.5, 0.5, 1.0);glColor3f(0.0,1.0,0.0); / green /draw_triangle (); / rotating a triangle in a counterclockwise direction about Z_axis /glLoadIdentity ();glRotatef (90.0, 0.0, 0.0, 1.0);glColor3f(0.0,0.0,1.0); / blue /draw_triangle (); / scaling a triangle along Y_axis and reflecting it about Y_axis /glLoadIdentity();glScalef (1.0, -0.5, 1.0);glColor3f(1.0,1.0,0.0); / yellow /draw_triangle (); glFlush();} void myinit (void){glShadeModel (GL_FLAT);} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)glOrtho(-50.0, 50.0, -50.0(GLfloat)h/(GLfloat)w, 50.0(GLfloat)h/(GLfloat)w,-1.0,1.0);elseglOrtho(-50.0(GLfloat)w/(GLfloat)h, 50.0(GLfloat)w/(GLfloat)h, -50.0, 50.0,-1.0,1.0);glMatrixMode(GL_MODELVIEW);} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Geometric Transformations”);myinit ();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果：第一个白色三角形是原始三角形，第二个红色三角形是白三角沿X 负轴平移后的三角形，第三个绿色三角形是白三角分别沿X轴和Y轴比例变换后的三角形，第四个蓝色三角形是白三角绕Z正轴逆时针转90度后的三角形，第五个黄色三角形是白三角沿Y轴方向缩小一倍且相对于X轴作反射后形成的三角形。 图8-8 三角形的几何变换8.3、投影变换投影变换是一种很关键的图形变换，OpenGL中只提供了两种投影方式，一种是正射投影，另一种是透视投影。不管是调用哪种投影函数，为了避免不必要的变换，其前面必须加上以下两句： glMAtrixMode(GL_PROJECTION);glLoadIdentity(); 事实上，投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。本指南将详细讲述投影变换的概念以及用法。 8.3.1 正射投影（Orthographic Projection）正射投影，又叫平行投影。这种投影的视景体是一个矩形的平行管道，也就是一个长方体，如图8-9所示。正射投影的最大一个特点是无论物体距离相机多远，投影后的物体大小尺寸不变。这种投影通常用在建筑蓝图绘制和计算机辅助设计等方面，这些行业要求投影后的物体尺寸及相互间的角度不变，以便施工或制造时物体比例大小正确。 图8-9 正射投影视景体OpenGL正射投影函数共有两个，这在前面几个例子中已用过。一个函数是： void glOrtho(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far) 它创建一个平行视景体。实际上这个函数的操作是创建一个正射投影矩阵，并且用这个矩阵乘以当前矩阵。其中近裁剪平面是一个矩形，矩形左下角点三维空间坐标是（left，bottom，-near），右上角点是（right，top，-near）；远裁剪平面也是一个矩形，左下角点空间坐标是（left，bottom，-far），右上角点是（right，top，-far）。所有的near和far值同时为正或同时为负。如果没有其他变换，正射投影的方向平行于Z轴，且视点朝向Z负轴。这意味着物体在视点前面时far和near都为负值，物体在视点后面时far和near都为正值。另一个函数是： void gluOrtho2D(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top) 它是一个特殊的正射投影函数，主要用于二维图像到二维屏幕上的投影。它的near和far缺省值分别为-1.0和1.0，所有二维物体的Z坐标都为0.0。因此它的裁剪面是一个左下角点为（left，bottom）、右上角点为（right，top）的矩形。 8.3.2 透视投影（Perspective Projection）透视投影符合人们心理习惯，即离视点近的物体大，离视点远的物体小，远到极点即为消失，成为灭点。它的视景体类似于一个顶部和底部都被切除掉的棱椎，也就是棱台。这个投影通常用于动画、视觉仿真以及其它许多具有真实性反映的方面。OpenGL透视投影函数也有两个，其中函数glFrustum()在8.1.3节中提到过，它所形成的视景体如图8-10所示。 图8-10 函数glFrustum()透视投影视景体这个函数原型为： void glFrustum(GLdouble left,GLdouble Right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far); 它创建一个透视视景体。其操作是创建一个透视投影矩阵，并且用这个矩阵乘以当前矩阵。这个函数的参数只定义近裁剪平面的左下角点和右上角点的三维空间坐标，即（left，bottom，-near）和（right，top，-near）；最后一个参数far是远裁剪平面的Z负值，其左下角点和右上角点空间坐标由函数根据透视投影原理自动生成。near和far表示离视点的远近，它们总为正值。另一个函数是： void gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear, GLdouble zFar); 它也创建一个对称透视视景体，但它的参数定义于前面的不同，如图8-11所示。其操作是创建一个对称的透视投影矩阵，并且用这个矩阵乘以当前矩阵。参数 fovy定义视野在X-Z平面的角度，范围是[0.0, 180.0]；参数aspect是投影平面宽度与高度的比率；参数zNear和Far分别是远近裁剪面沿Z负轴到视点的距离，它们总为正值。 图8-11 函数gluPerspective()透视投影视景体以上两个函数缺省时，视点都在原点，视线沿Z轴指向负方向。二者的应用实例将在后续章节中介绍。8.4、裁剪变换在OpenGL中，空间物体的三维裁剪变换包括两个部分：视景体裁剪和附加平面裁剪。视景体裁剪已经包含在投影变换里，前面已述，这里不再重复。下面简单讲一下平面裁剪函数的用法。除了视景体定义的六个裁剪平面（上、下、左、右、前、后）外，用户还可自己再定义一个或多个附加裁剪平面，以去掉场景中无关的目标，如图8-12所示。 图8-12 附加裁剪平面和视景体附加平面裁剪函数为： void glClipPlane(GLenum plane,Const GLdouble *equation); 函数定义一个附加的裁剪平面。其中参数equation指向一个拥有四个系数值的数组，这四个系数分别是裁剪平面Ax+By+Cz+D=0的A、B、 C、D值。因此，由这四个系数就能确定一个裁剪平面。参数plane是GL_CLIP_PLANEi(i=0,1,…)，指定裁剪面号。在调用附加裁剪函数之前，必须先启动glEnable(GL_CLIP_PLANEi)，使得当前所定义的裁剪平面有效；当不再调用某个附加裁剪平面时，可用glDisable(GL_CLIP_PLANEi)关闭相应的附加裁剪功能。下面这个例子不仅说明了附加裁剪函数的用法，而且调用了gluPerspective()透视投影函数，读者可以细细体会其中的用法。例程如下： 例8-6 裁剪变换例程（clipball.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h);void CALLBACK display(void); void CALLBACK display(void){GLdouble eqn[4] = {1.0, 0.0, 0.0, 0.0}; glClear(GL_COLOR_BUFFER_BIT); glColor3f (1.0, 0.0, 1.0);glPushMatrix();glTranslatef (0.0, 0.0, -5.0); / clip the left part of wire_sphere : x&lt;0 /glClipPlane (GL_CLIP_PLANE0, eqn);glEnable (GL_CLIP_PLANE0);glRotatef (-90.0, 1.0, 0.0, 0.0);auxWireSphere(1.0);glPopMatrix();glFlush();} void myinit (void){glShadeModel (GL_FLAT);} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);glMatrixMode(GL_MODELVIEW);} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGB);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Arbitrary Clipping Planes”);myinit ();auxReshapeFunc (myReshape);auxMainLoop(display);} 图8-13 剪取后的网状半球体8.5、视口变换在前面几节内容中已相继提到过视口变换，这一节将针对OpenGL来讲述视口变换的原理及其相关函数的用法。运用相机模拟方式，我们很容易理解视口变换就是类似于照片的放大与缩小。在计算机图形学中，它的定义是将经过几何变换、投影变换和裁剪变换后的物体显示于屏幕窗口内指定的区域内，这个区域通常为矩形，称为视口。OpenGL中相关函数是： glViewport(GLint x,GLint y,GLsizei width, GLsizei height); 这个函数定义一个视口。函数参数(x, y)是视口在屏幕窗口坐标系中的左下角点坐标，参数width和height分别是视口的宽度和高度。缺省时，参数值即(0, 0, winWidth, winHeight) 指的是屏幕窗口的实际尺寸大小。所有这些值都是以象素为单位，全为整型数。注意：在实际应用中，视口的长宽比率总是等于视景体裁剪面的长宽比率。如果两个比率不相等，那么投影后的图像显示于视口内时会发生变形，如图8-14所示。另外，屏幕窗口的改变一般不明显影响视口的大小。因此，在调用这个函数时，最好实时检测窗口尺寸，及时修正视口的大小，保证视口内的图像能随窗口的变化而变化，且不变形。 图8-14 视景体到视口的映射8.6 矩阵堆栈学过计算机的人也许都知道这个使用频率极高的名词 — “堆栈”。顾名思义，堆栈指的是一个顶部打开底部封闭的柱状物体，通常用来存放常用的东西。这些东西从顶部依次放入，但取出时也只能从顶部取出，即“先进后出，后进先出”。在计算机中，它常指在内存中开辟的一块存放某些变量的连续区域。因此，OpenGL的矩阵堆栈指的就是内存中专门用来存放矩阵数据的某块特殊区域。实际上，在创建、装入、相乘模型变换和投影变换矩阵时，都已用到堆栈操作。一般说来，矩阵堆栈常用于构造具有继承性的模型，即由一些简单目标构成的复杂模型。例如，一辆自行车就是由两个轮子、一个三角架及其它一些零部件构成的。它的继承性表现在当自行车往前走时，首先是前轮旋转，然后整个车身向前平移，接着是后轮旋转，然后整个车身向前平移，如此进行下去，这样自行车就往前走了。矩阵堆栈对复杂模型运动过程中的多个变换操作之间的联系与独立十分有利。因为所有矩阵操作函数如glLoadMatrix()、glMultMatrix()、 glLoadIdentity()等只处理当前矩阵或堆栈顶部矩阵，这样堆栈中下面的其它矩阵就不受影响。堆栈操作函数有以下两个： void glPushMatrix(void);void glPopMatrix(void); 第一个函数表示将所有矩阵依次压入堆栈中，顶部矩阵是第二个矩阵的备份；压入的矩阵数不能太多，否则出错。第二个函数表示弹出堆栈顶部的矩阵，令原第二个矩阵成为顶部矩阵，接受当前操作，故原顶部矩阵被破坏；当堆栈中仅存一个矩阵时，不能进行弹出操作，否则出错。由此看出，矩阵堆栈操作与压入矩阵的顺序刚好相反，编程时要特别注意矩阵操作的顺序。为了更好地理解这两个函数，我们可以形象地认为glPushMatrix()就是“记住自己在哪”，glPopMatrix()就是“返回自己原来所在地”。请看下面一例： 例8-7 堆栈操作例程（arm.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void drawPlane(void);void CALLBACK elbowAdd (void);void CALLBACK elbowSubtract (void);void CALLBACK shoulderAdd (void);void CALLBACK shoulderSubtract (void);void CALLBACK display(void);void CALLBACK myReshape(GLsizei w, GLsizei h); static int shoulder = 0, elbow = 0; void CALLBACK elbowAdd (void){elbow = (elbow + 5) % 360;} void CALLBACK elbowSubtract (void){elbow = (elbow - 5) % 360;} void CALLBACK shoulderAdd (void){shoulder = (shoulder + 5) % 360;} void CALLBACK shoulderSubtract (void){shoulder = (shoulder - 5) % 360;} void CALLBACK display(void){glClear(GL_COLOR_BUFFER_BIT);glColor3f(0.0, 1.0, 1.0); glPushMatrix();glTranslatef (-0.5, 0.0, 0.0);glRotatef ((GLfloat)shoulder, 0.0, 0.0, 1.0);glTranslatef (1.0, 0.0, 0.0);auxWireBox(2.0, 0.2, 0.5); glTranslatef (1.0, 0.0, 0.0);glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);glTranslatef (0.8, 0.0, 0.0);auxWireBox(1.6, 0.2, 0.5); glPopMatrix();glFlush();} void myinit (void){glShadeModel (GL_FLAT);} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity(); glTranslatef (0.0, 0.0, -5.0); / viewing transform /} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 400, 400);auxInitWindow (“Composite Modeling Transformations”); myinit (); auxKeyFunc (AUX_LEFT, shoulderSubtract);auxKeyFunc (AUX_RIGHT, shoulderAdd);auxKeyFunc (AUX_UP, elbowAdd);auxKeyFunc (AUX_DOWN, elbowSubtract);auxReshapeFunc (myReshape);auxMainLoop(display);} 从以上例程可以看出，复杂的机械手臂是由两个简单的长方体依据一定的继承关系构成的，而这个继承关系是由矩阵堆栈的顺序决定的。 图8-15 简单机械手臂的符合运动九、OpenGL颜色 几乎所有OpenGL应用目的都是在屏幕窗口内绘制彩色图形，所以颜色在OpenGL编程中占有很重要的地位。这里的颜色与绘画中的颜色概念不一样，它属于RGB颜色空间，只在监视器屏幕上显示。另外，屏幕窗口坐标是以象素为单位，因此组成图形的每个象素都有自己的颜色，而这种颜色值是通过对一系列OpenGL函数命令的处理最终计算出来的。本章将讲述计算机颜色的概念以及OpenGL的颜色模式、颜色定义和两种模式应用场合等内容，若掌握好颜色的应用，你就能走进缤纷绚丽的色彩世界，从中享受无穷的乐趣。9.1、计算机颜色 9.1.1 颜色生成原理计算机颜色不同于绘画或印刷中的颜色，显示于计算机屏幕上每一个点的颜色都是由监视器内部的电子枪激发的三束不同颜色的光（红、绿、蓝）混合而成，因此，计算机颜色通 常用R（Red）、G（Green）、B（Blue）三个值来表示，这三个值又称为颜色分量。颜色生成原理 示意图见图9-1所示。 图9-1 计算机颜色生成原理9.1.2 RGB色立体（RGB Color Cube）所有监视器屏幕的颜色都属于RGB颜色空间，如果用一个立方体形象地表示RGB颜色组成关系，那么就称这个立方体为RGB色立体，如图9-2所示。 图9-2 RGB色立体在图中，R、G、B三值的范围都是从0.0到1.0。如果某颜色分量越大，则表示对应的颜色分量越亮，也就是它在此点所贡献的颜色成分越多；反之，则越暗或越少。当R、G、B三个值都为0.0时，此点颜色为黑色（Black）；当三者都为1.0时，此点颜色为白色（White）；当三个颜色分量值相等时，表示三者贡献一样，因此呈现灰色（Grey），在图中表现为从黑色顶点到白色顶点的那条对角线；当R=1.0、G=1.0、B=0.0时，此点颜色为黄色（Yellow）；同理，R=1.0、G=0.0、B=1.0时为洋红色，也叫品色（Magenta）；R=0.0、G=1.0、B=1.0时为青色（Cyan）。9.2、颜色模式OpenGL颜色模式一共有两个：RGB（RGBA）模式和颜色表模式。在RGB模式下，所有的颜色定义全用R、G、B三个值来表示，有时也加上 Alpha值（与透明度有关），即RGBA模式。在颜色表模式下，每一个象素的颜色是用颜色表中的某个颜色索引值表示，而这个索引值指向了相应的R、G、 B值。这样的一个表成为颜色映射（Color Map）。 9.2.1 RGBA模式（RGBA Mode）在RGBA模式下，可以用glColor*()来定义当前颜色。其函数形式为： void glColor3{b s i f d ub us ui}(TYPE r,TYPE g,TYPE b);void glColor4{b s i f d ub us ui}(TYPE r,TYPE g,TYPE b,TYPE a);void glColor3{b s i f d ub us ui}v(TYPE v);void glColor4{b s i f d ub us ui}v(TYPE v); 设置当前R、G、B和A值。这个函数有3和4两种方式，在前一种方式下，a值缺省为1.0，后一种Alpha值由用户自己设定，范围从0.0到1.0。同样，它也可用指针传递参数。另外，函数的第二个后缀的不同使用，其相应的参数值及范围不同，见下表9-1所示。虽然这些参数值不同，但实际上 OpenGL已自动将它们映射在0.0到1.0或-1.0或范围之内。因此，灵活使用这些后缀，会给你编程带来很大的方便。 后缀 数据类型 最小值 最小值映射 最大值 最大值映射 b 1字节整型数 -128 -1.0 127 1.0 s 2字节整型数 -32,768 -1.0 32,767 1.0 i 4字节整型数 -2,147,483,648 -1.0 2,147,483,647 1.0 ub 1字节无符号整型数 0 0.0 255 1.0 us 2字节无符号整型数 0 0.0 65,535 1.0 ui 4字节无符号整型数 0 0.0 4,294,967,295 1.0 表9-1 整型颜色值到浮点数的转换9.2.2 颜色表模式（Color_Index Mode）在颜色表方式下，可以调用glIndex*()函数从颜色表中选取当前颜色。其函数形式为： void glIndex{sifd}(TYPE c);void glIndex{sifd}v(TYPE *c); 设置当前颜色索引值，即调色板号。若值大于颜色位面数时则取模。 9.2.3 两种模式应用场合在大多情况下，采用RGBA模式比颜色表模式的要多，尤其许多效果处理，如阴影、光照、雾、反走样、混合等，采用RGBA模式效果会更好些；另外，纹理映射只能在RGBA模式下进行。下面提供几种运用颜色表模式的情况（仅供参考）：1）若原来应用程序采用的是颜色表模式则转到OpenGL上来时最好仍保持这种模式，便于移植。2）若所用颜色不在缺省提供的颜色许可范围之内，则采用颜色表模式。3）在其它许多特殊处理，如颜色动画，采用这种模式会出现奇异的效果。9.3、颜色应用举例颜色是一个极具吸引力的应用，在前面几章中已经逐步介绍了RGBA模式的应用方式，这里就不再多述。下面着重说一下颜色表模式的应用方法，请看例程： 例9-1 颜色表应用例程（cindex.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void InitPalette(void);void DrawColorFans(void);void CALLBACK myReshape(GLsizei w,GLsizei h);void CALLBACK display(void); void myinit(void){glClearColor(0.0,0.0,0.0,0.0);glClear(GL_COLOR_BUFFER_BIT);glShadeModel(GL_FLAT);} void InitPalette(void){GLint j;static GLfloat rgb[][3]={{1.0,0.0,0.0},{1.0,0.0,0.5},{1.0,0.0,1.0},{0.0,0.0,1.0},{0.0,1.0,1.0},{0.0,1.0,0.0},{1.0,1.0,0.0},{1.0,0.5,0.0}}; for(j=0;j&lt;8;j++)auxSetOneColor(j+1,rgb[j][0],rgb[j][1],rgb[j][2]);} void CALLBACK myReshape(GLsizei w,GLsizei h){glViewport(0,0,w,h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if(w&lt;=h)glOrtho(-12.0,12.0,-12.0(GLfloat)h/(GLfloat)w, 12.0(GLfloat)h/(GLfloat)w,-30.0,30.0);elseglOrtho(-12.0(GLfloat)h/(GLfloat)w, 12.0(GLfloat)h/(GLfloat)w,-12.0,12.0,-30.0,30.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void CALLBACK display(void){InitPalette();DrawColorFans();glFlush();} void DrawColorFans(void){GLint n;GLfloat pp[8][2]={{7.0,-7.0},{0.0,-10.0},{-7.0,-7.0},{-10.0,0.0},{-7.0,7.0}, {0.0,10.0},{7.0,7.0},{10.0,0.0}}; / draw some filled_fan_triangles /glBegin(GL_TRIANGLE_FAN);glVertex2f(0.0,0.0);glVertex2f(10.0,0.0);for(n=0;n&lt;8;n++){glIndexi(n+1);glVertex2fv(pp[n]);}glEnd();} void main(void){auxInitDisplayMode(AUX_SINGLE|AUX_INDEX);auxInitPosition(0,0,500,500);auxInitWindow(“Color Index”);myinit();auxReshapeFunc(myReshape);auxMainLoop(display);} 这个程序运行结果是在屏幕上显示八个连成扇形的不同颜色的三角形，每个三角形的颜色定义采用颜色表模式。其中，调用了辅助库函数auxSetOneColor()来装载颜色映射表，即调色板。因为将某个颜色装载到颜色查找表（color lookup table）中的过程必须依赖窗口系统，而OpenGL函数与窗口系统无关，所以这里就调用辅助库的函数来完成这个过程，然后才调用OpenGL自己的函数glIndex()设置当前的颜色号。 **图9-3 自定义调色板 **十、OpenGL光照 10.1、真实感图形基本概念真实感图形绘制是计算机图形学的一个重要组成部分，它综合利用数学、物理学、计算机科学和其它科学知识在计算机图形设备上生成象彩色照片那样的具有真实感的图形。一般说来，用计算机在图形设备上生成真实感图形必须完成以下四个步骤：一是用建模，即用一定的数学方法建立所需三维场景的几何描述，场景的几何描述直接影响图形的复杂性和图形绘制的计算耗费；二是将三维几何模型经过一定变换转为二维平面透视投影图；三是确定场景中所有可见面，运用隐藏面消隐算法将视域外或被遮挡住的不可见面消去；四是计算场景中可见面的颜色，即根据基于光学物理的光照模型计算可见面投射到观察者眼中的光亮度大小和颜色分量，并将它转换成适合图形设备的颜色值，从而确定投影画面上每一象素的颜色，最终生成图形。由于真实感图形是通过景物表面的颜色和明暗色调来表现景物的几何形状、空间位置以及表面材料的，而一个物体表面所呈现的颜色是由表面向视线方向辐射的光能决定的。在计算机图形学中，常采用一个既能表示光能大小又能表示其颜色组成的物理量即光亮度（luminance）或光强（intensity of light）来描述物体表面朝某方向辐射光能的颜色。采用这个物理量可以正确描述光在物体表面的反射、透射和吸收现象，因而可以正确计算处物体表面在空间给定方向上的光能颜色。物体表面向空间给定方向辐射的光强可应用光照模型进行计算。简单的光照模型通常假定物体表面是光滑的且由理想材料构成，因此只考虑光源照射在物体表面产生的反射光，所生成的图形可以模拟处不透明物体表面的明暗过渡，具有一定的真实感效果。复杂的光照模型除了考虑上述因素外，还要考虑周围环境的光对物体表面的影响。如光亮平滑的物体表面会将环境中其它物体映像在表面上，而通过透明物体也可看到其后的环境景象。这类光照模型称为整体光照模型，它能模拟出镜面映像、透明等较精致的光照效果。为了更真实的绘制图形，还要考虑物体表面的细节纹理，这通常使用一种称为“纹理映射”（texture mapping）的技术把已有的平面花纹图案映射到物体表面上，并在应用光照模型时将这些花纹的颜色考虑进去，物体表面细节的模拟使绘制的图形更接近自然景物。以上内容中，真实感图形绘制的四大步骤前两步在前面的章节已经详细介绍过，这里不再重复，第三步OpenGL将自动完成所有消隐过程，第四步下面几节详述。另外，部分复杂光照模型应用将在后续章节里介绍。10.2、光照模型 10.2.1 简单光照模型当光照射到一个物体表面上时，会出现三种情形。首先，光可以通过物体表面向空间反射，产生反射光。其次，对于透明体，光可以穿透该物体并从另一端射出，产生透射光。最后，部分光将被物体表面吸收而转换成热。在上述三部分光中，仅仅是透射光和反射光能够进入人眼产生视觉效果。这里介绍的简单光照模型只考虑被照明物体表面的反射光影响，假定物体表面光滑不透明且由理想材料构成，环境假设为由白光照明。一般来说，反射光可以分成三个分量，即环境反射、漫反射和镜面反射。环境反射分量假定入射光均匀地从周围环境入射至景物表面并等量地向各个方向反射出去，通常物体表面还会受到从周围环境来的反射光（如来自地面、天空、墙壁等的反射光）的照射，这些光常统称为环境光（Ambient Light）；漫反射分量表示特定光源在景物表面的反射光中那些向空间各方向均匀反射出去的光，这些光常称为漫射光（Diffuse Light）；镜面反射光为朝一定方向的反射光，如一个点光源照射一个金属球时会在球面上形成一块特别亮的区域，呈现所谓“高光（Highlight）”，它是光源在金属球面上产生的镜面反射光（Specular Light）。对于较光滑物体，其镜面反射光的高光区域小而亮；相反，粗糙表面的镜面反射光呈发散状态，其高光区域大而不亮。下面先看一个简单的光照例程。 例10-1 简单光照例程（light0.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h);void CALLBACK display(void); void myinit(void){GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 }; glLightfv(GL_LIGHT0, GL_POSITION, light_position); glEnable(GL_LIGHTING);glEnable(GL_LIGHT0);glDepthFunc(GL_LESS);glEnable(GL_DEPTH_TEST);} void CALLBACK display(void){glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);auxSolidSphere(1.0);glFlush();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)glOrtho (-1.5, 1.5, -1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w, -10.0, 10.0);elseglOrtho (-1.5(GLfloat)w/(GLfloat)h, 1.5(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Simple Lighting”);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果是显示一个具有灰色光影的球。其中函数myinit()中包含了关键的设定光源位置、启动光照等几句，而其它程序语言几乎与以前的没有多大区别，但效果却完全不一样。下面几个小节将详细介绍有关函数的用法。 图10-1 带光影的灰色球体10.2.2 OpenGL光组成在OpenGL简单光照模型中的几种光分为：辐射光（Emitted Light）、环境光（Ambient Light）、漫射光（Diffuse Light）、镜面光（Specular Light）。辐射光是最简单的一种光，它直接从物体发出并且不受任何光源影响。环境光是由光源发出经环境多次散射而无法确定其方向的光，即似乎来自所有方向。一般说来，房间里的环境光成分要多些，户外的相反要少得多，因为大部分光按相同方向照射，而且在户外很少有其他物体反射的光。当环境光照到曲面上时，它在各个方向上均等地发散（类似于无影灯光）。漫射光来自一个方向，它垂直于物体时比倾斜时更明亮。一旦它照射到物体上，则在各个方向上均匀地发散出去。于是，无论视点在哪里它都一样亮。来自特定位置和特定方向的任何光，都可能有散射成分。镜面光来自特定方向并沿另一方向反射出去，一个平行激光束在高质量的镜面上产生100%的镜面反射。光亮的金属和塑料具有很高非反射成分，而象粉笔和地毯等几乎没有反射成分。因此，三某种意义上讲，物体的反射程度等同于其上的光强（或光亮度）。 10.2.3 创建光源（Light Source）光源有许多特性，如颜色、位置、方向等。选择不同的特性值，则对应的光源作用在物体上的效果也不一样，这在以后的章节中会逐步介绍的。下面详细讲述定义光源特性的函数glLight*()： void glLight{if}v 创建具有某种特性的光源。其中第一个参数light指定所创建的光源号，如GL_LIGHT0、GL_LIGHT1、…、GL_LIGHT7。第二个参数pname指定光源特性，这个参数的辅助信息见表10-1所示。最后一个参数设置相应的光源特性值。 pname 参数名 缺省值 说明 GL_AMBIENT (0.0, 0.0, 0.0, 1.0) RGBA模式下环境光 GL_DIFFUSE (1.0, 1.0, 1.0, 1.0) RGBA模式下漫反射光 GL_SPECULAR (1.0,1.0,1.0,1.0) RGBA模式下镜面光 GL_POSITION (0.0,0.0,1.0,0.0) 光源位置齐次坐标（x,y,z,w） GL_SPOT_DIRECTION (0.0,0.0,-1.0) 点光源聚光方向矢量（x,y,z） GL_SPOT_EXPONENT 0.0 点光源聚光指数 GL_SPOT_CUTOFF 180.0 点光源聚光截止角 GL_CONSTANT_ATTENUATION 1.0 常数衰减因子 GL_LINER_ATTENUATION 0.0 线性衰减因子 GL_QUADRATIC_ATTENUATION 0.0 平方衰减因子 表10-1 函数glLight*()参数pname说明注意：以上列出的GL_DIFFUSE和GL_SPECULAR的缺省值只能用于GL_LIGHT0，其他几个光源的GL_DIFFUSE和GL_SPECULAR缺省值为(0.0,0.0,0.0,1.0)。另外，表中后六个参数的应用放在下一篇中介绍。在上面例程中，光源的创建为： GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };glLightfv(GL_LIGHT0, GL_POSITION, light_position); 其中light_position是一个指针，指向定义的光源位置齐次坐标数组。其它几个光源特性都为缺省值。同样，我们也可用类似的方式定义光源的其他几个特性值，例如： GLfloat light_ambient [] = { 0.0, 0.0, 0.0, 1.0 };GLfloat light_diffuse [] = { 1.0, 1.0, 1.0, 1.0 };GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };glLightfv(GL_LIGHT0, GL_AMBIENT , light_ambient );glLightfv(GL_LIGHT0, GL_DIFFUSE , light_diffuse );glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular); 10.2.4 启动光照在OpenGL中，必须明确指出光照是否有效或无效。如果光照无效，则只是简单地将当前颜色映射到当前顶点上去，不进行法向、光源、材质等复杂计算，那么显示的图形就没有真实感，如前几章例程运行结果显示。要使光照有效，首先得启动光照，即： glEnable(GL_LIGHTING); 若使光照无效，则调用gDisable(GL_LIGHTING)可关闭当前光照。然后，必须使所定义的每个光源有效，例light0.c中只用了一个光源，即： glEnable(GL_LIGHT0); 其它光源类似，只是光源号不同而已。10.3、明暗处理在计算机图形学中，光滑的曲面表面常用多边形予以逼近和表示，而每个小多边形轮廓（或内部）就用单一的颜色或许多不同的颜色来勾画（或填充），这种处理方式就称为明暗处理。在OpenGL中，用单一颜色处理的称为平面明暗处理（Flat Shading），用许多不同颜色处理的称为光滑明暗处理（Smooth Shading），也称为Gourand明暗处理（Gourand Shading）。设置明暗处理模式的函数为： void glShadeModel(GLenum mode); 函数参数为GL_FLAT或GL_SMOOTH，分别表示平面明暗处理和光滑明暗处理。应用平面明暗处理模式时，多边形内每个点的法向一致，且颜色也一致；应用光滑明暗处理模式时，多边形所有点的法向是由内插生成的，具有一定的连续性，因此每个点的颜色也相应内插，故呈现不同色。这种模式下，插值方法采用的是双线性插值法，如图10-2所示。 图10-2 Gouraud明暗处理Gouraud明暗处理通常算法为：先用多边形顶点的光强线性插值出当前扫描线与多边形边交点处的光强，然后再用交点的光强线插值处扫描线位于多边形内区段上每一象素处的光强值。图中显示出一条扫描线与多边形相交，交线的端点是A点和B点，P点是扫描线上位于多边形内的任一点，多边形三个顶点的光强分别为I1、I2和I3.取A点的光强Ia为I1和I2的线性插值，B点的光强Ib为I1和I3的线性插值，P点的光强Ip则为Ia和Ib的线性插值。采用Gouraud明暗处理不但可以使用多边形表示的曲面光强连续，而且计算量很小。这种算法还可以以增量的形式改进，且能用硬件直接实现算法，从而广泛用于计算机实时图形生成。请看下面光滑明暗处理的例程： 例10-2 明暗处理例程（Shading.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void object(void);void CALLBACK display(void);void CALLBACK myReshape(GLsizei w, GLsizei h); / GL_SMOOTH is actually the default shading model. /void myinit (void){glShadeModel (GL_SMOOTH);} void object(void){glBegin (GL_POLYGON);glColor3f (1.0, 0.0, 0.0);glVertex2f (4.0, 4.0);glColor3f(1.0,1.0,1.0);glVertex2f (12.0, 4.0);glColor3f(0.0,0.0,1.0);glVertex2f (12.0, 12.0);glColor3f(0.0,1.0,0.0);glVertex2f (4.0, 12.0);glEnd ();} void CALLBACK display(void){glClear (GL_COLOR_BUFFER_BIT);object ();glFlush ();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)gluOrtho2D (0.0, 16.0, 0.0, 16.0 (GLfloat) h/(GLfloat) w);elsegluOrtho2D (0.0, 16.0 (GLfloat) w/(GLfloat) h, 0.0, 16.0);glMatrixMode(GL_MODELVIEW);} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Smooth Shading”);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果是在屏幕上显示一个色彩连续变化的三角形。这个程序是用的RGBA显示模式，若改用颜色表模式，则颜色内插实际上是颜色表的内插，因此呈现的颜色可能不连续。网友不妨自己试试。另外，若在light0.c程序中加上一句定义GL_FLAT明暗处理模式，则又会出现怎样的情形呢？读者可以仔细比较一下。 图10-3 高氏明暗处理的正方形10.4、材质 10.4.1 材质颜色OpenGL用材料对光的红、绿、蓝三原色的反射率来近似定义材料的颜色。象光源一样，材料颜色也分成环境、漫反射和镜面反射成分，它们决定了材料对环境光、漫反射光和镜面反射光的反射程度。在进行光照计算时，材料对环境光的反射率与每个进入光源的环境光结合，对漫反射光的反射率与每个进入光源的漫反射光结合，对镜面光的反射率与每个进入光源的镜面反射光结合。对环境光与漫反射光的反射程度决定了材料的颜色，并且它们很相似。对镜面反射光的反射率通常是白色或灰色（即对镜面反射光中红、绿、蓝的反射率相同）。镜面反射高光最亮的地方将变成具有光源镜面光强度的颜色。例如一个光亮的红色塑料球，球的大部分表现为红色，光亮的高光将是白色的。 10.4.2 材质定义材质的定义与光源的定义类似。其函数为： void glMaterial{if}v; 定义光照计算中用到的当前材质。face可以是GL_FRONT、GL_BACK、GL_FRONT_AND_BACK，它表明当前材质应该应用到物体的哪一个面上；pname说明一个特定的材质；param是材质的具体数值，若函数为向量形式，则param是一组值的指针，反之为参数值本身。非向量形式仅用于设置GL_SHINESS。pname参数值具体内容见表10-1。另外，参数GL_AMBIENT_AND_DIFFUSE表示可以用相同的 RGB值设置环境光颜色和漫反射光颜色。 参数名 缺省值 说明 GL_AMBIENT (0.2, 0.2, 0.2, 1.0) 材料的环境光颜色 GL_DIFFUSE (0.8, 0.8, 0.8, 1.0) 材料的漫反射光颜色 GL_AMBIENT_AND_DIFFUSE 材料的环境光和漫反射光颜色 GL_SPECULAR (0.0, 0.0, 0.0, 1.0) 材料的镜面反射光颜色 GL_SHINESS 0.0 镜面指数（光亮度） GL_EMISSION (0.0, 0.0, 0.0, 1.0) 材料的辐射光颜色 GL_COLOR_INDEXES (0, 1, 1) 材料的环境光、漫反射光和镜面光颜色 表10-2 函数glMaterial*()参数pname的缺省值例10-3 材质定义例程（light1.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h); void CALLBACK display(void); void myinit(void){/ 设置材质的各种光的颜色成分反射比率 /GLfloat mat_ambient[]={0.8,0.8,0.8,1.0};GLfloat mat_diffuse[]={0.8,0.0,0.8,1.0}; / 紫色 /GLfloat mat_specular[] = { 1.0, 0.0, 1.0, 1.0 }; / 亮紫色 /GLfloat mat_shininess[] = { 50.0 }; GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 }; glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess); glLightfv(GL_LIGHT0, GL_POSITION, light_position); glEnable(GL_LIGHTING);glEnable(GL_LIGHT0);glDepthFunc(GL_LESS);glEnable(GL_DEPTH_TEST);} void CALLBACK display(void){glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);auxSolidSphere(1.0);glFlush();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)glOrtho (-1.5, 1.5, -1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w, -10.0, 10.0);elseglOrtho (-1.5(GLfloat)w/(GLfloat)h, 1.5(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH16);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Lighting_1 “);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果是一个紫色的球。在函数myinit()中定义了球的材质颜色，光源的定义仍延用light0.c中的，而light.c物体的光源定义为缺省形式。从例子中明显地看出，物体的材质颜色定义与光源颜色定义几乎一样，物体反射到眼中的颜色与二者都有关系，具体关系请看下一小节。 10.4.3 材质RGB值和光源RGB值的关系材质的颜色与光源的颜色有些不同。对于光源，R、G、B值等于R、G、B对其最大强度的百分比。若光源颜色的R、G、B值都是1.0，则是最强的白光；若值变为0.5，颜色仍为白色，但强度为原来的一半，于是表现为灰色；若R＝G＝1.0，B＝0.0，则光源为黄色。对于材质，R、G、B值为材质对光的 R、G、B成分的反射率。比如，一种材质的R＝1.0、G＝0.5、B＝0.0，则材质反射全部的红色成分，一半的绿色成分，不反射蓝色成分。也就是说，若OpenGL的光源颜色为（LR、LG、LB），材质颜色为（MR、MG、MB），那么，在忽略所有其他反射效果的情况下，最终到达眼睛的光的颜色为（LRMR、LGMG、LB*MB）。同样，如果有两束光，相应的值分别为（R1、G1、B1）和（R2、G2、B2），则OpenGL 将各个颜色成分相加，得到（R1+R2、G1+G2、B1+B2），若任一成分的和值大于1（超出了设备所能显示的亮度）则约简到1.0。下面一例程就说明了二者之间的关系。 例10-4 材质与光源的RGB关系例程（light2.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h);void CALLBACK display(void); void myinit(void){GLfloat mat_ambient[]= { 0.8, 0.8, 0.8, 1.0 };GLfloat mat_diffuse[]= { 0.8, 0.0, 0.8, 1.0 }; / 紫色 /GLfloat mat_specular[] = { 1.0, 0.0, 1.0, 1.0 };GLfloat mat_shininess[] = { 50.0 }; GLfloat light_diffuse[]= { 0.0, 0.0, 1.0, 1.0}; / 蓝色 /GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 }; glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess); glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);glLightfv(GL_LIGHT0, GL_POSITION, light_position); glEnable(GL_LIGHTING);glEnable(GL_LIGHT0);glDepthFunc(GL_LESS);glEnable(GL_DEPTH_TEST);} void CALLBACK display(void){glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);auxSolidSphere(1.0);glFlush();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)glOrtho (-1.5, 1.5, -1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w, -10.0, 10.0);elseglOrtho (-1.5(GLfloat)w/(GLfloat)h, 1.5(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH16);auxInitPosition (0, 0, 500, 500);auxInitWindow (“Lighting_2 “);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序运行结果是一个蓝色的球，其中高光部分仍为上一例的亮紫色。从上可看出，球漫反射光的结果是mat_diffuse[]与 light_diffuse[]中的三个颜色分量值相乘，即 (0.01.0,0.01.0,0.81.0,1.01.0)=(0.0,0.0,0.8,1.0)，所以球大部分呈现蓝色。 图10-4 光照蓝色球（高光为红色）10.4.4 材质改变在实际应用的许多情况下，不同的物体或同一物体的不同部分都有可能设置不同的材质，OpenGL函数库提供了两种方式实现这种要求。下面一例程采用的是设置矩阵堆栈来保存不同物体的材质信息： 例10-5 矩阵堆栈改变材质例程（chgmat1.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK display(void);void CALLBACK myReshape(GLsizei w, GLsizei h); / 初始化z-buffer、光源和光照模型，在此不具体定义材质。/void myinit(void){GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };GLfloat position[] = { 0.0, 3.0, 2.0, 0.0 };GLfloat lmodel_ambient[] = { 0.4, 0.4, 0.4, 1.0 }; glEnable(GL_DEPTH_TEST);glDepthFunc(GL_LESS); glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);glLightfv(GL_LIGHT0, GL_POSITION, position); glEnable(GL_LIGHTING);glEnable(GL_LIGHT0); glClearColor(0.0, 0.1, 0.1, 0.0);} void CALLBACK display(void){GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };GLfloat no_shininess[] = { 0.0 };GLfloat low_shininess[] = { 5.0 };GLfloat high_shininess[] = { 100.0 };GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0}; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); / 第一行第一列绘制的球仅有漫反射光而无环境光和镜面光。/glPushMatrix();glTranslatef (-3.75, 3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第一行第二列绘制的球有漫反射光和镜面光，并有低高光，而无环境光 。/glPushMatrix();glTranslatef (-1.25, 3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第一行第三列绘制的球有漫反射光和镜面光，并有很亮的高光，而无环境光 。/glPushMatrix();glTranslatef (1.25, 3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第一行第四列绘制的球有漫反射光和辐射光，而无环境和镜面反射光。/glPushMatrix();glTranslatef (3.75, 3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);auxSolidSphere(1.0);glPopMatrix(); / 第二行第一列绘制的球有漫反射光和环境光，而镜面反射光。/glPushMatrix();glTranslatef (-3.75, 0.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第二行第二列绘制的球有漫反射光、环境光和镜面光，且有低高光。/glPushMatrix();glTranslatef (-1.25, 0.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第二行第三列绘制的球有漫反射光、环境光和镜面光，且有很亮的高光。/glPushMatrix();glTranslatef (1.25, 0.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第二行第四列绘制的球有漫反射光、环境光和辐射光，而无镜面光。/glPushMatrix();glTranslatef (3.75, 0.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);auxSolidSphere(1.0); glPopMatrix(); / 第三行第一列绘制的球有漫反射光和有颜色的环境光，而无镜面光。/glPushMatrix();glTranslatef (-3.75, -3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第三行第二列绘制的球有漫反射光和有颜色的环境光以及镜面光，且有低高光。/glPushMatrix();glTranslatef (-1.25, -3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第三行第三列绘制的球有漫反射光和有颜色的环境光以及镜面光，且有很亮的高光。/glPushMatrix();glTranslatef (1.25, -3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);auxSolidSphere(1.0);glPopMatrix(); / 第三行第四列绘制的球有漫反射光和有颜色的环境光以及辐射光，而无镜面光。/glPushMatrix();glTranslatef (3.75, -3.0, 0.0);glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);auxSolidSphere(1.0);glPopMatrix(); glFlush();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= (h 2))glOrtho (-6.0, 6.0, -3.0((GLfloat)h2)/(GLfloat)w,3.0((GLfloat)h2)/(GLfloat)w, -10.0, 10.0);elseglOrtho (-6.0(GLfloat)w/((GLfloat)h2),6.0(GLfloat)w/((GLfloat)h*2), -3.0, 3.0, -10.0, 10.0);glMatrixMode(GL_MODELVIEW);} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);auxInitPosition (0, 0, 600, 450);auxInitWindow (“Material”);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 图10-5 多种光和材质的变化效果以上程序运行结果是绘制12个球（3行4列）。第一行的球材质都没有环境反射光，第二行的都有一定的环境反射光，第三行的都有某种颜色的环境光。而第一列的球材质仅有蓝色的漫反射光；第二列的不仅有蓝漫反射光，而且还有镜面反射光，较低的高光；第三列的不仅有蓝漫反射光，而且还有镜面反射光，很亮的高光；第四列的还包括辐射光，但无镜面光。这个程序运用矩阵堆栈多次调用glMaterialfv()来设置每个球的材质，也就是改变同一场景中的不同物体的颜色。但由于这个函数的应用有个性能开销，因此建议最好尽可能少的改变材质，以减少改变材质时所带来的性能开销，可采用另一种方式即改变材质颜色，相应函数为glColorMaterial()，说明如下： void glColorMaterial(GLenum face,GLenum mode); 函数参数face指定面，值有GL_FRONT、GL_BACK或GL_FRONT_AND_BACK（缺省值）。mode指定材质成分，值有 GL_AMBIENT、GL_DIFFUSE、GL_AMBIENT_AND_DIFFUSE（缺省值）、GL_SPECULAR或 GLEMISSION。注意：这个函数说明了两个独立的值，第一个参数说明哪一个面和哪些面被修改，而第二个参数说明这些面的哪一个或哪些材质成分要被修改。OpenGL并不为每一种face保持独立的mode变量。在调用glColorMterial() 以后，首先需要用GL_COLOR_MATERIAL作为参数调用glEnable()来启动颜色材质，然后在绘图时调用glColor*()来改变当前颜色，或用glMaterial()来改变材质成分。当不用这种方式来改变材质时，可调用glDisable(GL_COLOR_MATERIAL)来关闭取消。如下面一段代码： glColorMaterial(GL_FRONT,GL_DIFFUSE);glEnable(GL_COLOR_MATERIAL);glColor3f(0.3,0.5,0.7);/ draw some objects here. /glcolor3f(0.0,1.0,0.0);/ draw other objects here./glDisable(GL_COLOR_MATERIAL); 当需要改变场景中大部分方面的单个材质时，最好调用glColorMaterial()；当需要修改不止一个材质参数时，最好调用glMaterial*()。注意，当不需要颜色材质时一定要关闭它，以避免相应的开销。下面来看一个颜色材质的具体应用例子： 例10-6 颜色定义改变材质例程（chgmat2.c） #include “glos.h” #include &lt;GL/gl.h&gt; #include &lt;GL/glu.h&gt; #include &lt;GL/glaux.h&gt; void myinit(void);void CALLBACK myReshape(GLsizei w, GLsizei h);void CALLBACK display(void); void myinit(void){GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 }; glLightfv(GL_LIGHT0, GL_POSITION, light_position); glEnable(GL_LIGHTING);glEnable(GL_LIGHT0);glDepthFunc(GL_LESS);glEnable(GL_DEPTH_TEST); glColorMaterial(GL_FRONT, GL_DIFFUSE);glEnable(GL_COLOR_MATERIAL);} void CALLBACK display(void){glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); / draw one yellow ball /glLoadIdentity();glTranslatef(-0.7,0.0,0.0);glColor3f(1.0,1.0,0.0);auxSolidSphere(0.5); / draw one red cone /glLoadIdentity();glRotatef(-65.0,1.0,0.0,0.0);glTranslatef(0.7,0.0,0.0);glColor3f(1.0,0.0,0.0);auxSolidCone(0.4,0.6); glFlush();} void CALLBACK myReshape(GLsizei w, GLsizei h){glViewport(0, 0, w, h);glMatrixMode(GL_PROJECTION);glLoadIdentity();if (w &lt;= h)glOrtho (-1.5, 1.5, -1.5(GLfloat)h/(GLfloat)w, 1.5(GLfloat)h/(GLfloat)w, -10.0, 10.0);elseglOrtho (-1.5(GLfloat)w/(GLfloat)h, 1.5(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);glMatrixMode(GL_MODELVIEW);glLoadIdentity();} void main(void){auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);auxInitPosition (0, 0, 500, 500);auxInitWindow (“ColorMaterial Mode”);myinit();auxReshapeFunc (myReshape);auxMainLoop(display);} 以上程序改变的是漫反射颜色。场景中显示了一个黄色的球和一个红色的锥体。 **图10-6 漫反射材质改变 **转自：http://blog.csdn.net/iduosi/article/details/7835624","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"OPenGL","slug":"OPenGL","permalink":"http://www.voyax.me/tags/OPenGL/"}]},{"title":"OPenGL函数glMatrixMode和glMatrixMode()和gluPerspective和gluLookAt用法","slug":"opengl函数glmatrixmode和glmatrixmode和gluperspective和glulookat用法","date":"2014-04-03T04:02:57.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/22260/","link":"","permalink":"http://www.voyax.meposts/22260/","excerpt":"","text":"glMatrixMode当您调用glLoadIdentity()之后，您实际上将当前点移到了屏幕中心：类似于一个复位操作 1.X坐标轴从左至右，Y坐标轴从下至上，Z坐标轴从里至外。 2.OpenGL屏幕中心的坐标值是X和Y轴上的0.0f点。 3.中心左面的坐标值是负值，右面是正值。 移向屏幕顶端是正值，移向屏幕底端是负值。 移入屏幕深处是负值，移出屏幕则是正值。 &nbsp; glLoadIdentity()该函数的功能是重置当前指定的矩阵为单位矩阵.在语义上，其等同于用单位矩阵调用glLoadMatrix()。但是，在一些情况下，glLoadIdentity()更加效率。 ## glMatrixMode()&nbsp; glMatrixMode()函数的参数，这个函数其实就是对接下来要做什么进行一下声明，也就是在要做下一步之前告诉计算机我要对“什么”进行操作了，这个“什么”在glMatrixMode的“()”里的选项(参数)有3种模式: GL_PROJECTION 投影, GL_MODELVIEW 模型视图, GL_TEXTURE 纹理. &nbsp; 如果参数是GL_PROJECTION，这个是投影的意思，就是要对投影相关进行操作，也就是把物体投影到一个平面上，就像我们照相一样，把3维物体投到2维的平面上。这样，接下来的语句可以是跟透视相关的函数，比如glFrustum()或gluPerspective()； 在操作投影矩阵以前，需要调用函数： glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影矩阵 然后把矩阵设为单位矩阵： glLoadIdentity(); 然后调用glFrustum()或gluPerspective(),它们生成的矩阵会与当前的矩阵相乘,生成透视的效果； &nbsp; 如果参数是GL_MODELVIEW，这个是对模型视景的操作，接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数； 若是GL_TEXTURE，就是对纹理相关进行操作 顺便说下，OpenGL里面的操作，很多是基于对矩阵的操作的，比如位移，旋转，缩放，所以，这里其实说的规范一点就是glMatrixMode是用来指定哪一个矩阵是当前矩阵，而它的参数代表要操作的目标，GL_PROJECTION是对投影矩阵操作，GL_MODELVIEW是对模型视景矩阵操作，GL_TEXTURE是对纹理矩阵进行随后的操作。 &nbsp; 切换当前矩阵. 如.要使用透视(3D).那么先要设置透视投影 glMatrixMode(GL_PROJECTION); //切换到投影矩阵. //…设置透视投影 设置完成后开始画图,需要切换到 模型视图矩阵 才能正确画图. glMatrixMode(GL_MODELVIEW); // 画一个物体A (看起来是3D的), // 如这时候需画一个 2D效果 的 物体A,那么又需要透视投影 &nbsp; glMatrixMode(GL_PROJECTION); //切换到投影矩阵.. // ..设置正交投影 //..设置完成,切换回模型视图矩阵….. glMatrixMode(GL_MODELVIEW); // 再画一个物体A (看起来是2D的) &nbsp; &nbsp; // 如从头到尾都是画3D/2D, 只需初始化时设置一次. // 如果有交替,那么就需要glMatrixMode() 切换 // 因这样设置很烦人,所以又有glPushMatrix() 保存当前矩阵 4.gluPerspectivegluPerspective这个函数指定了观察的视景体（frustum为锥台的意思，通常译为视景体）在世界坐标系中的具体大小，一般而言，其中的参数aspect应该与窗口的宽高比大小相同。比如说，aspect=2.0表示在观察者的角度中物体的宽度是高度的两倍，在视口中宽度也是高度的两倍，这样显示出的物体才不会被扭曲。 NAME（函数名称） gluPerspective – set up a perspective projection matrix (设置透视投影矩阵) C SPECIFICATION(C语言实现示例) void gluPerspective( GLdouble fovy, //角度 GLdouble aspect,//视景体的宽高比 GLdouble zNear,//沿z轴方向的两裁面之间的距离的近处 GLdouble zFar //沿z轴方向的两裁面之间的距离的远处 ) PARAMETERS(参数含义) fovy Specifies the field of view angle, in degrees, in the y direction. 指定视景体的视野的角度，以度数为单位，y轴的上下方向 aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height). 指定你的视景体的宽高比（x 平面上） zNear Specifies the distance from the viewer to the near clipping plane (always positive). 指定观察者到视景体的最近的裁剪面的距离（必须为正数） zFar Specifies the distance from the viewer to the far clipping plane (always positive). 与上面的参数相反，这个指定观察者到视景体的最远的裁剪面的距离（必须为正数） DESCRIPTION（说明） gluPerspective specifies a viewing frustum into the world coordinate system. In general, the aspect ratio in gluPerspective should match the aspect ratio of the associated viewport. For example, aspect = 2.0 means the viewer’s angle of view is twice as wide in x as it is in y. If the viewport is twice as wide as it is tall, it displays the image without distortion. The matrix generated by gluPerspective is multipled by the current matrix, just as if glMultMatrix were called with the generated matrix. To load the perspective matrix onto the current matrix stack instead, precede the call to gluPerspective with a call to glLoadIdentity. 由gluPerspective产生的矩阵是与当前矩阵与指定的矩阵相乘得到的，就好像是调用glMatrix()产生的矩阵一样。为了使透视矩阵替代当前矩阵，在调用gluPerspective之前要先调用glLoadidentity()这个函数（就是把当前矩阵s设置为单位矩阵）。 补充，这段话的意思就是说（个人理解），这个gluPerspective的实现是通过将当前矩阵与你通过这个函数指定的参数而建立的矩阵相乘来实现的，而在OpenGL中，矩阵的相乘都是连乘的，也就是说，你调用这个函数会与其他的变化矩阵的函数效果相叠加从而影响原矩阵（当然有时候确实需要这样做），所以，在调用这个函数之前，通常需要先调用glLoadidentity来把当前矩阵单位化，从而使各种变换效果不会叠加，比如旋转就只旋转，透视就只透视，通过调用glLoadidentity就不会既旋转有透视了。 5.gluLookAt 视点转换 函数原型 void gluLookAt(GLdouble eyex,GLdouble eyey,GLdouble eyez,GLdouble centerx,GLdouble centery,GLdouble centerz,GLdouble upx,GLdouble upy,GLdouble upz); 该函数定义一个视图矩阵，并与当前矩阵相乘。 第一组eyex, eyey,eyez 相机在世界坐标的位置 第二组centerx,centery,centerz 相机镜头对准的物体在世界坐标的位置 第三组upx,upy,upz 相机向上的方向在世界坐标中的方向 你把相机想象成为你自己的脑袋： 第一组数据就是脑袋的位置 第二组数据就是眼睛看的物体的位置 第三组就是头顶朝向的方向（因为你可以歪着头看同一个物体）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"OPenGL","slug":"OPenGL","permalink":"http://www.voyax.me/tags/OPenGL/"}]},{"title":"2014年阿里巴巴网申前端工程师总结","slug":"2014年阿里巴巴网申前端工程师总结","date":"2014-04-02T16:31:32.000Z","updated":"2017-06-18T09:30:28.000Z","comments":true,"path":"/posts/33896/","link":"","permalink":"http://www.voyax.meposts/33896/","excerpt":"来总结下昨天参加阿里巴巴前端工程师线上笔试的感受，这应当是近半年来给自己最大的教训。 先说说阿里前端笔试的大体情况，总共10题，我抽到的有8道都是写代码的（不要期望有选择题），考试时间100分钟，不要以为时间很多，大多数人都是做不完的。 大家其实最关心的是题目难度，如果你做过2014年阿里巴巴招应届毕业生的考题，那很不好意思的告诉你，针对大三学生暑期实习的考题给我的印象是比给毕业生的题还难！考完后就有人吐槽这哪是招实习生啊，就是招前端大牛啊！ 不过如果你真的实实在在开发过前段，其实那并不是问题，前端开发不像算法，前端其实难度系数不大，它的特点在于“广”、“细”，即你需要学习的知识很多，一大堆啊~，还有就是前端细节太多，这个相信大家都有同感的吧。而这也是准备笔试需要关注的，总结一下，我自己认为的前端笔试前准备的几个要点： 1.实际开发 这点很重要，不仅是技术的学习很巩固，而且在笔试的时候你很有可能发现笔试的题目就是你以前写过的！（我就遇到了） 2.多练手，熟悉 这是我这次笔试最大的败笔，我已经一学期多都写过前端了，很多都不拿不准，导致我做题速度太慢！题量还是挺大的，一定要抓紧时间啊！ 3.多了解一些专业术语，要不然一道很简单的题换个花样说出来你就得给跪了 4.做题一定不要慌，能做多少做多少，不要想着一定做完，除非你真的很牛。","text":"来总结下昨天参加阿里巴巴前端工程师线上笔试的感受，这应当是近半年来给自己最大的教训。 先说说阿里前端笔试的大体情况，总共10题，我抽到的有8道都是写代码的（不要期望有选择题），考试时间100分钟，不要以为时间很多，大多数人都是做不完的。 大家其实最关心的是题目难度，如果你做过2014年阿里巴巴招应届毕业生的考题，那很不好意思的告诉你，针对大三学生暑期实习的考题给我的印象是比给毕业生的题还难！考完后就有人吐槽这哪是招实习生啊，就是招前端大牛啊！ 不过如果你真的实实在在开发过前段，其实那并不是问题，前端开发不像算法，前端其实难度系数不大，它的特点在于“广”、“细”，即你需要学习的知识很多，一大堆啊~，还有就是前端细节太多，这个相信大家都有同感的吧。而这也是准备笔试需要关注的，总结一下，我自己认为的前端笔试前准备的几个要点： 1.实际开发 这点很重要，不仅是技术的学习很巩固，而且在笔试的时候你很有可能发现笔试的题目就是你以前写过的！（我就遇到了） 2.多练手，熟悉 这是我这次笔试最大的败笔，我已经一学期多都写过前端了，很多都不拿不准，导致我做题速度太慢！题量还是挺大的，一定要抓紧时间啊！ 3.多了解一些专业术语，要不然一道很简单的题换个花样说出来你就得给跪了 4.做题一定不要慌，能做多少做多少，不要想着一定做完，除非你真的很牛。 其实考完后还有好多想法，今天早点睡，以后再慢慢补上来吧。 &nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"最简单的Goagent配置教程【图文】","slug":"最简单的goagent配置教程【图文】","date":"2014-04-02T15:59:12.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/47237/","link":"","permalink":"http://www.voyax.meposts/47237/","excerpt":"网上的goagent的教程不仅看着麻烦（就是某些人故弄玄虚）而且都是千篇一律，对于对计算机比较陌生的人来说，看着就让人头疼，下面写一个goagent的配置教程，争取做到简单，明了。 工欲善其事必先利其器： 1：确保你有一个Google账号 2.下载goagent最新版（老版本很多地址已经不能用了）：https://code.google.com/p/goagent/","text":"网上的goagent的教程不仅看着麻烦（就是某些人故弄玄虚）而且都是千篇一律，对于对计算机比较陌生的人来说，看着就让人头疼，下面写一个goagent的配置教程，争取做到简单，明了。 工欲善其事必先利其器： 1：确保你有一个Google账号 2.下载goagent最新版（老版本很多地址已经不能用了）：https://code.google.com/p/goagent/ 着手配置： 1.申请Google Appengine并创建appid https://appengine.google.com/ 说明一下，这里完全没必要按照goagent官方教程中那么麻烦去申请账号，然后还要保存一大串密码，直接用你的Google账号到上面的链接，点击Great Application，如下图： &nbsp; [caption id=”attachment_115” align=”alignnone” width=”1043”] Google App Engine[/caption] 创建一个appid(这个图片借用了下网上的图片): &nbsp; 2.创建完appid，你已经完成1/3了，现在进入下载的goagent文件夹： 双击server文件夹下的upload.bat 根据提示输入相应信息： [caption id=”attachment_117” align=”alignnone” width=”674”] 上传账户信息[/caption] 这步完成后，编辑local\\proxy.ini，把其中appid = goagent中的goagent 改成你已经上传成功的应用的appid 注意：在配置文件proxy.ini中可以选择ipv6或者ipv4，找到profile = ipv4这行，把ipv4换成ipv6就切换成ipv6了 3.最后一步啦~，配置浏览器： 这里我只说chrome的配置方法（IE是不需要配置的，当你运行goagent.exe后右键goagent的图标你会看到一个IE代理设置，在那里可以直接选择代理，不需要其他任何设置）: 安装Google扩展插件Proxy SwitchySharp，https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm 安装完成后，进行设置： 点击 Proxy SwitchySharp图标》选项》导入/导出》 点击“从文件恢复”，选择goagent文件夹下local文件夹下的switchyoptions.bak，导入 [caption id=”attachment_118” align=”alignnone” width=”795”] Proxy SwitchySharp设置[/caption] &nbsp; OK，大功告成，现在单击地址栏右侧Proxy SwitchySharp图标即可进行模式选择了，一般直接选择“自动选择”就好了。 下面是所有规则具体意义： 遇到规则中没有的，可以使用扩展的“新建规则”按钮自行添加，选情景模式为“GoAgent”，使用此模式可以方便的定制自己的代理切换规则 这个扩展偶尔会出BUG，出现设置无误但浏览器提示错误130无法连接到代理服务器，可以将自己的设置导出之后卸载重装 如果遇到无法更新规则列表，可以先运行goagent，并把浏览器代理设置为GoAgent模式再更新规则，不更新规则只会影响自动切换模式，不会影响其他模式的使用，若确实无法更新也可不更新，直接把扩展设置为GoAgent PAC模式即可","categories":[{"name":"工具","slug":"工具","permalink":"http://www.voyax.me/categories/工具/"}],"tags":[]},{"title":"理解蝶形运算","slug":"理解蝶形运算","date":"2014-03-30T03:16:13.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/55708/","link":"","permalink":"http://www.voyax.meposts/55708/","excerpt":"","text":"对于N（2的x次方）点的离散信号，把它按索引位置分成两个序列，分别为0，2，4，….，2K（记为A）和1，3，5，….，2K-1（记为B），由傅立叶变换可以推出N点的傅立叶变换前半部分的结果为A+B旋转因子，后半部分的结果为A-B旋转因子。于是求N点的傅立叶变换就变成分别求两个N/2点序列的傅立叶变换，对每一个N/2点的序列，递归前面的步骤，直到只有两点的序列，就只变成简单的加减关系了。把这些点的加减关系用线连接，看上去就是个蝶形。 VOID WINAPI FFT(complex&lt;double&gt; TD, complex&lt;double&gt; FD, int r){// 付立叶变换点数LONG count; // 循环变量int i,j,k; // 中间变量int bfsize,p; // 角度double angle; complex&lt;double&gt; W,X1,X2,X; // 计算付立叶变换点数count = 1 &lt;&lt; r; // 分配运算所需存储器W = new complex&lt;double&gt;[count / 2];X1 = new complex&lt;double&gt;[count];X2 = new complex&lt;double&gt;[count]; // 计算加权系数for(i = 0; i &lt; count / 2; i++){angle = -i PI 2 / count;W[i] = complex&lt;double&gt; (cos(angle), sin(angle));} // 将时域点写入X1memcpy(X1, TD, sizeof(complex&lt;double&gt;) * count); // 采用蝶形算法进行快速付立叶变换for(k = 0; k &lt; r; k++){for(j = 0; j &lt; 1 &lt;&lt; k; j++){bfsize = 1 &lt;&lt; (r-k);for(i = 0; i &lt; bfsize / 2; i++){p = j bfsize;X2[i + p] = X1[i + p] + X1[i + p + bfsize / 2];X2[i + p + bfsize / 2] = (X1[i + p] - X1[i + p + bfsize / 2]) W[i * (1&lt;&lt;k)];}}X = X1;X1 = X2;X2 = X;} // 重新排序for(j = 0; j &lt; count; j++){p = 0;for(i = 0; i &lt; r; i++){if (j&amp;(1&lt;&lt;i)){p+=1&lt;&lt;(r-i-1);}}FD[j]=X1[p];} // 释放内存delete W;delete X1;delete X2;}","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"腾讯web前端开发工程师笔试题及答案","slug":"腾讯web前端开发工程师笔试题及答案","date":"2014-03-27T17:09:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/21644/","link":"","permalink":"http://www.voyax.meposts/21644/","excerpt":"","text":"腾讯**web**前端开发工程师笔试题及答案 1、 **如何实现事件委托？** 首先要知道什么是事件委托。 考虑一个列表，在li的数量非常少的时候，为每一个li添加事件侦听当然不会存在太多性能方面的问题，但是当列表非常的长，长到上百上千甚至上万的时候（当然只是一个解释，实际工作中很少遇到这么多li的情况），为每个li添加事件侦听就会对页面性能产生很大的影响。 就像下面这段代码： &lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=”utf-8” /&gt;&lt;title&gt;js性能优化&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id=’list’&gt;&lt;li&gt;精通css&lt;/li&gt;&lt;li&gt;精通js&lt;/li&gt;&lt;li&gt;精通html&lt;/li&gt;……&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=”text/javascript”&gt;(function(){var a=document.getElementById(‘list’);var b=a.getElementsByTagName(‘li’);for(var i=0;i&lt;b.length;i++){b[i].addEventListener(‘click’,function(e){var c = e.target;alert(c.innerHTML);},false);} })();&lt;/script&gt; 首先，我们来想下，产生性能问题的根本原因是什么呢？li元素（目标对象）所要进行的事件处理了。怎么可以解决这种囧况呢？ 答案就是采用事件委托，将在li对象上面要处理的事件委托给父元素或者祖先元素，即为父元素绑定事件侦听， 看看下面的改进代码： &lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=”utf-8” /&gt;&lt;title&gt;js性能优化&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id=’list’&gt;&lt;li&gt;精通css&lt;/li&gt;&lt;li&gt;精通js&lt;/li&gt;&lt;li&gt;精通html&lt;/li&gt;……&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=”text/javascript”&gt;(function(){var a=document.getElementById(‘list’);a.addEventListener(‘click’,function(e){var b = e.target;alert(b.innerHTML);},false);})();&lt;/script&gt; 虽然现在很多框架都已经实现了事件委托，但是作为一个开发人员，用框架的同时我们也应该知道他实现的原理是如何的，知其然，更要知其所以然 &nbsp; 2、 **将10进制的数302转为二进制。** 十进制转二进制的原理是： 用2辗转相除至结果为1 将余数和最后的1从下向上倒序写 就是结果 例如302 302/2 = 151 余0 151/2 = 75 余1 75/2 = 37 余1 37/2 = 18 余1 18/2 = 9 余0 9/2 = 4 余1 4/2 = 2 余0 2/2 = 1 余0 故二进制为100101110 所以程序可以写成这样：var a=302; var str=””; while(a&gt;1){ str = a%2 + str; a = parseInt(a/2); } str = a+str; &nbsp; 3、 **js中运算符的优先级(此非原题，为原理题)** 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ – - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 / % 乘法、除法、取模 + 加法、减法、字符串连接 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 &lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof == != === !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 | 按位或 &amp;&amp; 逻辑与 || 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 &nbsp; &nbsp; 4、 **typeof(null)=__** 答案为object &nbsp; 5、 **JS中给全部都是数字元素的数组排序的原生方法是sort__，其中使用的是**冒泡**排序方法。 例如：array.sort(function(a,b){return a-b;}) 详细说明访问网站： http://www.admin5.com/article/20120718/445724.shtml &nbsp; 6、 NaN * 6=__NaN__ 7、 **JS**中调用某个函数之前，如何取得该函数最多可以传递多少个参数？该函数被调用时，如果知道传了多少个参数过来？ 假设函数名为fun，那个fun.length就是它足球博彩网站最多能接受的参数个数； 在fun函数里面，arguments就是用数组装着调用时传过来的所有参数，因此arguments.length就是已经传递过来的参数个数； 如： &nbsp; function needTwoPara(p1,p2){ var a=arguments; var result=’我是个需要’+needTwoPara.length+’个参数的函数\\n’ +’您输入的参数的个数为:’+a.length+’\\n’ for(var i=0, len = a.length; i &lt; len; i++){ result=result+’第’+(i+1)+’个参数为:’+a[i]+’\\n’ } result+=’以上是用arguments来获得参数\\n’; result+=’下面用变量来获得参数:\\n’; result+=’p1:’+p1+’\\n’; result+=’p2:’+p2+’\\n’; alert(result); } alert(needTwoPara.length); needTwoPara(‘ooooo’); &nbsp; 运行结果为： 2 &nbsp; 我是个需要2个参数的函数 您输入的参数的个数为:1 第1个参数为:ooooo 以上是用arguments来获得参数 下面用变量来获得参数: p1:ooooo p2:undefined &nbsp; 8、 **软件HttpWatch**的作用？ 可以参考：http://baike.baidu.com/view/425789.htm &nbsp; 9、 **JS如何得到HTTP的请求头信息和返回的头信息？** Javascript中跟response header有关的就两个方法： getResponseHeader 从响应信息中获取指定的http头 语法strValue =oXMLHttpRequest.getResponseHeader(bstrHeader);getAllResponseHeaders 获取响应的所有http头 语法strValue =oXMLHttpRequest.getAllResponseHeaders(); 需要注意的是，通常，在IE下不能完整的获取header报头数据，只能取到如下header数据： X-Powered-By:X-UA-Compatible:Keep-Alive:Transfer-Encoding:Content-Type:比如你要获取时间戳，在IE下必须做些特殊处理，需要在后端设置一下，关闭缓存： header( ‘Cache-Control: no-store’); // 关闭缓存&nbsp;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"阿里巴巴前端工程师笔试面试题目汇总（持续更新）","slug":"阿里巴巴前端工程师笔试面试题目汇总（持续更新","date":"2014-03-27T09:55:09.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/29128/","link":"","permalink":"http://www.voyax.meposts/29128/","excerpt":"","text":"面试：① web前端优化 ② 事件冒泡（选项卡的实现） ③ CSS布局相关 ④ 应该用float吗？ ⑤ 模块化编程 ⑥ 为什么有闭包 ⑦ 延迟请求 大神面试，而且需要恶补的知识点：① 作用域问题 var a = 6;setTimeout(function () {alert(a);a = 666;}, 1000);a = 66;这道题，我可耻的没有答起，我面试结束刚刚上出租就知道这道题很水了。。。。考察作用域的，当时活生生的被大神气场照住了，周围人的集体智商都减低了！！！ ② 语义化标签 这道题我确实没辙，之前其实差点写类似的博客，却没有写，今天结束后补上吧！ 1）tite与h1的区别 2）b与strong的区别 3）i与em的区别 PS：不要小看这些题，80%人答不上来 ③ 事件绑定 addEventListener，第三个参数是用来表示事件是以事件冒泡还是事件捕获这个各位都知道！但是他问的问题是： 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获！！！ 来吧，谁能说出来。。。。 ④ CSS选择器问题 考察优先级问题，反正会出很多莫名其妙的变形，比如将style标签写在body后与body前有什么区别，比如同一dom应用多个class其应该如何表现，比如class a定义颜色为blue，class b定义颜色为red，同时应用到dom上，dom作何显示。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"一个小故事，挺感人的","slug":"一个小故事，挺感人的","date":"2014-03-26T04:27:06.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/31223/","link":"","permalink":"http://www.voyax.meposts/31223/","excerpt":"","text":"你愿意花几分钟看一个有爱的故事吗？】她是三胞胎宝宝的妈妈，她有三个未满3周岁长得近乎一模一样人见人爱的女儿。今年3月份开始，妈妈和宝宝们，有了各自的秘密。如果你有时间，就和我们一起来倾听这个痛苦与温暖同在的故事吧！ 我有一个秘密·2013成长季","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"谨以此文祭墓本学期第一次熬夜","slug":"谨以此文祭墓本学期第一次熬夜","date":"2014-03-25T12:14:30.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/50469/","link":"","permalink":"http://www.voyax.meposts/50469/","excerpt":"","text":"终于又血复活，回到我离开了四天四夜的自习室，心里那个踏实啊！ 计算机图形学，数字图像处理，汇编，阿里网申，金融，英语，好充实有没有啊！周末熬夜写数字图像处理，周一写计算机图形学写到凌晨2点多，尼玛，这只是刚开始，我不认为这样循序发展会想每天坚持跑步，从5圈加到15圈那样简单，革命尚未成功，同志还需努力啊！看着被我搁置了4天的金融，那个叫心虚啊！好歹现在终于可以回来安心上两天自习了…… 附带感慨下，经常提醒自己： 乐极生悲：这已非第一次感到如此心痛，经常脑袋一热那只能说是个脑残，满怀希望，却终是镜花水月，别自以为是别人将你玩弄于鼓掌，其实是自己犯贱。清醒，没心没肺倒也还好。 自信：自信才是改变一个人的说话、气质的根本途径，有什么直接做就好，哪这么多顾虑，对于别人和自己都要狠一点，自己就是决策者，勿让他人指手画脚！ 写了一半，没心情了，算了，就这点断了吧，不想多了，抓紧学习吧。 面壁四海图破壁， 难酬蹈海亦英雄。 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"HTML判断IE版本","slug":"html判断ie版本","date":"2014-03-25T09:49:34.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/38544/","link":"","permalink":"http://www.voyax.meposts/38544/","excerpt":"","text":"&lt;!–[if !IE]&gt;&lt;!–&gt; 除IE外都可识别 &lt;!–&lt;![endif]–&gt;&lt;!–[if IE]&gt; 所有的IE可识别 &lt;![endif]–&gt;&lt;!–[if IE 6]&gt; 仅IE6可识别 &lt;![endif]–&gt;&lt;!–[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]–&gt;&lt;!–[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]–&gt;&lt;!–[if IE 7]&gt; 仅IE7可识别 &lt;![endif]–&gt;&lt;!–[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]–&gt;&lt;!–[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]–&gt;&lt;!–[if IE 8]&gt; 仅IE8可识别 &lt;![endif]–&gt;&lt;!–[if IE 9]&gt; 仅IE9可识别 &lt;![endif]–&gt; 项目 范例 说明 ! [if !IE] The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression.NOT运算符。这是摆立即在前面的功能，操作员，或子表达式扭转布尔表达式的意义。 lt [if lt IE 5.5] The less-than operator. Returns true if the first argument is less than the second argument.小于运算符。如果第一个参数小于第二个参数，则返回true。 lte [if lte IE 6] The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument.小于或等于运算。如果第一个参数是小于或等于第二个参数，则返回true。 gt [if gt IE 5] The greater-than operator. Returns true if the first argument is greater than the second argument.大于运算符。如果第一个参数大于第二个参数，则返回true。 gte [if gte IE 7] The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument.大于或等于运算。如果第一个参数是大于或等于第二个参数，则返回true。 ( ) [if !(IE 7)] Subexpression operators. Used in conjunction with boolean operators to create more complex expressions.子表达式运营商。在与布尔运算符用于创建更复杂的表达式。 &amp; [if (gt IE 5)&amp;(lt IE 7)] The AND operator. Returns true if all subexpressions evaluate to trueAND运算符。如果所有的子表达式计算结果为true，返回true | [if (IE 6)|(IE 7)] The OR operator. Returns true if any of the subexpressions evaluates to true.OR运算符。返回true，如果子表达式计算结果为true。&nbsp; &lt;!–[if lt IE 9]&gt;加载CSS1&lt;!–[else]&gt;加载CSS2&lt;![endif]–&gt; 这样有效是有效,但是用HTML VALIDATOR里,报错,因为这个不符合XHTML 1.1的规范,如果把ELSE语句去掉,则正确. &nbsp; 方法1： 加载CSS2&lt;!–[if lt IE 9]&gt;加载CSS1(可以把要重写的写在这里).&lt;![endif]–&gt; 原文地址：http://www.cnblogs.com/dtdxrk/archive/2012/03/06/2381868.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.voyax.me/tags/前端/"}]},{"title":"视角","slug":"视角","date":"2014-03-25T07:50:33.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/4208/","link":"","permalink":"http://www.voyax.meposts/4208/","excerpt":"","text":"印象中曾经非常期待传说中丰富多彩的大学生活，不好意思真的没有“活”过来。印象中也曾经很中二的幻想着未来要不要轰轰烈烈的做些什么，不好意思只是想想。印象中还是曾经坚信着我很厉害嘛，很聪明什么的，不好意思就算你是百万人中才能出一个天才中国也有1500人。 所以说，真是充满了不好意思的感慨啊。 我们不了解。因为不了解，所以觉得绚烂、感到憧憬。但其实世界很少变化，我们的世界的翻覆不过是不再是原来的视角。 可惜啊，这个视角真的不是自愿变化的。 时间啊，时间改变了我们看的角度，不管是物理上的还是精神上的。身体慢慢长大，却有着更多的单子慢慢压下来，简直就像是多么孤单却坚韧的短匕誓言着要刺杀掉天空。一寸一寸。 撕心裂肺、狼狈不堪。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"谎言","slug":"谎言","date":"2014-03-25T07:49:00.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/36483/","link":"","permalink":"http://www.voyax.meposts/36483/","excerpt":"","text":"谎言 从什么时候开始，慢慢的谎言覆满了我的世界的每一个角落？从什么时候开始，我们总要去想一想面前这个笑的开心的人，是不是会在背后一脸鄙夷？从是么时候开始，我们举着各自的面具，斟酌着面对这一个面具要不要换成另外一张面孔？ 英俊的钟馗，狰狞的徐公；刚正的奉先，奸诈的翼德。潇洒如游侠，爽朗若江湖；嫌恶似鳏寡，卑鄙恰帝王。 我把满满的谎言编织成甲胄，欺瞒了自己，欺瞒了相信，欺瞒了爱。 然后一事无成，循环着另一个又一个再一个还一个这样许许多多的谎言。 无比愤怒、无比卑劣、无比怯懦。","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"本学期第一次熬夜了啊","slug":"本学期第一次熬夜了啊","date":"2014-03-23T20:26:10.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/40123/","link":"","permalink":"http://www.voyax.meposts/40123/","excerpt":"","text":"现在凌晨4点19，终于把代码写完……还有文档啊！ 早已知道这学期熬夜是避免不了的，只是没想到这么早。。。 好想吐槽某些老师，鉴于很多事情大家都心知肚明，不提也罢。 Mathtype装好了，继续写文档","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"【转】彩色图像转换成灰度图像","slug":"【转】彩色图像转换成灰度图像","date":"2014-03-22T17:39:35.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/57990/","link":"","permalink":"http://www.voyax.meposts/57990/","excerpt":"","text":"图像处理中，大部分的处理方法都需要事先把彩色图像转换成灰度图像才能进行相关的计算、识别。彩色图转换灰度图的原理如下：我们知道彩色位图是由R/G/B三个分量组成，其文件存储格式为BITMAPFILEHEADER+BITMAPINFOHEADER，紧跟后面的可能是:如果是24位真彩图，则每个点是由三个字节分别表示R/G/B，所以这里直接跟着图像的色彩信息；如果是8位（256色）,4位(16色)，1位(单色)图，则紧跟后面的是调色板数据，一个RGBQUAD类型的数组，其长度由BITMAPINFOHEADER.biClrUsed来决定。然后后面紧跟的才是图像数据(24位图是真实的图像数据，其他的则是调色板的索引数据)。灰度图是指只含亮度信息，不含色彩信息的图象，就象我们平时看到的黑白照片：亮度由暗到明，变化是连续的。因此，要表示灰度图，就需要把亮度值进行 量化。通常划分成0到255共256个级别，其中0最暗(全黑)，255最亮(全白)。在表示颜色的方法中，除了RGB外，还有一种叫YUV的表示方法， 应用也很多。电视信号中用的就是一种类似于YUV的颜色表示方法。在这种表示方法中，Y分量的物理含义就是亮度，Y分量包含了灰度图的所有信息，只用Y分 量就能完全能够表示出一幅灰度图来。从 RGB 到 YUV 空间的 Y 转换公式为：Y = 0.299R+0.587G+0.114B在 WINDOWS 中，表示 16 位以上的图和以下的图有点不同； 16 位以下的图使用一个调色板来表示选择具体的颜色，调色板的每个单元是 4 个字节，其中一个透明度；而具体的像素值存储的是索引，分别是 1 、 2 、 4 、 8 位。 16 位以上的图直接使用像素表示颜色。那么如何将彩色图转换为灰度图呢？灰度图中有调色板，首先需要确定调色板的具体颜色取值。我们前面提到了，灰度图的三个分量相等。当转换为 8 位的时候，调色板中有 256 个颜色，每个正好从 0 到 255 个，三个分量都相等。当转换为 4 位的时候，调色板中 16 个颜色，等间隔平分 255 个颜色值，三个分量都相等。当转换为 2 位的时候，调色板中 4 个颜色，等间隔平分 255 个颜色，三个分量相等。当转换为 1 位的时候，调色板中两个颜色，是 0 和 255 ，表示黑和白。将彩色转换为灰度时候，按照公式计算出对应的值，该值实际上是亮度的级别；亮度从 0 到 255 ；由于不同的位有不同的亮度级别，所以 Y 的具体取值如下：Y = Y/ (1&lt;&lt;(8- 转换的位数 ));所以，我们要转化成灰度图，并且存储成一幅可以看到的图像，需要做如下转换：16位以上的图像不带调色板，只需要把图像数据按每个点的位数都转换成相同的灰度值即可16位以下的图像，则需要修改调色板的数值，并且按照每个点所占位数修改灰度值索引即可。 &nbsp; 这个程序实现将彩色图像转换为灰度图像。 彩色转换为灰度使用如下公式： Gray = R * 0.299 + G * 0.587 + B * 0.114 为了提高运算速度，将这个公式转换为整数运算： Gray = (R * 229 + G * 587 + B * 114 + 500) / 1000 为了提高运算速度的方法还有很多，这里作为演示，不再详述。 完整代码如下： ///////////////////////////////////////////////////////// // 程序名称：彩色图片转换为灰阶图片 // 编译环境：Visual C++ 6.0 / 2010，EasyX 20130322(beta) // 作 者：krissi &lt;zh@easyx.cn&gt; // 最后修改：2013-1-19 // #include &lt;graphics.h&gt; #include &lt;conio.h&gt; // 彩色图像转换为灰度图像 void ColorToGray(IMAGE *pimg) { DWORD *p = GetImageBuffer(pimg); COLORREF c; // 逐个像素点读取计算 for(int i = pimg-&gt;getwidth() * pimg-&gt;getheight() - 1; i &gt;= 0; i--) { c = BGR(p[i]); c = (GetRValue(c) * 299 + GetGValue(c) * 587 + GetBValue(c) * 114 + 500) / 1000; p[i] = RGB(c, c, c); // 由于是灰度值，无需再执行 BGR 转换 } } // 主函数 void main() { // 初始化绘图环境 initgraph(640, 480); // 获取图像 IMAGE img; loadimage(&amp;img, _T(\"c:\\\\test.jpg\")); // 显示原始图像 putimage(0, 0, &amp;img); // 按任意键转换为灰度图像 getch(); // 处理图像为灰度 ColorToGray(&amp;img); // 显示处理后的图像 putimage(0, 0, &amp;img); // 关闭绘图环境 getch(); closegraph(); }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"解决Sublime Text 2中文乱码问题","slug":"解决sublime-text-2中文乱码问题","date":"2014-03-22T09:13:13.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/50892/","link":"","permalink":"http://www.voyax.meposts/50892/","excerpt":"","text":"Sublime Text 2目前并不支持GBK编码，当打开GBK编码的文件时，就会遇到中文乱码的问题了……提供两个解决Sublime Text 2中文乱码的方案： 1.将文件转换为UTF-8的。这个比较烦，治标不治本…… 2.安装GBK插件： 首先声明：这一方法前提是sublime text 2的安装路径没有中文字符，且系统路径的%username%中不包含中文字符。否则需要手动添加转换包，这个稍后说明。 （1）. 安装Sublime Package Control: 在Sublime Text 2上用Ctrl+～打开控制台并在里面输入以下代码，Sublime Text 2就会自动安装Package Control. import urllib2,os; pf=’Package Control.sublime-package’; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘http://sublime.wbond.net/&#39;+pf.replace(‘ ‘,’%20’)).read()); print(‘Please restart Sublime Text to finish installation’) （2）.重启Sublime Text 2（3）.然后使用Ctrl+Shift+P打开命令行模式，在里面输入Install Package即可搜索需要 的Package。（4）.选择“ConvertToUTF8”或“GBK Encoding Support” 如果Sublime Text 2被安装在有中文的路径下，或者系统路径的%username%包含中文字符的话，则需要进行手动安装。1. 还是要先安装Sublime Package Control，可以尝试用上面的安装方法，然后检查是否安装成功。检查方法很简单：1）打开Sublime Text 2，选择Preferences菜单，并选择 Browse Packages…2）系统会打开Sublime Text 2的Packages文件夹，回到上一级菜单，然后打开Installed Packages文件夹3）如果该文件夹下有Package Control.sublime-package文件即说明安装成功。2. 否则需要手动安装Sublime Package Control，也很简单：下载Package Control.sublime-package（百度一下）并将下载的文件拷贝到Installed Packages文件夹下。3. 手动安装类型转换包：比如“ConvertToUTF8”或“GBK Encoding Support”随便从网上下一个，拷贝到Sublime Text 2的Packages目录下即可。4. 重启Sublime Text 2。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.voyax.me/categories/学习笔记/"}],"tags":[]},{"title":"樱花开了，北京","slug":"樱花开了，北京","date":"2014-03-21T14:27:57.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/26534/","link":"","permalink":"http://www.voyax.meposts/26534/","excerpt":"","text":"在北京呆了近三年，或许是因为来北京以前几乎没见过雪，春、夏、秋、冬唯有冬天才让我有所察觉。来北京的第一个春天，英语老师跟我们说，四月份即使再忙，也要出去看看，玉渊潭的樱花、植物园的牡丹都是非常值得一看的……很可惜，直到现在我也没有去过；前几天突然发现经常上自习的教学楼下有一棵樱花开花了，花开得稀稀疏疏，与周围的色调极不协调，不禁让人有些感伤；今天路过，发现所有樱花都开了，天气不错，原来北京的春天也还挺不错 &nbsp;","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]},{"title":"关于这个博客","slug":"关于这个博客","date":"2014-03-20T12:42:03.000Z","updated":"2017-06-18T09:30:29.000Z","comments":true,"path":"/posts/7174/","link":"","permalink":"http://www.voyax.meposts/7174/","excerpt":"","text":"Time To Fly这是我个人的第三个网站，前两个因为诸多原因都无奈地选择了关闭，希望这个网站可以坚持下去。出于两个原因，我搭建了这个博客，一是希望好好学习php以及SEO,而这些实战无疑是 最有效的手段，同时也方便随时记录学习中遇到的一些难题；二是作为学习和生活的记录，大三上开始慢慢有了写日记的习惯，无论是欣喜还是悲伤，经年之后，当自己回忆起这点点滴滴，又该是怎样的感受。这学期刚来到学校便发现笔记本丢了，谈不上有太多的气愤与心痛，但我想那些大喜大悲之时记下的东西，还是应当好好保存的吧…… 这个博客仅仅是个人随性而为，没有规则，没有限制，不针对某人，亦不愿针对某事，若是有冒犯读者的地方，还望谅解。没有人可以强迫改变他人的意愿，有时我们难以接受的东西，或许只是因为我们还没有欣赏它的能力；还有一点，我们没有权利去改变他人的价值观，也不能随意拿着所谓的道德横扫一切。我所想所写也绝不会刻意讨好某人或有意无脑地要跟上大众，这个网站也并未想过通过某些方式赚取少量收入，所以对于流量或排名我并没有太大兴趣。废了这么大劲，其实就两个字——自由。 最后，就是期望了。马上大学毕业，我们该何去何从……都是满了二十的人了，是该好好拼一拼了，高三很苦吗，大学很苦吗？都是屁话，少点自怜情绪，看看那些每天穿梭于图书管的人，看看那些四五点就起床学习的人，你以为你很努力了？别人是在拼命，你拿什么和人比；既然选择了，就要努力做到最好，不要后悔……还想说什么，忘了……最后的最后也学着别人文艺一把，虽然下面这段是很久很久以前从哪抄来的… “再见，自以为是的青春，再见，想象中的美好，当现实赤裸裸的告诉你必须去面对的时候，除了微笑，只能微笑。让自己慢慢坚不可摧。天再高 ，又怎样，踮起脚尖，就离阳光更近。路太远，只要继续走，总会抵达梦想！” 对于各位的来访，我倍感荣幸","categories":[{"name":"365","slug":"365","permalink":"http://www.voyax.me/categories/365/"}],"tags":[]}]}