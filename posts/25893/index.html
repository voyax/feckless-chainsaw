<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="像孩子一样写代码"><meta name="keywords" content="CSS, JavaScript, NodeJS, Vue, React, Sketch, Git"><title>【转】Selenium WebDriver操作说明 - voya</title><link rel="stylesheet" href="/css/jquery.tocify.css"><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="http://oe54phg1r.bkt.clouddn.com/favicon32x32.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="/categories/365/"><span>忆</span></a></li><li><a href="/categories/css-tutorial/"><span>CSS 教程</span></a></li></ul><div class="wrapper wrapper--article" id="wrap"><div id="toc"><div class="toc-text">Table of Content ▾</div></div><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://oe54phg1r.bkt.clouddn.com/blog/2017-09-26-2017-08-16-adam-whitlock-270558-cmp.jpg"><div class="post-title"><h1 class="title">【转】Selenium WebDriver操作说明</h1><ul class="meta"><li><i class="icon icon-author"></i>voya</li><li><i class="icon icon-clock"></i>35 Minutes</li><li><i class="icon icon-calendar"></i>2015年1月19日</li></ul></div></div><div class="article-content" style="max-width:700px"><h2 id="1-打开一个测试浏览器"><a href="#1-打开一个测试浏览器" class="headerlink" title="1.打开一个测试浏览器"></a>1.打开一个测试浏览器</h2><p>对浏览器进行操作首先需要打开一个浏览器，接下来才能对浏览器进行操作。</p>
<p>Java代码</p>
<pre>
import java.io.File;

import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxBinary;
importorg.openqa.selenium.firefox.FirefoxDriver;
importorg.openqa.selenium.ie.InternetExplorerDriver;

public class OpenBrowsers {

         public static void main(String[] args) {
                   //打开默认路径的firefox
                   WebDriver diver = new FirefoxDriver();

                   //打开指定路径的firefox,方法1
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\MozillaFirefox\\firefox.exe");
                   WebDriver dr = new FirefoxDriver();

                   //打开指定路径的firefox,方法2
                   File pathToFirefoxBinary = newFile("D:\\Program Files\\Mozilla Firefox\\firefox.exe"); 
                   FirefoxBinary firefoxbin = newFirefoxBinary(pathToFirefoxBinary); 
                   WebDriver driver1 = newFirefoxDriver(firefoxbin,null);

                   //打开ie
                   WebDriver ie_driver = new InternetExplorerDriver();

                   //打开chrome
                   System.setProperty("webdriver.chrome.driver","D:\\chromedriver.exe");
                   System.setProperty("webdriver.chrome.bin",
                                            "C:\\Documents and Settings\\gongjf\\Local Settings"
                                             +"\\ApplicationData\\Google\\Chrome\\Application\\chrome.exe");

         }

}

</pre>

<h2 id="2-打开一个具体的url"><a href="#2-打开一个具体的url" class="headerlink" title="2.打开一个具体的url"></a>2.打开一个具体的url</h2><p>打开一个浏览器后，我们需要跳转到特定的url下，看下面代码：<br>Java代码</p>
<pre>
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class OpenUrl {
         public static void main(String []args){
                   Stringurl = "http://www.51.com";
                   WebDriverdriver = new FirefoxDriver();

                   //用get方法
                   driver.get(url);

                   //用navigate方法，然后再调用to方法
                   driver.navigate().to(url);
         }
}
</pre>

<h2 id="3-如何关闭浏览器"><a href="#3-如何关闭浏览器" class="headerlink" title="3.如何关闭浏览器"></a>3.如何关闭浏览器</h2><p>测试完成后，需要关闭浏览器</p>
<p>Java代码</p>
<pre>
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class CloseBrowser {
         public static void main(String []args){
                   Stringurl = "http://www.51.com";
                   WebDriverdriver = new FirefoxDriver();

                   driver.get(url);

                   //用quit方法
                   driver.quit();

                   //用close方法       
                   driver.close();
                   }
}
</pre>

<h2 id="4-如何返回当前页面的url和title"><a href="#4-如何返回当前页面的url和title" class="headerlink" title="4.如何返回当前页面的url和title"></a>4.如何返回当前页面的url和title</h2><p>有时候我们需要返回当前页面的url或者title做一些验证性的操作等。代码如下：<br>Java代码</p>
<pre>
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class GetUrlAndTitle {
         public static void main(String []args){
                   Stringurl = "http://www.google.com";
                   WebDriverdriver = new FirefoxDriver();

                   driver.get(url);

                //得到title
                   Stringtitle = driver.getTitle();

                //得到当前页面url
                   StringcurrentUrl = driver.getCurrentUrl();

                //输出title和currenturl
                   System.out.println(title+"\n"+currentUrl);

                   }
}
</pre>

<h2 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5.其他方法"></a>5.其他方法</h2><p>getWindowHandle()    返回当前的浏览器的窗口句柄<br>getWindowHandles()  返回当前的浏览器的所有窗口句柄<br>getPageSource()        返回当前页面的源码</p>
<p>从上面代码可以看出操作浏览器的主要方法都来自org.openqa.selenium.WebDriver这个接口中。看了一下源代码这些方法都是在org.openqa.selenium.remote.RemoteWebDriver这个类中实现的，然后不同浏览的driver类继承RemoteWebDriver。</p>
<h2 id="C-定位页面元素"><a href="#C-定位页面元素" class="headerlink" title="C  定位页面元素"></a>C  定位页面元素</h2><p>selenium-webdriver提供了强大的元素定位方法，支持以下三种方法。<br>单个对象的定位方法<br>多个对象的定位方法<br>层级定位<br>定位单个元素<br>在定位单个元素时,selenium-webdriver提示了如下一些方法对元素进行定位。<br> <pre><br> By.className(className))<br> By.cssSelector(selector)<br> By.id(id)<br> By.linkText(linkText)<br> By.name(name)<br> By.partialLinkText(linkText)<br> By.tagName(name)<br> By.xpath(xpathExpression)<br> </pre><br>注意：selenium-webdriver通过findElement()\findElements()等find方法调用”By”对象来定位 和查询元素。By类只是提供查询的方式进行分类。findElement返回一个元素对象否则抛出异常，findElements返回符合条件的元素 List，如果不存在符合条件的就返回一个空的list。</p>
<h3 id="1-使用className进行定位"><a href="#1-使用className进行定位" class="headerlink" title="1.使用className进行定位"></a>1.使用className进行定位</h3><p>当所定位的元素具有class属性的时候我们可以通过classname来定位该元素。<br>下面的例子定位了51.com首页上class为”username”的li。<br>Java代码</p>
<pre>
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import org.openqa.selenium.By;

public class ByClassName {

   public static void main(String[] args) {
        WebDriver driver = new FirefoxDriver();
       driver.get("http://www.51.com");
        WebElement element =driver.findElement(By.className("username"));
        System.out.println(element.getTagName());

    }
}
</pre>
输出结果：
Java代码

Li

### 2.使用id属性定位

51.com首页的帐号输入框的html代码如下：
Java代码
<pre>
<input id="passport_51_user" type="text" value="" tabindex="1" title="用户名/彩虹号/邮箱" name="passport_51_user">
</pre> 
在下面的例子中用id定位这个输入框，并输出其title,借此也可以验证代码是否工作正常。

Java代码
<pre> 
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class ByUserId {

         /**
          * @param args
          */
         public static void main(String[] args) {
                   //TODO Auto-generated method stub
                   WebDriverdr = new FirefoxDriver();
                   dr.get("http://www.51.com");

                   WebElementelement = dr.findElement(By.id("passport_51_user"));
                   System.out.println(element.getAttribute("title"));
         }

}
</pre>
输出结果：
 Java代码

用户名/彩虹号/邮箱

### 3.使用name属性定位

51.com首页的帐号输入框的html代码如下：

Java代码
<pre>
<input id="passport_51_user" type="text" value="" tabindex="1" title="用户名/彩虹号/邮箱" name="passport_51_user">
</pre> 
使用name定位

Java代码
 <pre>
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class ByUserId {

         /**
          * @param args
          */
         public static void main(String[] args) {
                   //TODO Auto-generated method stub
                   WebDriverdr = new FirefoxDriver();
                   dr.get("http://www.51.com");

         WebElemente = dr.findElement(By.name("passport_51_user"));                                      System.out.println(element.getAttribute("title"));
         }

}
</pre> 
输出结果：
 Java代码

用户名/彩虹号/邮箱

### 4.使用css属性定位

51.com首页的帐号输入框的html代码如下：
Java代码
<pre> 
<input id="passport_51_user" type="text" value="" tabindex="1" title="用户名/彩虹号/邮箱" name="passport_51_user">
</pre>
使用css定位
Java代码

WebElement e1 =dr.findElement(By.cssSelector("#passport_51_user"));

### 5.使用 XPATH定位

51.com首页的帐号输入框的html代码如下：
Java代码
<pre> 
<input id="passport_51_user" type="text" value="" tabindex="1" title="用户名/彩虹号/邮箱" name="passport_51_user">
</pre>
通过xpath查找：
Java代码

WebElement element=driver.findElement(By.xpath("//input[@id=' passport_51_user ']"));

### 6.使用其他方式定位

在定位link元素的时候，可以使用link和link_text属性；
另外还可以使用tag_name属性定位任意元素；

### 7.定位多个元素

上面提到findElements()方法可以返回一个符合条件的元素List组。看下面例子。
Java代码
<pre>
import java.io.File;
import java.util.List;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxBinary;
import org.openqa.selenium.firefox.FirefoxDriver;

public class FindElementsStudy {

         /**
          * @author gongjf
          */
         public static void main(String[] args) {
                   WebDriver  driver = new FirefoxDriver();
                   driver.get("http://www.51.com");

                   //定位到所有<input>标签的元素，然后输出他们的id
                   List<webelement>element = driver.findElements(By.tagName("input"));
                   for(WebElement e : element){
                            System.out.println(e.getAttribute("id"));
                   }

                   driver.quit();
         }
}
</webelement></pre> 
输出结果：
Java代码

passport_cookie_login
gourl
passport_login_from
passport_51_user
passport_51_password
passport_qq_login_2
btn_reg
passport_51_ishidden
passport_auto_login

上面的代码返回页面上所有input对象

### 8.层级定位

层级定位的思想是先定位父元素，然后再从父元素中精确定位出其我们需要选取的子元素。
层级定位一般的应用场景是无法直接定位到需要选取的元素，但是其父元素比较容易定位，通过定位父元素再遍历其子元素选择需要的目标元素，或者需要定位某个元素下所有的子元素。
下面的代码演示了如何使用层级定位class为"login"的div，然后再取得它下面的所有label，并打印出他们的文本
Java代码
<pre> 
import java.io.File;
importjava.util.List;
importorg.openqa.selenium.By;
importorg.openqa.selenium.WebDriver;
importorg.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxBinary;
importorg.openqa.selenium.firefox.FirefoxDriver;
publicclass LayerLocator {

         /**
          * @author gongjf
          */
         public static void main(String[] args){

                   WebDriver  driver = new FirefoxDriver();
                   driver.get("http://www.51.com");

                   //定位class为"login"的div，然后再取得它下面的所有label，并打印出他们的值
                   WebElement element =driver.findElement(By.className("login"));
                    List<webelement> el =element.findElements(By.tagName("label"));
                    for(WebElement e : el)
                   System.out.println(e.getText());

         }       
}
</webelement></pre>
输出结果：
Java代码

帐号：
密码：
隐身

## >如何对页面元素进行操作

找到页面元素后，怎样对页面进行操作呢？我们可以根据不同的类型的元素来进行一一说明。

### 1\. 输入框（text field or textarea）

 找到输入框元素：
WebElement element =driver.findElement(By.id("passwd-id"));
在输入框中输入内容：
element.sendKeys(“test”);
将输入框清空：
element.clear();
获取输入框的文本内容：
element.getText();

### 2\. 下拉选择框(Select)

找到下拉选择框的元素：
Select select = newSelect(driver.findElement(By.id("select")));

选择对应的选择项：
select.selectByVisibleText(“mediaAgencyA”);
或
select.selectByValue(“MA_ID_001”);

不选择对应的选择项：
select.deselectAll();
select.deselectByValue(“MA_ID_001”);
select.deselectByVisibleText(“mediaAgencyA”);
或者获取选择项的值：
select.getAllSelectedOptions();
select.getFirstSelectedOption();

对下拉框进行操作时首先要定位到这个下拉框，new 一个Selcet对象，然后对它进行操作 

### 3\. 单选项(Radio Button)

找到单选框元素：
WebElement bookMode =driver.findElement(By.id("BookMode"));
选择某个单选项：
bookMode.click();
清空某个单选项：
bookMode.clear();
判断某个单选项是否已经被选择：
bookMode.isSelected();

### 4\. 多选项(checkbox)

多选项的操作和单选的差不多：
WebElement checkbox=driver.findElement(By.id("myCheckbox."));
checkbox.click();
checkbox.clear();
checkbox.isSelected();
checkbox.isEnabled();

### 5\. 按钮(button)

找到按钮元素：
WebElement saveButton =driver.findElement(By.id("save"));
点击按钮：
saveButton.click();
判断按钮是否enable:

saveButton.isEnabled ();

### 6\. 左右选择框

也就是左边是可供选择项，选择后移动到右边的框中，反之亦然。例如：
Select lang = new Select(driver.findElement(By.id("languages")));
lang.selectByVisibleText(“English”);
WebElement addLanguage=driver.findElement(By.id("addButton"));
addLanguage.click();

### 7\. 弹出对话框(Popup dialogs)

Alert alert = driver.switchTo().alert();
alert.accept();
alert.dismiss();
alert.getText();

后面有具体的例子解释~

### 8\. 表单(Form)

Form中的元素的操作和其它的元素操作一样，对元素操作完成后对表单的提交可以：
WebElement approve =driver.findElement(By.id("approve"));
approve.click();
或
approve.submit();//只适合于表单的提交

### 9\. 上传文件 (Upload File)

上传文件的元素操作：
WebElement adFileUpload = driver.findElement(By.id("WAP-upload"));
String filePath ="C:\test\\uploadfile\\media_ads\\test.jpg";
adFileUpload.sendKeys(filePath);

### 10.拖拉(Drag andDrop)

WebElement element=driver.findElement(By.name("source"));
WebElement target = driver.findElement(By.name("target"));

(new Actions(driver)).dragAndDrop(element,target).perform();

### 11.导航 (Navigationand History)

打开一个新的页面：
 driver.navigate().to("http://www.example.com");

通过历史导航返回原页面：
<pre>
driver.navigate().forward();
driver.navigate().back();
</pre>                                                                                                                                           

<h2 id="E-iframe的处理"><a href="#E-iframe的处理" class="headerlink" title="E  iframe的处理"></a>E  iframe的处理</h2><p>有时候我们在定位一个页面元素的时候发现一直定位不了，反复检查自己写的定位器没有任何问题，代码也没有任何问题。这时你就要看一下这个页面元素是否在一个iframe中，这可能就是找不到的原因之一。如果你在一个default content中查找一个在iframe中的元素，那肯定是找不到的。反之你在一个iframe中查找另一个iframe元素或default content中的元素，那必然也定位不到。<br>selenium webdriver中提供了进入一个iframe的方法：</p>
<pre>
WebDriverorg.openqa.selenium.WebDriver.TargetLocator.frame(String nameOrId)
</pre>
也提供了一个返回default content的方法：
<pre>
WebDriver org.openqa.selenium.WebDriver.TargetLocator.defaultContent()
</pre>
这样使我们面对iframe时可以轻松应对。
以下面的html代码为例，我们看一下处现iframe。

Html代码
<pre> 
main.html

<html>
   <head>
       <title>FrameTest</title>
   </head>
   <body>
         <divid =="" "id1"="">this is a div!
       <iframe id="frame" frameborder="0" scrolling="no" style="left:0;position:absolute;" src="frame.html"></iframe>
   </divid></body>
</html>
</pre>

<p>frame.html</p>
<pre> 
<html>
   <head>
       <title>this is a frame!</title>
   </head>
   <body>
         <divid =="" "div1"="">this is a div，too!
         <label>input:</label>
         <inputid =="" "input1"="">
   </inputid></divid></body>
</html>
</pre> 

<p>Java代码</p>
<pre> 
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class FameStudy {

         public static void main(String[] args) {
                   WebDriverdr = new FirefoxDriver();
                   Stringurl = "\\Your\\Path\\to\\main.html";
                   dr.get(url);

                   //在defaultcontent定位id="id1"的div
                   dr.findElement(By.id("id1"));

                   //此时，没有进入到id="frame"的frame中时，以下两句会报错
                   dr.findElement(By.id("div1"));//报错
                   dr.findElement(By.id("input1"));//报错

                   //进入id="frame"的frame中，定位id="div1"的div和id="input1"的输入框。
                   dr.switchTo().frame("frame");        
                   dr.findElement(By.id("div1"));
                   dr.findElement(By.id("input1"));

                   //此时，没有跳出frame，如果定位defaultcontent中的元素也会报错。
                   dr.findElement(By.id("id1"));//报错

                   //跳出frame,进入defaultcontent;重新定位id="id1"的div
                   dr.switchTo().defaultContent();
                   dr.findElement(By.id("id1"));
         }

}
</pre> 

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>switch_to方法会new1个TargetLocator对象，使用该对象的frame方法可以将当前识别的”主体”移动到需要定位的frame上去。 </p>
<h2 id="F-如何得到弹出窗口"><a href="#F-如何得到弹出窗口" class="headerlink" title="F 如何得到弹出窗口"></a>F 如何得到弹出窗口</h2><p>在selenium 1.X里面得到弹出窗口是一件比较麻烦的事，特别是新开窗口没有id、name的时候。在selenium webdriver中得到新开窗口相对简单的多，它无关新开窗口的id、name等属性。以下面的html为例：</p>
<p>Html代码</p>
<pre> 
<span style="white-space: normal;background-color: #ffffff;">test.html</span>

<html>

   <head><title>Test Popup Window</title></head>

   <body>

       [Let's go!](http://www.51.com/)

   </body>

</html>
</pre> 

<p>下面的代码演示了如何去得到弹出的新窗口</p>
<p>Java代码</p>
<pre> 
import java.util.Iterator;
import java.util.Set;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class PopupWindowTest {

         /**
          * @author gongjf
          */
         public static void main(String[] args) {
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();
                   Stringurl ="\\Your\\Path\\to\\main.html";
                   dr.get(url);       
                   dr.findElement(By.id("51")).click();
                   //得到当前窗口的句柄
                   StringcurrentWindow = dr.getWindowHandle();
                   //得到所有窗口的句柄
                   Set<string>handles = dr.getWindowHandles();
                   Iterator</string><string>it = handles.iterator();
                   while(it.hasNext()){
                            if(currentWindow== it.next())  continue;
                            dr.switchTo().window(it.next());

                   }
         }

}
</string>
</pre> 

<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>捕获或者说定位弹出窗口的关键在于获得弹出窗口的句柄。（<br>在上面的代码里，使用windowhandle方法来获取当前浏览器窗口的句柄，使用了windowhandles方法获取所有弹出的浏览器窗口的句柄，然后通过排除当前句柄的方法来得到新开窗口的句柄。<br>在获取新弹出窗口的句柄后，使用switchto.window(newwindow_handle)方法，将新窗口的句柄作为参数传入既可捕获到新窗口了。<br>如果想回到以前的窗口定位元素，那么再调用1次switchto.window方法，传入之前窗口的句柄既可达到目的。</p>
<h2 id="G-如何处理alert、confirm、prompt对话框"><a href="#G-如何处理alert、confirm、prompt对话框" class="headerlink" title="G  如何处理alert、confirm、prompt对话框"></a>G  如何处理alert、confirm、prompt对话框</h2><p>alert、confirm、prompt这样的js对话框在selenium1.X时代也是难啃的骨头，常常要用autoit来帮助处理。<br>试用了一下selenium webdriver中处理这些对话框十分方便简洁</p>
<p>Html代码</p>
<p>Dialogs.html  </p>
<pre> 
<html>

   <head>

       <title>Alert</title>

   </head>

   <body>

       <input id="alert" value="alert" type="button" onclick="alert('欢迎！请按确认继续！');">
        <input id="confirm" value="confirm" type="button" onclick="confirm('确定吗？');">
         <inputid =="" "prompt"="" value="prompt" type="button" onclick="var name = prompt('请输入你的名字:','请输入

你的名字'); document.write(name) "></inputid>

   </body>

</html>
</pre> 

<p> 以上html代码在页面上显示了三个按钮，点击他们分别弹出alert、confirm、prompt对话框。如果在prompt对话框中输入文字点击确定之后，将会刷新页面，显示出这些文字。</p>
<p>selenium webdriver 处理这些弹层的代码如下：</p>
<p>Java代码</p>
<pre> 
import org.openqa.selenium.Alert;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class DialogsStudy {

         /**
          * @author gongjf
          */
         public static void main(String[] args) {
                   //TODO Auto-generated method stub
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();
                   Stringurl = "file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Dialogs.html";//"/Your/Path/to/main.html"
                   dr.get(url);

                   //点击第一个按钮，输出对话框上面的文字，然后叉掉
                   dr.findElement(By.id("alert")).click();
                   Alertalert = dr.switchTo().alert();
                   Stringtext = alert.getText();
                   System.out.println(text);
                   alert.dismiss();

                   //点击第二个按钮，输出对话框上面的文字，然后点击确认
                   dr.findElement(By.id("confirm")).click();
                   Alertconfirm = dr.switchTo().alert();
                   Stringtext1 = confirm.getText();
                   System.out.println(text1);
                   confirm.accept();

                   //点击第三个按钮，输入你的名字，然后点击确认，最后
                   dr.findElement(By.id("prompt")).click();
                   Alertprompt = dr.switchTo().alert();
                   Stringtext2 = prompt.getText();
                   System.out.println(text2);
                   prompt.sendKeys("jarvi");
                   prompt.accept();

         }

}

</pre> 

<h3 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h3><p>从以上代码可以看出dr.switchTo().alert();这句可以得到alert\confirm\prompt对话框的对象，然后运用其方法对它进行操作。对话框操作的主要方法有：</p>
<p>getText()    得到它的文本值<br>accept()      相当于点击它的”确认”<br>dismiss()     相当于点击”取消”或者叉掉对话框<br>sendKeys() 输入值，这个alert\confirm没有对话框就不能用了，不然会报错。</p>
<h2 id="H-如何操作cookies"><a href="#H-如何操作cookies" class="headerlink" title="H  如何操作cookies"></a>H  如何操作cookies</h2><p>Web 测试中我们经常会接触到Cookies，一个Cookies主要属性有”所在域、name、value、有效日期和路径”,下面来讲一下怎么操作Cookies</p>
<p>Java代码</p>
<pre> 
import java.util.Set;

import org.openqa.selenium.Cookie;
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;

public class CookiesStudy {

         /**
          * @author gongjf
          */
         publicstatic void main(String[] args) {
                   //TODO Auto-generated method stub
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();
                   dr.get("http://www.51.com");

                   //增加一个name ="name",value="value"的cookie
                   Cookiecookie = new Cookie("name", "value");
                   dr.manage().addCookie(cookie);

                   //得到当前页面下所有的cookies，并且输出它们的所在域、name、value、有效日期和路径
                   Set<cookie>cookies = dr.manage().getCookies();
                   System.out.println(String.format("Domain-> name -> value -> expiry -> path"));
                   for(Cookiec : cookies)
                            System.out.println(String.format("%s-> %s -> %s -> %s -> %s",
                                               c.getDomain(),c.getName(), c.getValue(),c.getExpiry(),c.getPath()));

                   //删除cookie有三种方法

                   //第一种通过cookie的name
                   dr.manage().deleteCookieNamed("CookieName");
                   //第二种通过Cookie对象
                   dr.manage().deleteCookie(cookie);
                   //第三种全部删除
                   dr.manage().deleteAllCookies();
         }
 </cookie></pre>

<h3 id="小结：-3"><a href="#小结：-3" class="headerlink" title="小结："></a>小结：</h3><p>上面的代码首先在页面中增加了一个cookie,然后遍历页面的所有cookies，并输出他们的主要属性。最后就是三种删除cookie的方法。</p>
<h2 id="I-如何等待页面元素加载完成"><a href="#I-如何等待页面元素加载完成" class="headerlink" title="I  如何等待页面元素加载完成"></a>I  如何等待页面元素加载完成</h2><p>web的自动化测试中，我们经常会遇到这样一种情况：当我们的程序执行时需要页面某个元素，而此时这个元素还未加载完成，这时我们的程序就会报错。怎么办？等待。等待元素出现后再进行对这个元素的操作。<br>在selenium-webdriver中我们用两种方式进行等待：明确的等待和隐性的等待。</p>
<p>明确的等待</p>
<p>明确的等待是指在代码进行下一步操作之前等待某一个条件的发生。最不好的情况是使用Thread.sleep()去设置一段确认的时间去等待。但为什么说最不好呢？因为一个元素的加载时间有长有短，你在设置sleep的时间之前要自己把握长短，太短容易超时，太长浪费时间。selenium webdriver提供了一些方法帮助我们等待正好需要等待的时间。利用WebDriverWait类和ExpectedCondition接口就能实现这一点。</p>
<p>下面的html代码实现了这样的一种效果：点击click按钮5秒钟后，页面上会出现一个红色的div块。我们需要写一段自动化脚本去捕获这个出现的div，然后高亮之。</p>
<p>Html代码</p>
<p>Wait.html</p>
<pre> 
<html>
   <head>
       <title>Set Timeout</title>
       <style>
           .red_box {background-color: red; width = 20%; height: 100px; border:none;}
       </style>
       <script>
           function show_div(){
               setTimeout("create_div()", 5000);
           }

           function create_div(){
                d =document.createElement('div');
                d.className ="red_box";
                document.body.appendChild(d);
           }
       </script>
   </head>
   <body>
       <button id="b" onclick="show_div()">click</button>
   </body>
</html>
</pre> 

<p>下面的代码实现了高亮动态生成的div块的功能：</p>
<p>Java代码</p>
<pre> 
import org.openqa.selenium.By;
importorg.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxDriver;
importorg.openqa.selenium.support.ui.ExpectedCondition;
importorg.openqa.selenium.support.ui.WebDriverWait;

public class WaitForSomthing {

         /**
          * @author gongjf
          */
         public static void main(String[] args) {
                   //TODO Auto-generated method stub
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();
                   Stringurl = "file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Wait.html";//"/Your/Path/to/Wait.html"
                   dr.get(url);
                   WebDriverWaitwait = new WebDriverWait(dr,10);
                   wait.until(newExpectedCondition<webelement>(){
                            @Override
                            publicWebElement apply(WebDriver d) {
                                     returnd.findElement(By.id("b"));
                            }}).click();

                   WebElementelement = dr.findElement(By.cssSelector(".red_box"));
                   ((JavascriptExecutor)dr).executeScript("arguments[0].style.border= \"5px solid yellow\"",element); 

         }
}
</webelement></pre> 

<p>上面的代码WebDriverWait类的构造方法接受了一个WebDriver对象和一个等待最长时间（10秒）。然后调用until方法，其中重写了 ExpectedCondition接口中的apply方法，让其返回一个WebElement,即加载完成的元素，然后点击。默认情况下，WebDriverWait每500毫秒调用一次ExpectedCondition，直到有成功的返回，当然如果超过设定的值还没有成功的返回，将抛出异常。</p>
<h2 id="隐性等待"><a href="#隐性等待" class="headerlink" title="隐性等待"></a>隐性等待</h2><p>隐性等待是指当要查找元素，而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。上面的代码就变成了这样：</p>
<p>Java代码</p>
<pre> 

import java.util.concurrent.TimeUnit;
import org.openqa.selenium.By;
importorg.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.firefox.FirefoxDriver;
importorg.openqa.selenium.support.ui.ExpectedCondition;
importorg.openqa.selenium.support.ui.WebDriverWait;

public class WaitForSomthing {

         /**
          * @author gongjf
          */
         public static void main(String[] args) {
                   //TODO Auto-generated method stub
                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();

                   //设置10秒
                   dr.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);

                   Stringurl = "file:///C:/Documents and Settings/gongjf/桌面/selenium_test/Wait.html";//"/Your/Path/to/Wait.html"
                   dr.get(url);
                 //注释掉原来的
                   /*WebDriverWaitwait = new WebDriverWait(dr,10);
                   wait.until(newExpectedCondition<webelement>(){
                            @Override
                            publicWebElement apply(WebDriver d) {
                                     returnd.findElement(By.id("b"));
                            }}).click();*/
                   dr.findElement(By.id("b")).click();
                   WebElementelement = dr.findElement(By.cssSelector(".red_box"));
                   ((JavascriptExecutor)dr).executeScript("arguments[0].style.border= \"5px solid yellow\"",element); 

         }
}

</webelement>
</pre> 
小结：

两种方法任选其一

## J  如何利用selenium-webdriver截图

在自动化测试中常常会用到截图功能。可以截取页面全图，不管页面有多长。

下面的代码演示了如何使用webdriver进行截图：

Java代码

<pre>
import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
importorg.openqa.selenium.firefox.FirefoxDriver;
public class ShotScreen {

         /**
          * @author gongjf
          * @throws IOException
          * @throws InterruptedException
          */
         public static void main(String[] args) throws IOException, InterruptedException {

                   System.setProperty("webdriver.firefox.bin","D:\\ProgramFiles\\Mozilla Firefox\\firefox.exe"); 
                   WebDriverdr = new FirefoxDriver();
                   dr.get("http://www.51.com");

                   //这里等待页面加载完成
                   Thread.sleep(5000);
                   //下面代码是得到截图并保存在D盘下
                   FilescreenShotFile = ((TakesScreenshot)dr).getScreenshotAs(OutputType.FILE);
                   FileUtils.copyFile(screenShotFile,new File("D:/test.png"));
}
}
</pre> 

<h2 id="K-封装与重用"><a href="#K-封装与重用" class="headerlink" title="K  封装与重用"></a>K  封装与重用</h2><p>WebDriver对页面的操作，需要找到一个WebElement，然后再对其进行操作，比较繁琐：</p>
<pre>
 // Find the text inputelement by itsname
WebElement element =driver.findElement(By.name("q"));

// Enter something to search for
element.sendKeys("Cheese!");
</pre>
我们可以考虑对这些基本的操作进行一个封装，简化操作。比如，封装代码：
<pre>
    protected void sendKeys(Byby, String value){
       driver.findElement(by).sendKeys(value);
    }
</pre>
那么，在测试用例可以这样简化调用：
<pre>
sendKeys(By.name("q"),”Cheese!”);
 </pre>
看，这就简洁多了。

类似的封装还有：
<pre>
package com.drutt.mm.end2end.actions;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.concurrent.TimeUnit;

import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
importorg.openqa.selenium.remote.RemoteWebDriver;
importorg.openqa.selenium.support.ui.WebDriverWait;

importcom.drutt.mm.end2end.data.TestConstant;

public class WebDriverAction {

   //protected WebDriverdriver;
   protectedRemoteWebDriverdriver;
   protectedWebDriverWaitdriverWait;

    protected boolean isWebElementExist(Byselector) {
       try {
           driver.findElement(selector);
           return true;
       } catch(NoSuchElementException e) {
           return false;
       }
    }

    protected String getWebText(By by) {
       try {
       return driver.findElement(by).getText();
       } catch (NoSuchElementException e) {
           return "Textnot existed!";
       }
    }

    protected void clickElementContainingText(By by, String text){
       List<webelement>elementList = driver.findElements(by);
       for(WebElement e:elementList){
           if(e.getText().contains(text)){
               e.click();
               break;
           }
       }    
    }

    protected String getLinkUrlContainingText(By by, String text){
       List</webelement><webelement>subscribeButton = driver.findElements(by);
       String url = null;
       for(WebElement e:subscribeButton){
           if(e.getText().contains(text)){
               url =e.getAttribute("href");
               break;
           }
       }
       return url;
    }

    protected void click(Byby){
       driver.findElement(by).click();
       driver.manage().timeouts().implicitlyWait(TestConstant.WAIT_ELEMENT_TO_LOAD,TimeUnit.SECONDS);
    }

    protected String getLinkUrl(By by){
       return driver.findElement(by).getAttribute("href");
    }

    protected void sendKeys(Byby, String value){
       driver.findElement(by).sendKeys(value);
    }
</webelement>
</pre> 

<h3 id="小结：-4"><a href="#小结：-4" class="headerlink" title="小结："></a>小结：</h3><p>按照上面的例子你可以对各个方法进行封装，使自己的代码更加简洁！</p>
<h2 id="L-在selenium2-0中使用selenium1-0的API"><a href="#L-在selenium2-0中使用selenium1-0的API" class="headerlink" title="L  在selenium2.0中使用selenium1.0的API"></a>L  在selenium2.0中使用selenium1.0的API</h2><p>Selenium2.0中使用WeDriver API对页面进行操作，它最大的优点是不需要安装一个selenium server就可以运行，但是对页面进行操作不如selenium1.0的Selenium RC API那么方便。Selenium2.0提供了使用Selenium RC API的方法：<br>// 我用火狐浏览器作为例子</p>
<pre>
WebDriver driver = newFirefoxDriver(); 
 String baseUrl="http://www.google.com"; 
Selenium selenium = newWebDriverBackedSelenium(driver, baseUrl);

// 执行selenium命令
selenium.open("http://www.google.com");
selenium.type("name=q","cheese");
selenium.click("name=btnG");

WebDriver driverInstance = ((WebDriverBackedSelenium)selenium).getUnderlyingWebDriver();

selenium.stop();
</pre>
我分别使用WebDriver API和SeleniumRC API写了一个Login的脚本，很明显，后者的操作更加简单明了。
WebDriver API写的Login脚本：
<pre>
    public void login() {
       driver.switchTo().defaultContent();
       driver.switchTo().frame("mainFrame");

       WebElement eUsername= waitFindElement(By.id("username"));
       eUsername.sendKeys(manager@ericsson.com);

       WebElement ePassword= waitFindElement(By.id("password"));
       ePassword.sendKeys(manager);

       WebElementeLoginButton = waitFindElement(By.id("loginButton"));
       eLoginButton.click();

    }
</pre>

<p>SeleniumRC API写的Login脚本：</p>
<pre>
    public void login() {
       selenium.selectFrame("relative=top");
       selenium.selectFrame("mainFrame");
       selenium.type("username","manager@ericsson.com");
       selenium.type("password","manager");
       selenium.click("loginButton");
}
</pre>
</div><div class="article-meta" style="max-width:700px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/webdriver/">webdriver</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">45</span></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/posts/2636/"><i class="icon icon-arror-left"></i></a></li><li><a href="/posts/61148/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="bottom"><div class="copyright">© 2017 voya<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></div></div></div></div><script src="https://cdn.staticfile.org/jquery/1.8.3/jquery.min.js"></script><script src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script src="/js/jquery-ui-1.9.1.custom.min.js"></script><script src="/js/jquery.tocify.min.js"></script><script>$(function(){
  var wrap = document.getElementById("wrap");
  wrap.className += " done";
  if (document.querySelector("#toc")) {
    $("#toc").tocify({
      context: "body",
      selectors: "h2,h3,h4,h5",
      extendPage: false,
    }).data("toc-tocify");
    const b = document.querySelector("#toc");

    function a() {
      b.classList.toggle("show")
    }

    document.querySelector(".toc-text").addEventListener("mouseenter", a);
    if (document.querySelector(".tocify-header")) {
      b.style.display = "block"
    }
  }
  $(".post-list img, .article-content img").lazyload({
    placeholder:"http://oe54phg1r.bkt.clouddn.com/typing-preloader.svg",
    effect:"fadeIn",
    load : function(elements_left, settings) {
      $(this).removeClass("img-loading");
    }
  });
});</script></body></html>