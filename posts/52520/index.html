<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>【转】OpenGL基础图形编程 | voya</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL = { 
  root: '/',
  algolia: {"appId":"TJ6WR04MZ3","apiKey":"81961c3645425e892e7caa399f73e5b2","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script><link rel="icon" href="/favicon.ico"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀-数据类型-相应C语言类型-OpenGL类型"><span class="toc-number">1.</span> <span class="toc-text">前缀    数据类型                    相应C语言类型        OpenGL类型</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://oe54phg1r.bkt.clouddn.com/blog/2017-09-26-2017-07-26-075816%20.jpg"></div><div class="author-info__name text-center">voya</div><div class="author-info__description text-center">Reading, Collecting, Thinking and Doing</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="../../archives"><span class="pull-left">文章</span><span class="pull-right">149</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="../../categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://oe54phg1r.bkt.clouddn.com/blog/2017-09-26-2017-08-16-adam-whitlock-270558-cmp.jpg);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">voya</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">【转】OpenGL基础图形编程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2014-04-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"> </i><a class="post-meta__categories" href="../../categories/学习笔记/">学习笔记</a><span class="post-meta__separator">|</span><i class="fa fa-tag post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="../../tags/OPenGL/">OPenGL</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">27,080</span><span class="post-meta__separator">|</span><span>阅读时长: 97 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><p>**一、OpenGL与3D图形世界</p>
<p>1.1、OpenGL使人们进入三维图形世界<strong><br>我们生活在一个充满三维物体的三维世界中，为了使计算机能精确地再现这些物体，我们必须能在三维空间描绘这些物体。我们又生活在一个充满信息的世界中，能否尽快地理解并运用这些信息将直接影响事业的成败，所以我们需要用一种最直接的形式来表示这些信息。<br>最近几年计算机图形学的发展使得三维表现技术得以形成，这些三维表现技术使我们能够再现三维世界中的物体，能够用三维形体来表示复杂的信息，这种技术就是可视化（Visualization）技术。可视化技术使人能够在三维图形世界中直接对具有形体的信息进行操作，和计算机直接交流。这种技术已经把人和机器的力量以一种直觉而自然的方式加以统一，这种革命性的变化无疑将极大地提高人们的工作效率。可视化技术赋予人们一种仿真的、三维的并且具有实时交互的能力，这样人们可以在三维图形世界中用以前不可想象的手段来获取信息或发挥自己创造性的思维。机械工程师可以从二维平面图中得以解放直接进入三维世界，从而很快得到自己设计的三维机械零件模型。医生可以从病人的三维扫描图象分析病人的病灶。军事指挥员可以面对用三维图形技术生成的战场地形，指挥具有真实感的三维飞机、军舰、坦克向目标开进并分析战斗方案的效果。<br>更令人惊奇的是目前正在发展的虚拟现实技术，它能使人们进入一个三维的、多媒体的虚拟世界，人们可以游历远古时代的城堡,也可以遨游浩翰的太空。所有这些都依赖于计算机图形学、计算机可视化技术的发展。人们对计算机可视化技术的研究已经历了一个很长的历程，而且形成了许多可视化工具，其中SGI公司推出的GL三维图形库表现突出，易于使用而且功能强大。利用GL开发出来的三维应用软件颇受许多专业技术人员的喜爱，这些三维应用软件已涉及建筑、产品设计、医学、地球科学、流体力学等领域。随着计算机技术的继续发展，GL已经进一步发展成为OpenGL，OpenGL已被认为是高性能图形和交互式视景处理的标准，目前包括ATT公司UNIX软件实验室、IBM公司、DEC公司、SUN公司、HP公司、Microsoft公司和 SGI公司在内的几家在计算机市场占领导地位的大公司都采用了OpenGL图形标准。<br>值得一提的是，由于Microsoft公司在 Windows NT中提供OpenGL图形标准，OpenGL将在微机中广泛应用，尤其是OpenGL三维图形加速卡和微机图形工作站的推出，人们可以在微机上实现三维图形应用，如CAD设计、仿真模拟、三维游戏等，从而更有机会、更方便地使用OpenGL及其应用软件来建立自己的三维图形世界。<br><a name="1.2"></a>
</strong>1.2、OpenGL提供直观的三维图形开发环境**<br>OpenGL实际上是一种图形与硬件的接口。它包括了120个图形函数，开发者可以用这些函数来建立三维模型和进行三维实时交互。与其他图形程序设计接口不同，OpenGL提供了十分清晰明了的图形函数，因此初学的程序设计员也能利用OpenGL的图形处理能力和1670万种色彩的调色板很快地设计出三维图形以及三维交互软件。<br>OpenGL强有力的图形函数不要求开发者把三维物体模型的数据写成固定的数据格式，这样开发者不但可以直接使用自己的数据，而且可以利用其他不同格式的数据源。这种灵活性极大地节省了开发者的时间，提高了软件开发效益。<br>长期以来，从事三维图形开发的技术人员都不得不在自己的程序中编写矩阵变换、外部设备访问等函数，这样为调制这些与自己的软件开发目标关系并不十分密切的函数费脑筋，而OpenGL正是提供一种直观的编程环境，它提供的一系列函数大大地简化了三维图形程序。例如：</p>
<ul>
<li>OpenGL提供一系列的三维图形单元供开发者调用。</li>
<li>OpenGL提供一系列的图形变换函数。</li>
<li>OpenGL提供一系列的外部设备访问函数，使开发者可以方便地访问鼠标、键盘、空间球、数据手套等这种直观的三维图形开发环境体现了OpenGL的技术优势，这也是许多三维图形开发者热衷于OpenGL的缘由所在。<br><strong>1.3、OpenGL成为目前三维图形开发标准<a name="1.3"></a></strong><br>OpenGL成为目前三维图形开发标准在计算机发展初期，人们就开始从事计算机图形的开发。直到计算机硬软件和计算机图形学高度发达的九十年代，人们发现复杂的数据以视觉的形式表现时是最易理解的，因而三维图形得以迅猛发展，于是各种三维图形工具软件包相继推出，如PHIGS、PEX、 RenderMan等。这些三维图形工具软件包有些侧重于使用方便，有些侧重于渲染效果或与应用软件的连接，但没有一种三维工具软件包在交互式三维图形建模能力、外部设备管理以及编程方便程度上能够OpenGL相比拟。<br>OpenGL经过对GL的进一步发展，实现二维和三维的高级图形技术，在性能上表现得异常优越，它包括建模、变换、光线处理、色彩处理、动画以及更先进的能力，如纹理影射、物体运动模糊等。OpenGL的这些能力为实现逼真的三维渲染效果、建立交互的三维景观提供了优秀的软件工具。OpenGL在硬件、窗口、操作系统方面是相互独立的。<br>许多计算机公司已经把 OpenGL集成到各种窗口和操作系统中，其中操作系统包括UNIX、Windows NT、DOS等，窗口系统有X窗口、Windows等。为了实现一个完整功能的图形处理系统，设计一个与OpenGL相关的系统结构为：其最底层是图形硬件，第二层为操作系统，第三层为窗口系统，第四层为OpenGL，第五层为应用软件。OpenGL是网络透明的，在客户 — 服务器（Client-Server）体系结构中，OpenGL允许本地和远程绘图。所以在网络系统中，OpenGL在X窗口、Windows或其它窗口系统下都可以以一个独立的图形窗口出现。<br>OpenGL作为一个性能优越的图形应用程序设计界面（API）而适合于广泛的计算环境，从个人计算机到工作站和超级计算机，OpenGL都能实现高性能的三维图形功能。由于许多在计算机界具有领导地位的计算机公司纷纷采用OpenGL作为三维图形应用程序设计界面，OpenGL应用程序具有广泛的移植性。因此，OpenGL已成为目前的三维图形开发标准，是从事三维图形开发工作的技术人员所必须掌握的开发工具。</li>
</ul>
<p>二、OpenGL概念建立</p>
<p># </p>
<p><div>&lt;&gt;function StorePage(){d=document;t=d.selection?(d.selection.type!=’None’?d.selection.createRange().text:’’):(d.getSelection?d.getSelection():’’);void(keyit=window.open(‘<a href="http://www.365key.com/storeit.aspx?t=&#39;+escape(d.title)+&#39;&amp;u=&#39;+escape(d.location.href)+&#39;&amp;c=&#39;+escape(t),&#39;keyit&#39;,&#39;scrollbars=no,width=475,height=575,left=75,top=20,status=no,resizable=yes&#39;));keyit.focus(" target="_blank" rel="noopener">http://www.365key.com/storeit.aspx?t=&#39;+escape(d.title)+&#39;&amp;u=&#39;+escape(d.location.href)+&#39;&amp;c=&#39;+escape(t),&#39;keyit&#39;,&#39;scrollbars=no,width=475,height=575,left=75,top=20,status=no,resizable=yes&#39;));keyit.focus(</a>); <strong>2.1、OpenGL基本理解</strong><br>OpenGL是一个与硬件图形发生器的软件接口，它包括了100多个图形操作函数，开发者可以利用这些函数来构造景物模型、进行三维图形交互软件的开发。正如上一章所述，OpenGL是一个高性能的图形开发软件包。OpenGL支持网络，在网络系统中用户可以在不同的图形终端上运行程序显示图形。 OpenGL作为一个与硬件独立的图形接口，它不提供与硬件密切相关的设备操作函数，同时，它也不提供描述类似于飞机、汽车、分子形状等复杂形体的图形操作函数。用户必须从点、线、面等最基本的图形单元开始构造自己的三维模型。当然，象OpenInventor那样更高一级的基于OpenGL的三维图形建模开发软件包将提供方便的工具。因此OpenGL的图形操作函数十分基本、灵活。例如OpenGL中的模型绘制过程就多种多样，内容十分丰富，OpenGL提供了以下的对三维物体的绘制方式：</div></p>
<ul>
<li><strong>网格线绘图方式</strong>（wireframe）<br>这种方式仅绘制三维物体的网格轮廓线。</li>
<li><strong>深度优先网格线绘图方式</strong>（depth_cued）<br>用网格线方式绘图，增加模拟人眼看物体一样，远处的物体比近处的物体要暗些。</li>
<li><strong>反走样网格线绘图方式</strong>（antialiased）<br>用网格线方式绘图，绘图时采用反走样技术以减少图形线条的参差不齐。</li>
<li><strong>平面消隐绘图方式</strong>（flat_shade）<br>对模型的隐藏面进行消隐，对模型的平面单元按光照程度进行着色但不进行光滑处理。</li>
<li><strong>光滑消隐绘图方式</strong>（smooth_shade）<br>对模型进行消隐按光照渲染着色的过程中再进行光滑处理，这种方式更接近于现实。</li>
<li><strong>加阴影和纹理的绘图方式</strong>（shadows、textures）<br>在模型表面贴上纹理甚至于加上光照阴影，使得三维景观象照片一样。</li>
<li><strong>运动模糊的绘图方式</strong>（motion-blured）<br>模拟物体运动时人眼观察所感觉的动感现象。</li>
<li><strong>大气环境效果</strong>（atmosphere-effects）<br>在三维景观中加入如雾等大气环境效果，使人身临其境。</li>
<li><strong>深度域效果</strong>（depth-of-effects）<br>类似于照相机镜头效果，模型在聚焦点处清晰，反之则模糊。<br>这些三维物体绘图和特殊效果处理方式，说明OpenGL已经能够模拟比较复杂的三维物体或自然景观，这就是我们所面对的OpenGL。<br><a name="2.2"></a><br><strong>2.2、OpenGL工作流程</strong><br>整个OpenGL的基本工作流程如下图：<br><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/stfairy/310904/o_%e6%9c%aa%e5%91%bd%e5%90%8d.JPG" alt=""><br>其中几何顶点数据包括模型的顶点集、线集、多边形集，这些数据经过流程图的上部，包括运算器、逐个顶点操作等；图像数据包括象素集、影像集、位图集等，图像象素数据的处理方式与几何顶点数据的处理方式是不同的，但它们都经过光栅化、逐个片元（Fragment）处理直至把最后的光栅数据写入帧缓冲器。在OpenGL中的所有数据包括几何顶点数据和象素数据都可以被存储在显示列表中或者立即可以得到处理。OpenGL中，显示列表技术是一项重要的技术。<br>OpenGL要求把所有的几何图形单元都用顶点来描述，这样运算器和逐个顶点计算操作都可以针对每个顶点进行计算和操作，然后进行光栅化形成图形碎片；对于象素数据，象素操作结果被存储在纹理组装用的内存中，再象几何顶点操作一样光栅化形成图形片元。<br>整个流程操作的最后，图形片元都要进行一系列的逐个片元操作，这样最后的象素值BZ送入帧缓冲器实现图形的显示。<br><a name="2.3"></a><br><strong>2.3、OpenGL图形操作步骤</strong><br>在上一节中说明了OpenGL的基本工作流程，根据这个流程可以归纳出在OpenGL中进行主要的图形操作直至在计算机屏幕上渲染绘制出三维图形景观的基本步骤：<br>1）根据基本图形单元建立景物模型，并且对所建立的模型进行数学描述（OpenGL中把：点、线、多边形、图像和位图都作为基本图形单元）。<br>2）把景物模型放在三维空间中的合适的位置，并且设置视点（viewpoint）以观察所感兴趣的景观。<br>3）计算模型中所有物体的色彩，其中的色彩根据应用要求来确定，同时确定光照条件、纹理粘贴方式等。<br>4）把景物模型的数学描述及其色彩信息转换至计算机屏幕上的象素，这个过程也就是光栅化（rasterization）。<br>在这些步骤的执行过程中，OpenGL可能执行其他的一些操作，例如自动消隐处理等。另外，景物光栅化之后被送入帧缓冲器之前还可以根据需要对象素数据进行操作。</li>
</ul>
<p>三、WindowsNT下的OpenGL</p>
<p><strong>3.1、Windows NT下的OpenGL函数</strong><br>如前面的章节所述，Windows NT下的OpenGL同样包含100多个库函数，这些函数都按一定的格式来命名，即每个函数都以gl开头。Windows NT下的OpenGL除了具有基本的OpenGL函数外，还支持其他四类函数：</p>
<p><table border="1" cellspacing="1" cellpadding="1"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><strong>相应函数</strong></td></p>
<p><td><strong>具体说明</strong></td><br></p>
<p><tr></tr></p>
<p><td>OpenGL实用库</td></p>
<p><td>43个函数，每个函数以glu开头。</td><br></p>
<p><tr></tr></p>
<p><td>OpenGL辅助库</td></p>
<p><td>31个函数，每个函数以aux开头。</td><br></p>
<p><tr></tr></p>
<p><td>Windows专用库函数（WGL）</td></p>
<p><td>6个函数，每个函数以wgl开头。</td><br></p>
<p><tr></tr></p>
<p><td>Win32 API函数</td></p>
<p><td>5个函数，函数前面没有专用前缀。</td><br><br><br><br>在OpenGL中有115个核心函数，这些函数是最基本的，它们可以在任何OpenGL的工作平台上应用。这些函数用于建立各种各样的形体，产生光照效果，进行反走样以及进行纹理映射，进行投影变换等等。由于这些核心函数有许多种形式并能够接受不同类型的参数，实际上这些函数可以派生出300 多个函数。<br>OpenGL的实用函数是比OpenGL核心函数更高一层的函数，这些函数是通过调用核心函数来起作用的。这些函数提供了十分简单的用法，从而减轻了开发者的编程负担。OpenGL的实用函数包括纹理映射、坐标变换、多边形分化、绘制一些如椭球、圆柱、茶壶等简单多边形实体（本指南将详细讲述这些函数的具体用法）等。这部分函数象核心函数一样在任何OpenGL平台都可以应用。<br>OpenGL的辅助库是一些特殊的函数，这些函数本来是用于初学者做简单的练习之用，因此这些函数不能在所有的OpenGL平台上使用，在Windows NT环境下可以使用这些函数。这些函数使用简单，它们可以用于窗口管理、输入输出处理以及绘制一些简单的三维形体。为了使OpenGL的应用程序具有良好的移植性，在使用OpenGL辅助库的时候应谨慎。<br>6个WGL函数是用于连接OpenGL与Windows NT的，这些函数用于在Windows NT环境下的OpenGL窗口能够进行渲染着色，在窗口内绘制位图字体以及把文本放在窗口的某一位置等。这些函数把Windows与OpenGL揉合在一起。最后的5个Win32函数用于处理象素存储格式和双缓冲区，显然这些函数仅仅能够用于Win32系统而不能用于其它OpenGL平台。<br><a name="3.2"></a><br><strong>3.2、OpenGL基本功能</strong><br>OpenGL能够对整个三维模型进行渲染着色，从而绘制出与客观世界十分类似的三维景象。另外OpenGL还可以进行三维交互、动作模拟等。具体的功能主要有以下这些内容。</p>
<ul>
<li><strong>模型绘制</strong><br>OpenGL能够绘制点、线和多边形。应用这些基本的形体，我们可以构造出几乎所有的三维模型。OpenGL通常用模型的多边形的顶点来描述三维模型。如何通过多边形及其顶点来描述三维模型，在指南的在后续章节会有详细的介绍。</li>
<li><strong>模型观察</strong><br>在建立了三维景物模型后，就需要用OpenGL描述如何观察所建立的三维模型。观察三维模型是通过一系列的坐标变换进行的。模型的坐标变换在使观察者能够在视点位置观察与视点相适应的三维模型景观。在整个三维模型的观察过程中，投影变换的类型决定观察三维模型的观察方式，不同的投影变换得到的三维模型的景象也是不同的。最后的视窗变换则对模型的景象进行裁剪缩放，即决定整个三维模型在屏幕上的图象。<br><strong>
</strong></li>
<li><strong>颜色模式的指定</strong><br>OpenGL 应用了一些专门的函数来指定三维模型的颜色。程序员可以选择二个颜色模式，即RGBA模式和颜色表模式。在RGBA模式中，颜色直接由RGB值来指定；在颜色表模式中，颜色值则由颜色表中的一个颜色索引值来指定。程序员还可以选择平面着色和光滑着色二种着色方式对整个三维景观进行着色。</li>
<li><strong>光照应用</strong><br>用OpenGL绘制的三维模型必须加上光照才能更加与客观物体相似。OpenGL提供了管理四种光（辐射光、环境光、镜面光和漫反射光）的方法，另外还可以指定模型表面的反射特性。</li>
<li><strong>图象效果增强</strong><br>OpenGL提供了一系列的增强三维景观的图象效果的函数，这些函数通过反走样、混合和雾化来增强图象的效果。反走样用于改善图象中线段图形的锯齿而更平滑，混合用于处理模型的半透明效果，雾使得影像从视点到远处逐渐褪色，更接近于真实。</li>
<li><strong>位图和图象处理</strong><br>OpenGL还提供了专门对位图和图象进行操作的函数。</li>
<li><strong>纹理映射</strong><br>三维景物因缺少景物的具体细节而显得不够真实，为了更加逼真地表现三维景物，OpenGL提供了纹理映射的功能。OpenGL提供的一系列纹理映射函数使得开发者可以十分方便地把真实图象贴到景物的多边形上，从而可以在视窗内绘制逼真的三维景观。</li>
<li><strong>实时动画</strong><br>为了获得平滑的动画效果，需要先在内存中生成下一幅图象，然后把已经生成的图象从内存拷贝到屏幕上，这就是OpenGL的双缓存技术（double buffer）。OpenGL提供了双缓存技术的一系列函数。</li>
<li><strong>交互技术</strong><br>目前有许多图形应用需要人机交互，OpenGL提供了方便的三维图形人机交互接口，用户可以选择修改三维景观中的物体。<br><strong>3.3、Windows NT下OpenGL的结构</strong><a name="3.3"></a><br>OpenGL的作用机制是客户（client）/服务器（sever）机制，即客户（用OpenGL绘制景物的应用程序）向服务器（即OpenGL内核）发布OpenGL命令，服务器则解释这些命令。大多数情况下，客户和服务器在同一机器上运行。正是OpenGL的这种客户/服务器机制，OpenGL可以十分方便地在网络环境下使用。因此Windows NT下的OpenGL是网络透明的。正象Windows的图形设备接口（GDI）把图形函数库封装在一个动态链接库（Windows NT下的GDI32.DLL）内一样，OpenGL图形库也被封装在一个动态链接库内（OPENGL32.DLL）。受客户应用程序调用的OpenGL函数都先在OPENGL32.DLL中处理，然后传给服务器WINSRV.DLL。OpenGL的命令再次得到处理并且直接传给Win32的设备驱动接口（Device Drive Interface,DDI），这样就把经过处理的图形命令送给视频显示驱动程序。下图简要说明这个过程：<br><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/%E5%9B%BE3-1.JPG" alt=""><br>**图3-1 OpenGL在Windows NT下运行机制</li>
</ul>
<p>**　　在三维图形加速卡的GLINT图形加速芯片的加速支持下，二个附加的驱动程序被加入这个过程中。一个OpenGL可安装客户驱动程序（Installable Client Driver,ICD）被加在客户这一边，一个硬件指定DDI（Hardware-specific DDI）被加在服务器这边，这个驱动程序与Wind32 DDI是同一级别的。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/%E5%9B%BE3-2.JPG" alt=""><br><strong>图3-2 在三维图形加速下OpenGL运行机制</strong><br>四、OpenGL基础程序结构</p>
<p>用OpenGL编写的程序结构类似于用其他语言编写的程序。实际上，OpenGL是一个丰富的三维图形函数库，编写OpenGL程序并非难事，只需在基本C语言中调用这些函数，用法同Turbo C、Microsoft C等类似，但也有许多不同之处。<br>本指南所有的程序都是在Windows NT的Microsoft Visual C++集成环境下编译连接的，其中有部分头文件和函数是为这个环境所用的，例如判别操作系统的头文件“glos.h”。此外，为便于各类读者同时快速入门，在短时间内掌握OpenGL编程的基本方法和技巧，指南中例子尽量采用标准ANSI C调用OpenGL函数来编写，而且所有例程都只采用OpenGL附带的辅助库中的窗口系统。此外，这样也便于程序在各平台间移植，尤其往工作站UNIX 操作系统移植时，也只需改动头文件等很少很少的部分。下面列出一个简单的OpenGL程序：</p>
<p>例4-1 OpenGL简单例程（Simple.c）</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>#include “glos.h”</p>
<p>void main(void)<br>{<br>auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);<br>auxInitPosition(0,0,500,500);<br>auxInitWindow(“simple”);</p>
<p>glClearColor(0.0,0.0,0.0,0.0);<br>glClear(GL_COLOR_BUFFER_BIT);</p>
<p>glColor3f(1.0,0.0,0.0);<br>glRectf(-0.5,-0.5,0.5,0.5);</p>
<p>glFlush();<br>_sleep(1000);<br>}</p>
<p>这个程序运行结果是在屏幕窗口内画一个红色的方块。<br>下面具体分析整个程序结构：首先，在程序最开始处是OpenGL头文件：&lt;GL/gl.h&gt;、&lt;GL/glaux.h&gt;。前一个是gl库的头文件，后一个是辅助库的头文件。此外，在以后的几章中还将说明OpenGL的另外两个头文件，一个是&lt;GL/glu.h&gt;实用库的头文件，另一个是&lt;GL/glx.h&gt;X窗口扩充库的头文件（这个常用在工作站上）。接下来是主函数main()的定义：一般的程序结构是先定义一个窗口：</p>
<p>auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);<br>auxInitPosition(0,0,500,500);<br>auxInitWindow(“simple”);</p>
<p>auxInitDisplayMode(AUX_SINGLE|AUX_RGBA)设置窗口显示模式为RGBA方式，即彩色方式，并且图形缓存为单缓存（SINGLE BUFFER）。 auxInitPosition(0, 0, 500, 500)定义窗口的初始位置，前两个参数(0, 0)为窗口的左上角点的屏幕坐标，后两个参数(500,500)为窗口的宽度和高度。auxInitWindow(“simple”)是窗口初始化，字符参数是窗口名称。<br>然后是窗口内清屏：</p>
<p>glClearColor(0.0,0.0,0.0,0.0); glClear(GL_COLOR_BUFFER_BIT);</p>
<p>第一句将窗口清为黑色，第二句将颜色缓冲区清为glClearColor(0.0, 0.0, 0.0, 0.0)命令所设置的颜色，即同窗口背景颜色一致。<br>再接着是在窗口内画一个物体：</p>
<p>glColor3f(1.0,0.0,0.0);<br>glRectf(-0.5,-0.5,0.5,0.5);</p>
<p>很明显，第一句设置物体颜色，函数中前三个参数分别为R、G、B值，最后一个参数是Alpha值，范围都从0至1；第二句绘制一个二维矩形。注意：OpenGL是针对三维图形而言，因此用作OpenGL编程绘制物体必须意识到任何一个物体都是三维的，具有空间性，而显示于屏幕上的物体都是三维物体在二维平面上的投影。<br>从表面上看，上述程序代码很简单，实际上已经用到了缺省的投影形式（正射投影）。再看glFlush()函数，表示强制绘图完成。最后一句_sleep(1000)，参数单位为毫秒，整句意思是保持现有状况一秒钟，然后结束程序运行。这个函数是VC++的库函数。<br>总而言之，OpenGL程序基本结构为定义窗口、清理窗口、绘制物体、结束运行。</p>
<p>五、OpenGL的数据类型和函数名</p>
<p>OpenGL的数据类型定义可以与其它语言一致，但建议在ANSI C下最好使用以下定义的数据类型，例如GLint、GLfloat等。具体类型见表5-1。</p>
<h1 id="前缀-数据类型-相应C语言类型-OpenGL类型"><a href="#前缀-数据类型-相应C语言类型-OpenGL类型" class="headerlink" title="前缀    数据类型                    相应C语言类型        OpenGL类型"></a>前缀    数据类型                    相应C语言类型        OpenGL类型</h1><p>b       8-bit integer            signed char         GLbyte<br>s       16-bit integer           short               GLshort<br>i       32-bit integer           long                        GLint,GLsizei<br>f       32-bit floating-point    float                       GLfloat,GLclampf<br>d       64-bit floating-point    double                      GLdouble,GLclampd<br>ub      8-bit unsigned integer   unsigned char               GLubyte,GLboolean<br>us      16-bit unsigned integer  unsigned short      GLushort<br>ui      32-bit unsigned integer  unsigned long       GLuint,GLenum,GLbitfield</p>
<p><div>**表5-1 命令前缀和参数数据类型</div></p>
<p>**</p>
<p><div>　　OpenGL的库函数命名方式很有规律，了解这种规律后阅读和编写程序都比较容易方便。<br>首先，每个库函数有前缀gl、glu、glx或aux，表示此函数分属于基本库、实用库、X窗口扩充库或辅助库，其后的函数名头字母大写，后缀是参数类型的简写，取i、f，参见表5-1。例：</div></p>
<p>glVertex2i(2,4);<br>glVertex3f(2.0,4.0,5.0);</p>
<p><strong>注意</strong>：有的函数参数类型后缀前带有数字2、3、4。2代表二维，3代表三维，4代表alpha值（以后介绍）。<br>有些OpenGL函数最后带一个字母v，表示函数参数可用一个指针指向一个向量（或数组）来替代一系列单个参数值。下面两种格式都表示设置当前颜色为红色，二者等价。</p>
<p>glColor3f(1.0,0.0,0.0);<br>float color_array[]={1.0,0.0,0.0};<br>glColor3fv(color_array);</p>
<p>除了以上基本命名方式外，还有一种带“<em>”星号的表示方法，例如glColor</em>()，它表示可以用函数的各种方式来设置当前颜色。同理，glVertex*v()表示用一个指针指向所有类型的向量来定义一系列顶点坐标值。<br>最后，OpenGL也定义GLvoid类型，如果用C语言编写，可以用它替代void类型。<br><br>六、OpenGL辅组库的基本使用</p>
<p>OpenGL是一个开放的系统，它是独立于任何窗口系统或操作系统的。尽管它包含了许多图形函数，但它却没有窗口函数，也没有从键盘和鼠标读取事件的函数，所以要初学者写出一个完整的图形程序是相当困难的。另外，OpenGL图形函数中只提供基本的几何原形：点、线、多边形，因此要创建基本的三维几何体如球、锥体等，也很不容易。而OpenGL辅助库就是为解决这些基本问题专门设计的，它提供了一些基本的窗口管理函数和三维图形绘制函数，能帮助初学者尽快进入OpenGL世界，掌握关键的三维图形技术，体会其中奇妙的乐趣。但是，对于复杂的应用，这些函数远远不够，只能作为参考。<br><a name="6.1"></a><br>6.1、辅助库函数分类<br>这一节内容可以作为手册查阅，初学者不必深究。<br>辅助库函数大致分为六类：</p>
<p>6.1.1 窗口初始化和退出<br>相关函数有三个，它们在第一章已提到，这里将详细介绍：</p>
<p>void auxInitWindow(GLbyte *titleString)</p>
<p>打开一个由auxInitDisplayMode()和auxInitPosition()指定的窗口。函数参数是窗口标题，窗口背景缺省颜色是RGBA下的黑色或颜色表（color_index）下的0号调色板的颜色。按下Escape键可以完成关掉窗口、结束程序、全部清屏三项功能。</p>
<p>void auxInitDisplayMode(GLbitfield mask)</p>
<p>设置窗口显示模式。基本模式有RGBA或颜色表、单或双缓存，也可指定其他附加模式：深度、模板或累积缓存（depth,stencil,and/or accumulation buffer）。参数mask是一组位标志的联合（取或），AUX_RGBA或AUX_INDEX、AUX_SINGLE或AUX_DOUBLE，以及其它有效标志AUX_DEPTH、AUX_STENCIL或AUX_ACCUM。</p>
<p>void auxInitPosition(GLint x,GLint y,GLsizei width,GLsizei height)</p>
<p>设置窗口位置及大小。参数（x, y）为窗口的左上角点的屏幕坐标，参数（width, height）为窗口的宽度和高度，单位为象素，缺省值为（0, 0, 100, 100）。</p>
<p>6.1.2 窗口处理和事件输入<br>当窗口创建后，且在进入主函数循环之前，应当登记以下列出的回调函数（callback function）：</p>
<p>void auxReshapeFunc(void(*function)(GLsizei,GLsizei))</p>
<p>定义窗口改变时形状重定函数。参数function是一个函数指针，这个函数带有两个参数，即窗口改变后的新宽度和新高度。通常，function是 glViewport()，显示裁减后的新尺寸，重定义投影矩阵，以便使投影后图像的比例与视点匹配，避免比例失调。若不调用 auxReshapeFunc()，缺省重定物体形状的函数功能是调用一个二维的正射投影矩阵。运用辅助库，窗口将在每个事件改变后自动重新绘制。</p>
<p>void auxKeyFunction(GLint key,void(*function)(void))</p>
<p>定义键盘响应函数。参数function就是当按下key键时所调用的函数指针，辅助库为参数key定义了几个常量：AUX_0至AUX_9、 AUX_A至AUX_Z、AUX_a至AUX_z、AUX_LEFT、AUX_RIGHT、AUX_UP、AUX_DOWN（方向键）、 AUX_ESCAPE、AUX_SPACE或AUX_RETURN。</p>
<p>void auxMouseFunc(GLint button,Glint mode,void(<em>function)(AUX_EVENTREC </em>))</p>
<p>定义鼠标响应函数。参数function就是当鼠标以mode方式作用于button时所调用的函数。参数button有 AUX_LEFTBUTTON、AUX_MIDDLEBUTTON或AUX_RIGHTBUTTON（以右手为标准）。参数mode代表鼠标触击状态，击中时为AUX_MOUSEDOWN，释放时为AUX_MOUSEUP。参数function必须带一个参数，它是指向结构AUX_EVENNTREC的指针。当函数auxMouseFunc()被调用时将为这个结构分配相应的内存。通常用法类似如下：</p>
<p>void function(AUX_EVENTREC *event)<br>{<br>GLint x,y;<br>x=event-&gt;data[AUX_MOUSEX];<br>y=event-&gt;data[AUX_MOUSEY];<br>…<br>}</p>
<p>6.1.3 颜色表装入<br>因为OpenGL本身没有窗口系统，所以依赖于窗口系统的颜色映射就没法装入颜色查找表。如果采用颜色表模式，就要用到辅助库提供的用RGB值定义的单个颜色索引函数：</p>
<p>void auxSetOneColor(GLint index,GLfloat red,GLfloat green,GLfloat blue)</p>
<p>设置自定义颜色的索引。参数index即索引号，参数red、green、blue分别为红、绿、蓝值，范围在（0～1）内。</p>
<p>6.1.4 三维物体绘制<br>每组三维物体包括两种形式：网状体（wire）和实心体（solid）。网状体没有平面法向，而实心体有，能进行光影计算，有光照时采用实心体模型。下面这些函数的 参数都是定义物体大小的，可以改变。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="25%"><strong>功能</strong></td></p>
<p><td width="75%"><strong>函数</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制球</td></p>
<p><td valign="top" width="75%">void auxWireSphere(GLdouble radius)<br>void auxSolidSphere(GLdouble radius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制立方体</td></p>
<p><td valign="top" width="75%">void auxWireCube(GLdouble size)<br>void auxSolidCube(GLdouble size)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制长方体</td></p>
<p><td valign="top" width="75%">void auxWireBox(GLdouble width,GLdouble height,GLdouble depth)<br>void auxSolidBox(GLdouble width,GLdouble height,GLdouble depth)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制环形圆纹面</td></p>
<p><td valign="top" width="75%">void auxWireTorus(GLdouble innerRadius,GLdouble outerRadius)<br>void auxSolidTorus(GLdouble innerRadius,GLdouble outerRadius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制圆柱</td></p>
<p><td valign="top" width="75%">void auxWireCylinder(GLdouble radius,GLdouble height)<br>void auxSolidCylinder(GLdouble radius,GLdouble height)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制二十面体</td></p>
<p><td valign="top" width="75%">void auxWireIcosahedron(GLdouble radius)<br>void auxSolidIcosahedron(GLdouble radius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制八面体</td></p>
<p><td valign="top" width="75%">void auxWireOctahedron(GLdouble radius)<br>void auxSolidOctahedron(GLdouble radius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制四面体</td></p>
<p><td valign="top" width="75%">void auxWireTetrahedron(GLdouble radius)<br>void auxSolidTetrahedron(GLdouble radius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制十二面体</td></p>
<p><td valign="top" width="75%">void auxWireDodecahedron(GLdouble radius)<br>void auxSolidDodecahedron(GLdouble radius)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制圆锥</td></p>
<p><td valign="top" width="75%">void auxWireCone(GLdouble radius,GLdouble height)<br>void auxSolidCone(GLdouble radius,GLdouble height)</td><br></p>
<p><tr></tr></p>
<p><td valign="center" width="25%">绘制茶壶</td></p>
<p><td valign="top" width="75%">void auxWireTeapot(GLdouble size)<br>void aucSolidTeapot(GLdouble size)</td><br></p>
<p><tr></tr></p>
<p><td colspan="2" valign="center"><strong>表6-1</strong></td><br><br><br><br>以上物体均以各自中心为原点绘制，所有坐标都已单位化，可以缩放。</p>
<p>6.1.5 背景过程管理</p>
<p>void auxIdleFunc(void *func)</p>
<p>定义空闲状态执行函数。参数func是一个指针，指向所要执行的函数功能。当它为零时，func执行无效。</p>
<p>6.1.6 程序运行</p>
<p>void auxMainLoop(void(*displayFunc)(void))</p>
<p>定义场景绘制循环函数。displayFunc指针指向场景绘制函数。当窗口需要更新或场景发生改变时，程序便调用它所指的函数，重新绘制场景。<br><a name="6.2"></a><br>6.2、辅助库应用示例<br>下面举一个辅助库的应用例子，testaux.c：</p>
<p>例6-1 辅助库应用例程 testaux.c</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w,GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>glClearColor(0.0,0.0,0.0,0.0);<br>glClear(GL_COLOR_BUFFER_BIT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w,GLsizei h)<br>{<br>glViewport(0,0,w,h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if(w&lt;=h)<br>glOrtho(-1.5,1.5,-1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>else<br>glOrtho(-1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w,-1.5,1.5,-10.0,10.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glColor3f(1.0,1.0,0.0);<br>auxWireSphere(1.0);<br>glFlush();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);<br>auxInitPosition(0,0,500,500);<br>auxInitWindow(“AUX_SAMPLE”);<br>myinit();<br>auxReshapeFunc(myReshape);<br>auxMainLoop(display);<br>}</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/6.1.GIF" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图6-1 网状球体</strong></td><br><br><br><br>以上程序运行结果是在屏幕窗口内绘制一个黄色的网状球体，这个程序充分体现了辅助库的基本应用方法。<br>首先，在主函数中用辅助库函数定义一个窗口auxInitWindow()，然后初始化颜色myinit()，这些在第一章中已说明。接下来是两个十分重要的函数 auxReshapeFunc()和auxMainLoop()，参数都是一个函数指针，指向的都是回调函数（回调函数定义用CALLBACK说明）。<br>前者是窗口形状重定函数，参数指针指向函数myReshape()，它的两个参数就是窗口的新宽度和新高度。然后用glViewport(0, 0, w, h)重定视口，并且在新视口内重新定义投影矩阵，</p>
<p>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if(w&lt;=h)<br>glOrtho(-1.5,1.5,-1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>else<br>glOrtho(-1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w,-1.5,1.5,-10.0,10.0);</p>
<p>即先用glMatrixMode()说明当前矩阵操作与投影有关GL_PROJECTION，再用glLoadIdentity()将矩阵清为单位矩阵，避免受其它矩阵操作的干扰；然后调用glOrtho()对物体进行正射投影，并且用判断语句给出了两种情况，使投影后图像的比例与视点匹配，避免比例失调。<br>再下来调用glMatrixMode()将矩阵操作改为对观察物体有关的方式GL_MODELVIEW，同样用 glLoadIdentity()清矩阵。后者是主函数循环函数，参数指针指向函数display()，即绘制物体。当窗口需要更新或物体发生改变时，程序便调用它重新绘制。以上例子是辅助库的最基本应用，复杂的应用将在后续的章节中详细介绍。</p>
<p>七、OpenGL建模</p>
<p>OpenGL基本库提供了大量绘制各种类型图元的方法，辅助库也提供了不少描述复杂三维图形的函数。这一章主要介绍基本图元，如点、线、多边形，有了这些图元，就可以建立比较复杂的模型了。<br><a name="7.1"></a><br>7.1、描述图元<br>OpenGL是三维图形的函数库，它所定义的点、线、多边形等图元与一般的定义不太一样，存在一定的差别。对编程者来说，能否理解二者之间的差别十分重要。一种差别源于基于计算机计算的限制。OpenGL中所有浮点计算精度有限，故点、线、多边形的坐标值存在一定的误差。另一种差别源于位图显示的限制。以这种方式显示图形，最小的显示图元是一个象素，尽管每个象素宽度很小，但它们仍然比数学上所定义的点或线宽要大得多。当用OpenGL 进行计算时，虽然是用一系列浮点值定义点串，但每个点仍然是用单个象素显示，只是近似拟合。<br>OpenGL图元是抽象的几何概念，不是真实世界中的物体，因此须用相关的数学模型来描述。</p>
<p>7.1.1 齐次坐标（Homogeneous Coordinate）<br>在空间直角坐标系中，任意一点可用一个三维坐标矩阵[x y z]表示。如果将该点用一个四维坐标的矩阵[Hx Hy Hz H]表示时，则称为齐次坐标表示方法。在齐次坐标中，最后一维坐标H称为比例因子。<br>在OpenGL中，二维坐标点全看作三维坐标点，所有的点都用齐次坐标来描述，统一作为三维齐次点来处理。每个齐次点用一个向量(x, y, z, w)表示，其中四个元素全不为零。齐次点具有下列几个性质：<br>1）如果实数a非零，则(x, y, x, w)和(ax, ay, az, aw)表示同一个点，类似于x/y = (ax)/( ay)。<br>2）三维空间点(x, y, z)的齐次点坐标为(x, y, z, 1.0)，二维平面点(x,y)的齐次坐标为(x, y, 0.0, 1.0)。<br>3）当w不为零时，齐次点坐标(x, y, z, w)即三维空间点坐标(x/w, y/w, z/w)；当w为零时，齐次点(x, y, z, 0.0)表示此点位于某方向的无穷远处。<br>注意：OpenGL中指定w大于或等于0.0。</p>
<p>7.1.2 点(Point)<br>用浮点值表示的点称为顶点（Vertex）。所有顶点在OpenGL内部计算时都作为三维点处理，用二维坐标(x, y)定义的点在OpenGL中默认z值为0。所有顶点坐标用齐次坐标(x, y, z, w) 表示，如果w不为0.0，这些齐次坐标表示的顶点即为三维空间点(x/w, y/w, z/w)。编程者可以自己指定w值，但很少这样做。一般来说，w缺省为1.0。</p>
<p>7.1.3 线(Line)<br>在OpenGL中，线代表线段（Line Segment），不是数学意义上的那种沿轴两个方向无限延伸的线。这里的线由一系列顶点顺次连结而成，有闭合和不闭合两种。见图7-1所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/7.1.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图7-1 线段的两种连结方式</strong></td><br><br><br><br>7.1.4 多边形(Polygon)<br>OpenGL中定义的多边形是由一系列线段依次连结而成的封闭区域。这些线段不能交叉，区域内不能有空洞，多边形必须在凸多边形，否则不能被OpenGL函数接受。合法和非法多边形图示见图7-2。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/7.2.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图7-2 合法和非法多边形</strong></td><br><br><br><br>OpenGL多边形可以是平面多边形，即所有顶点在一个平面上，也可以是空间多边形。更复杂的多边形将在提高篇中介绍。<br><a name="7.2"></a><br>7.2、绘制图元</p>
<p>7.2.1 定义顶点<br>在OpenGL中，所有几何物体最终都由有一定顺序的顶点集来描述。<br>函数glVertex{234}{sifd}<a href="TYPE coords">v</a>可以用二维、三维或齐次坐标定义顶点。举例如下：</p>
<p>glVertex2s(2,3);<br>glVertex3d(0.0,1.0,3.1414926535);<br>glVertex4f(2.4,1.0,-2.2,2.0);<br>GLfloat pp[3]={5.0,2.0,10.2};<br>glVertex3fv(pp);</p>
<p>第一例子表示一个空间顶点(2, 3, 0)，第二个例子表示用双精度浮点数定义一个顶点，第三个例子表示用齐次坐标定义一个顶点，其真实坐标为(1.2, 0.5, -1.1)，最后一个例子表示用一个指针（或数组）定义顶点。</p>
<p>7.2.2 构造几何图元<br>在实际应用中，通常用一组相关的顶点序列以一定的方式组织起来定义某个几何图元，而不采用单独定义多个顶点来构造几何图元。在OpenGL中，所有被定义的顶点必须放在glBegain()和glEnd()两个函数之间才能正确表达一个几何图元或物体，否则，glVertex*()不完成任何操作。如：</p>
<p>glBegin(GL_POLYGON);<br>glVertex2f(0.0,0.0);<br>glVertex2f(0.0,3.0);<br>glVertex2f(3.0,3.0);<br>glVertex2f(4.0,1.5);<br>glVertex2f(3.0,0.0);<br>glEnd();</p>
<p>以上这段程序定义了一个多边形，如果将glBegin()中的参数GL_POLYGON改为GL_POINTS，则图形变为一组顶点（5个），见图7-3所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/7.3.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图7-3 绘制多边形或一组顶点</strong></td><br><br><br><br>点函数glBegin(GLenum mode)标志描述一个几何图元的顶点列表的开始，其参数mode表示几何图元的描述类型。所有类型及说明见表7-1所示，相应的图示见图7-4。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="30%"><strong>类型</strong></td></p>
<p><td width="70%"><strong>说明</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_POINTS</td></p>
<p><td valign="top" width="70%">单个顶点集</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_LINES</td></p>
<p><td valign="top" width="70%">多组双顶点线段</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_POLYGON</td></p>
<p><td valign="top" width="70%">单个简单填充凸多边形</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_TRAINGLES</td></p>
<p><td valign="top" width="70%">多组独立填充三角形</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_QUADS</td></p>
<p><td valign="top" width="70%">多组独立填充四边形</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_LINE_STRIP</td></p>
<p><td valign="top" width="70%">不闭合折线</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_LINE_LOOP</td></p>
<p><td valign="top" width="70%">闭合折线</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_TRAINGLE_STRIP</td></p>
<p><td valign="top" width="70%">线型连续填充三角形串</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_TRAINGLE_FAN</td></p>
<p><td valign="top" width="70%">扇形连续填充三角形串</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="30%">GL_QUAD_STRIP</td></p>
<p><td valign="top" width="70%">连续填充四边形串</td><br></p>
<p><tr></tr></p>
<p><td colspan="2" valign="top"><strong>表7-1 几何图元类型和说明</strong></td><br><br><br><br>&nbsp;</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/7.4.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图7-4 几何图元类型</strong></td><br><br><br><br>函数glEnd()标志顶点列表的结束。<br>从图7-4中可看出，可以采用许多方法构造几何图元，这些方法仅仅依赖于所给的顶点数据。<br>在glBegin()和glEnd()之间最重要的信息就是由函数glVertex*()定义的顶点，必要时也可为每个顶点指定颜色、法向、纹理坐标或其他，即调用相关的函数，见表7-2所示，具体用法以后会逐步介绍。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="35%"><strong>函数</strong></td></p>
<p><td width="60%"><strong>函数意义</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glVertex*()</td></p>
<p><td valign="top" width="60%">设置顶点坐标</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glColor*()</td></p>
<p><td valign="top" width="60%">设置当前颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glIndex*()</td></p>
<p><td valign="top" width="60%">设置当前颜色表</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glNormal*()</td></p>
<p><td valign="top" width="60%">设置法向坐标</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glEvalCoord*()</td></p>
<p><td valign="top" width="60%">产生坐标</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glCallList(),glCallLists()</td></p>
<p><td valign="top" width="60%">执行显示列表</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glTexCoord*()</td></p>
<p><td valign="top" width="60%">设置纹理坐标</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glEdgeFlag*()</td></p>
<p><td valign="top" width="60%">控制边界绘制</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="35%">glMaterial*()</td></p>
<p><td valign="top" width="60%">设置材质</td><br></p>
<p><tr></tr></p>
<p><td colspan="2" valign="top"><strong>表7-2 在glBegin()和glEnd()之间可调用的函数</strong></td><br><br><br><br>看如下几句：</p>
<p>glBegin(GL_POINTS);<br>glColor3f(1.0,0.0,0.0); /<em> red color </em>/<br>glVertex(…);<br>glColor3f(0.0,1.0,0.0); /<em> green color </em>/<br>glColor3f(0.0,0.0,1.0); /<em> blue color </em>/<br>glVertex(…);<br>glVertex(…);<br>glEnd();</p>
<p>颜色等的设置只对当前点或后续点有效。上一例中第一个点是红色，第二个点和第三个点都是蓝色。其中设置绿色时，之后没有顶点操作，而是设置蓝色，故只有当前蓝色对紧跟其后的两个顶点有效。<br>为了更好地理解构造几何图元函数的用法，下面举一个简单的例子：</p>
<p>例7-3 几何图元构造例程（drawgeom.c）</p>
<p>#include “glos.h”</p>
<p>#include&lt;GL/gl.h&gt;</p>
<p>#include&lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void DrawMyObjects(void);<br>void CALLBACK myReshape(GLsizei w,GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>glClearColor(0.0,0.0,0.0,0.0);<br>glClear(GL_COLOR_BUFFER_BIT);<br>glShadeModel(GL_FLAT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w,GLsizei h)<br>{<br>glViewport(0,0,w,h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();</p>
<p>if(w&lt;=h)<br>glOrtho(-20.0,20.0,-20.0<em>(GLfloat)h/(GLfloat)w, 20.0</em>(GLfloat)h/(GLfloat)w,-50.0,50.0);<br>else<br>glOrtho(-20.0<em>(GLfloat)h/(GLfloat)w, 20.0</em>(GLfloat)h/(GLfloat)w,-20.0,20.0,-50.0,50.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glColor3f(1.0,1.0,0.0);<br>DrawMyObjects();<br>glFlush();<br>}</p>
<p>void DrawMyObjects(void)<br>{<br>/<em> draw some points </em>/<br>glBegin(GL_POINTS);<br>glColor3f(1.0,0.0,0.0);<br>glVertex2f(-10.0,11.0);<br>glColor3f(1.0,1.0,0.0);<br>glVertex2f(-9.0,10.0);<br>glColor3f(0.0,1.0,1.0);<br>glVertex2f(-8.0,12.0);<br>glEnd();</p>
<p>/<em> draw some line_segments </em>/<br>glBegin(GL_LINES);<br>glColor3f(1.0,1.0,0.0);<br>glVertex2f(-11.0,8.0);<br>glVertex2f(-7.0,7.0);<br>glColor3f(1.0,0.0,1.0);<br>glVertex2f(-11.0,9.0);<br>glVertex2f(-8.0,6.0);<br>glEnd();</p>
<p>/<em> draw one opened_line </em>/<br>glBegin(GL_LINE_STRIP);<br>glColor3f(0.0,1.0,0.0);<br>glVertex2f(-3.0,9.0);<br>glVertex2f(2.0,6.0);<br>glVertex2f(3.0,8.0);<br>glVertex2f(-2.5,6.5);<br>glEnd();</p>
<p>/<em> draw one closed_line </em>/<br>glBegin(GL_LINE_LOOP);<br>glColor3f(0.0,1.0,1.0);<br>glVertex2f(7.0,7.0);<br>glVertex2f(8.0,8.0);<br>glVertex2f(9.0,6.5);<br>glVertex2f(10.3,7.5);<br>glVertex2f(11.5,6.0);<br>glVertex2f(7.5,6.0);<br>glEnd();</p>
<p>/<em> draw one filled_polygon </em>/<br>glBegin(GL_POLYGON);<br>glColor3f(0.5,0.3,0.7);<br>glVertex2f(-7.0,2.0);<br>glVertex2f(-8.0,3.0);<br>glVertex2f(-10.3,0.5);<br>glVertex2f(-7.5,-2.0);<br>glVertex2f(-6.0,-1.0);<br>glEnd();</p>
<p>/<em> draw some filled_quandrangles </em>/<br>glBegin(GL_QUADS);<br>glColor3f(0.7,0.5,0.2);<br>glVertex2f(0.0,2.0);<br>glVertex2f(-1.0,3.0);<br>glVertex2f(-3.3,0.5);<br>glVertex2f(-0.5,-1.0);<br>glColor3f(0.5,0.7,0.2);<br>glVertex2f(3.0,2.0);<br>glVertex2f(2.0,3.0);<br>glVertex2f(0.0,0.5);<br>glVertex2f(2.5,-1.0);<br>glEnd();</p>
<p>/<em> draw some filled_strip_quandrangles </em>/<br>glBegin(GL_QUAD_STRIP);<br>glVertex2f(6.0,-2.0);<br>glVertex2f(5.5,1.0);<br>glVertex2f(8.0,-1.0);<br>glColor3f(0.8,0.0,0.0);<br>glVertex2f(9.0,2.0);<br>glVertex2f(11.0,-2.0);<br>glColor3f(0.0,0.0,0.8);<br>glVertex2f(11.0,2.0);<br>glVertex2f(13.0,-1.0);<br>glColor3f(0.0,0.8,0.0);<br>glVertex2f(14.0,1.0);<br>glEnd();</p>
<p>/<em> draw some filled_triangles </em>/<br>glBegin(GL_TRIANGLES);<br>glColor3f(0.2,0.5,0.7);<br>glVertex2f(-10.0,-5.0);<br>glVertex2f(-12.3,-7.5);<br>glVertex2f(-8.5,-6.0);<br>glColor3f(0.2,0.7,0.5);<br>glVertex2f(-8.0,-7.0);<br>glVertex2f(-7.0,-4.5);<br>glVertex2f(-5.5,-9.0);<br>glEnd();</p>
<p>/<em> draw some filled_strip_triangles </em>/<br>glBegin(GL_TRIANGLE_STRIP);<br>glVertex2f(-1.0,-8.0);<br>glVertex2f(-2.5,-5.0);<br>glColor3f(0.8,0.8,0.0);<br>glVertex2f(1.0,-7.0);<br>glColor3f(0.0,0.8,0.8);<br>glVertex2f(2.0,-4.0);<br>glColor3f(0.8,0.0,0.8);<br>glVertex2f(4.0,-6.0);<br>glEnd();</p>
<p>/<em> draw some filled_fan_triangles </em>/<br>glBegin(GL_TRIANGLE_FAN);<br>glVertex2f(8.0,-6.0);<br>glVertex2f(10.0,-3.0);<br>glColor3f(0.8,0.2,0.5);<br>glVertex2f(12.5,-4.5);<br>glColor3f(0.2,0.5,0.8);<br>glVertex2f(13.0,-7.5);<br>glColor3f(0.8,0.5,0.2);<br>glVertex2f(10.5,-9.0);<br>glEnd();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode(AUX_SINGLE|AUX_RGBA);<br>auxInitPosition(0,0,500,500);<br>auxInitWindow(“Geometric Primitive Types”);<br>myinit();<br>auxReshapeFunc(myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果就是图7-4所示的内容，这个例子很好地说明了几何图元的类型及颜色等函数的用法。希望读者自己仔细分析每个物体的绘制方法，体会其中的关键之处，达到举一反三的效果。当然，还可利用上一章辅助库中提供的基本三维图元构造比较复杂的物体，你不妨也试一试。</p>
<p>八、OpenGL变换</p>
<p>OpenGL变换是本篇的重点内容，它包括计算机图形学中最基本的三维变换，即几何变换、投影变换、裁剪变换、视口变换，以及针对OpenGL的特殊变换概念理解和用法，如相机模拟、矩阵堆栈等。学好了这章，才开始真正走进三维世界。<br><a name="8.1"></a><br>8.1、从三维空间到二维平面</p>
<p>8.1.1 相机模拟<br>在真实世界里，所有的物体都是三维的。但是，这些三维物体在计算机世界中却必须以二维平面物体的形式表现出来。那么，这些物体是怎样从三维变换到二维的呢？下面我们采用相机（Camera）模拟的方式来讲述这个概念，如图8-1所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.1.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-1 相机模拟</strong></td><br><br><br><br>实际上，从三维空间到二维平面，就如同用相机拍照一样，通常都要经历以下几个步骤 （括号内表示的是相应的图形学概念）：<br>第一步，将相机置于三角架上，让它对准三维景物（视点变换，Viewing Transformation）。<br>第二步，将三维物体放在适当的位置（模型变换，Modeling Transformation）。<br>第三步，选择相机镜头并调焦，使三维物体投影在二维胶片上（投影变换，Projection Transformation）。<br>第四步，决定二维像片的大小（视口变换，Viewport Transformation）。<br>这样，一个三维空间里的物体就可以用相应的二维平面物体表示了，也就能在二维的电脑屏幕上正确显示了。</p>
<p>8.1.2 三维图形显示流程<br>运用相机模拟的方式比较通俗地讲解了三维图形显示的基本过程，但在具体应用OpenGL函数库编程时，还必须了解三维图形世界中的几个特殊坐标系的概念，以及用这些概念表达的三维图形显示流程。<br>计算机本身只能处理数字，图形在计算机内也是以数字的形式进行加工和处理的。大家都知道，坐标建立了图形和数字之间的联系。为了使被显示的物体数字化，要在被显示的物体所在的空间中定义一个坐标系。这个坐标系的长度单位和坐标轴的方向要适合对被显示物体的描述，这个坐标系称为世界坐标系。<br>计算机对数字化的显示物体作了加工处理后，要在图形显示器上显示，这就要在图形显示器屏幕上定义一个二维直角坐标系，这个坐标系称为屏幕坐标系。这个坐标系坐标轴的方向通常取成平行于屏幕的边缘，坐标原点取在左下角，长度单位常取成一个象素的长度，大小可以是整型数。<br>为了使显示的物体能以合适的位置、大小和方向显示出来，必须要通过投影。投影的方法有两种，即正射投影和透视投影。<br>有时为了突出图形的一部分，只把图形的某一部分显示出来，这时可以定义一个三维视景体（Viewing Volume）。正射投影时一般是一个长方体的视景体，透视投影时一般是一个棱台似的视景体。只有视景体内的物体能被投影在显示平面上，其他部分则不能。在屏幕窗口内可以定义一个矩形，称为视口（Viewport），视景体投影后的图形就在视口内显示。<br>为了适应物理设备坐标和视口所在坐标的差别，还要作一适应物理坐标的变换。这个坐标系称为物理设备坐标系。根据上面所述，三维图形的显示流程应如图8-2所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.2.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-2 三维图形的显示流程</strong></td><br><br><br><br>8.1.3 基本变换简单分析<br>下面举一个简单的变换例子，cube.c：</p>
<p>例8-4 简单变换例程（cube.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);<br>void CALLBACK display(void);</p>
<p>void CALLBACK display (void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT);<br>glColor3f (1.0, 1.0, 1.0);<br>glLoadIdentity (); /<em> clear the matrix </em>/<br>glTranslatef (0.0, 0.0, -5.0); /<em> viewing transformation </em>/<br>glScalef (1.0, 2.0, 1.0); /<em> modeling transformation </em>/<br>auxWireCube(1.0); /<em> draw the cube </em>/<br>glFlush();<br>}</p>
<p>void myinit (void)<br>{<br>glShadeModel (GL_FLAT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glMatrixMode (GL_PROJECTION); /<em> prepare for and then </em>/<br>glLoadIdentity (); /<em> define the projection </em>/<br>glFrustum (-1.0, 1.0, -1.0, 1.0, 1.5, 20.0); /<em> transformation </em>/<br>glMatrixMode (GL_MODELVIEW); /<em> back to modelview matrix </em>/<br>glViewport (0, 0, w, h); /<em> define the viewport </em>/<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Perspective 3-D Cube”);<br>myinit ();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果就是绘制一个三维的正面透视立方体。其中已经用到了相机模拟中提到的四种基本变换，即视点变换、模型变换、投影变换和视口变换。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"></td></p>
<p><table border="0" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr bgcolor="#ffffff"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.3.JPG" alt=""></td><br><br><br><br><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-3 三维的正面透视立方体</strong></td><br><br><br><br>下面简单分析一下整个程序过程：<br>1）视点变换。视点变换是在视点坐标系中进行的。视点坐标系于一般的物体所在的世界坐标系不同，它遵循左手法则，即左手大拇指指向Z正轴，与之垂直的四个手指指向X正轴，四指弯曲90度的方向是Y正轴。而世界坐标系遵循右手法则的。如图8-4所示。当矩阵初始化glLoadIdentity()后，调用glTranslatef()作视点变换。函数参数(x, y, z)表示视点或相机在视点坐标系中移动的位置，这里z=-5.0，意思是将相机沿Z负轴移动5个单位。<br>通常相机位置缺省值同场景中的物体一样，都在原点处，而且相机初始方向都指向Z负轴。<br>这里相机移走后，仍然对准立方体。如果相机需要指向另一方向，则调用glRotatef()可以改变。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.4.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-4 视点坐标系与世界坐标系</strong></td><br><br><br><br>2）模型变换。模型变换是在世界坐标系中进行的。在这个坐标系中，可以对物体实施平移 glTranslatef()、旋转glRotatef()和放大缩小glScalef()。例子里只对物体进行比例变换，glScalef(sx, sy, sz)的三个参数分别是X、Y、Z轴向的比例变换因子。缺省时都为1.0，即物体没变化。程序中物体Y轴比例为2.0，其余都为1.0，就是说将立方体变成长方体。<br>3）投影变换。投影变换类似于选择相机的镜头。本例中调用了一个透视投影函数 glFrustum()，在调用它之前先要用glMatrixMode()说明当前矩阵方式是投影GL_PROJECTION。这个投影函数一共有六个参数，由它们可以定义一个棱台似的视景体。即视景体内的部分可见，视景体外的部分不可见，这也就包含了三维裁剪变换。<br>4）视口变换。视口变换就是将视景体内投影的物体显示在二维的视口平面上。通常，都调用函数glViewport()来定义一个视口，这个过程类似于将照片放大或缩小。<br>总而言之，一旦所有必要的变换矩阵被指定后，场景中物体的每一个顶点都要按照被指定的变换矩阵序列逐一进行变换。注意：OpenGL 中的物体坐标一律采用齐次坐标，即(x, y, z, w)，故所有变换矩阵都采用4X4矩阵。一般说来，每个顶点先要经过视点变换和模型变换，然后进行指定的投影，如果它位于视景体外，则被裁剪掉。最后，余下的已经变换过的顶点x、y、z坐标值都用比例因子w除，即x/w、y/w、z/w，再映射到视口区域内，这样才能显示在屏幕上。<br><a name="8.2"></a><br>8.2、几何变换<br>实际上，上述所说的视点变换和模型变换本质上都是一回事，即图形学中的几何变换。<br>只是视点变换一般只有平移和旋转，没有比例变换。当视点进行平移或旋转时，视点坐标系中的物体就相当于在世界坐标系中作反方向的平移或旋转。因此，从某种意义上讲，二者可以统一，只是各自出发点不一样而已。读者可以根据具体情况，选择其中一个角度去考虑，这样便于理解。</p>
<p>8.2.1 两个矩阵函数解释<br>这里先解释两个基本OpenGL矩阵操作函数，便于以后章节的讲述。函数解释如下：</p>
<p>void glLoadMatrix{fd}(const TYPE *m)</p>
<p>设置当前矩阵中的元素值。函数参数*m是一个指向16个元素(m0, m1, …, m15)的指针，这16个元素就是当前矩阵M中的元素，其排列方式如下：</p>
<p><table border="0" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td align="right" width="45%">M =</td></p>
<p><td align="left" width="55%">| m0 m4 m8　m12 |<br>| m1 m5 m9　m13 |<br>| m2 m6 m10 m14 |<br>| m3 m7 m11 M15 |</td><br><br><br><br>void glMultMatrix{fd}(const TYPE *m)</p>
<p>用当前矩阵去乘<em>m所指定的矩阵，并将结果存放于</em>m中。当前矩阵可以是用glLoadMatrix() 指定的矩阵，也可以是其它矩阵变换函数的综合结果。<br>当几何变换时，调用OpenGL的三个变换函数glTranslate<em>()、glRotate</em>()和glScale*()，实质上相当于产生了一个近似的平移、旋转和比例矩阵，然后调用glMultMatrix()与当前矩阵相乘。但是直接调用这三个函数程序运行得快一些，因OpenGL自动能计算矩阵。</p>
<p>8.2.2 平移<br>平移变换函数如下：</p>
<p>void glTranslate{fd}(TYPE x,TYPE y,TYPE z)</p>
<p>三个函数参数就是目标分别沿三个轴向平移的偏移量。这个函数表示用这三个偏移量生成的矩阵乘以当前矩阵。当参数是(0.0,0.0,0.0)时，表示对函数glTranslate*()的操作是单位矩阵，也就是对物体没有影响。平移示意如图8-5所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.5.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-5 平移示意图</strong></td><br><br><br><br>8.2.3 旋转<br>旋转变换函数如下：</p>
<p>void glRotate{fd}(TYPE angle,TYPE x,TYPE y,TYPE z)</p>
<p>函数中第一个参数是表示目标沿从点(x, y, z)到原点的方向逆时针旋转的角度，后三个参数是旋转的方向点坐标。这个函数表示用这四个参数生成的矩阵乘以当前矩阵。当角度参数是0.0时，表示对物体没有影响。旋转示意如图8-6所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.6.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-6 旋转示意图</strong></td><br><br><br><br>8.2.3 缩放和反射<br>缩放和反射变换函数如下：</p>
<p>void glScale{fd}(TYPE x,TYPE y,TYPE z)</p>
<p>三个函数参数值就是目标分别沿三个轴向缩放的比例因子。这个函数表示用这三个比例因子生成的矩阵乘以当前矩阵。这个函数能完成沿相应的轴对目标进行拉伸、压缩和反射三项功能。当参数是(1.0, 1.0, 1.0)时，表示对函数glScale*()操作是单位矩阵，也就是对物体没有影响。当其中某个参数为负值时，表示将对目标进行相应轴的反射变换，且这个参数不为1.0，则还要进行相应轴的缩放变换。最好不要令三个参数值都为零，这将导致目标沿三轴都缩为零。缩放和反射示意如图8-7所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.7.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-7 缩放和反射示意图</strong></td><br><br><br><br>8.2.5 几何变换举例<br>以上介绍了三个基本几何变换函数，下面举一个简单的例子进一步说明它们的用法。程序如下：</p>
<p>例 8-5 几何变换例程（geomtrsf.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void draw_triangle(void);<br>void CALLBACK display(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);</p>
<p>void draw_triangle(void)<br>{<br>glBegin(GL_LINE_LOOP);<br>glVertex2f(0.0, 25.0);<br>glVertex2f(25.0, -25.0);<br>glVertex2f(-25.0, -25.0);<br>glEnd();<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClearColor (0.0, 0.0, 0.0, 1.0);<br>glClear (GL_COLOR_BUFFER_BIT);</p>
<p>/<em> draw an original triangle </em>/<br>glLoadIdentity ();<br>glColor3f (1.0, 1.0, 1.0);　　/<em> white </em>/<br>draw_triangle ();</p>
<p>/<em> translating a triangle along X_axis </em>/<br>glLoadIdentity ();<br>glTranslatef (-20.0, 0.0, 0.0);<br>glColor3f(1.0,0.0,0.0);　　　/<em> red </em>/<br>draw_triangle ();</p>
<p>/<em> scaling a triangle along X_axis by 1.5 and along Y_axis by 0.5 </em>/<br>glLoadIdentity();<br>glScalef (1.5, 0.5, 1.0);<br>glColor3f(0.0,1.0,0.0);　　　/<em> green </em>/<br>draw_triangle ();</p>
<p>/<em> rotating a triangle in a counterclockwise direction about Z_axis </em>/<br>glLoadIdentity ();<br>glRotatef (90.0, 0.0, 0.0, 1.0);<br>glColor3f(0.0,0.0,1.0);　　　/<em> blue </em>/<br>draw_triangle ();</p>
<p>/<em> scaling a triangle along Y_axis and reflecting it about Y_axis </em>/<br>glLoadIdentity();<br>glScalef (1.0, -0.5, 1.0);<br>glColor3f(1.0,1.0,0.0); 　　/<em> yellow </em>/<br>draw_triangle ();</p>
<p>glFlush();<br>}</p>
<p>void myinit (void)<br>{<br>glShadeModel (GL_FLAT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>glOrtho(-50.0, 50.0, -50.0<em>(GLfloat)h/(GLfloat)w, 50.0</em>(GLfloat)h/(GLfloat)w,-1.0,1.0);<br>else<br>glOrtho(-50.0<em>(GLfloat)w/(GLfloat)h, 50.0</em>(GLfloat)w/(GLfloat)h, -50.0, 50.0,-1.0,1.0);<br>glMatrixMode(GL_MODELVIEW);<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Geometric Transformations”);<br>myinit ();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果：第一个白色三角形是原始三角形，第二个红色三角形是白三角沿X 负轴平移后的三角形，第三个绿色三角形是白三角分别沿X轴和Y轴比例变换后的三角形，第四个蓝色三角形是白三角绕Z正轴逆时针转90度后的三角形，第五个黄色三角形是白三角沿Y轴方向缩小一倍且相对于X轴作反射后形成的三角形。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.8.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-8 三角形的几何变换</strong></td><br><br><br><br><a name="8.3"></a><br>8.3、投影变换<br>投影变换是一种很关键的图形变换，OpenGL中只提供了两种投影方式，一种是正射投影，另一种是透视投影。不管是调用哪种投影函数，为了避免不必要的变换，其前面必须加上以下两句：</p>
<p>glMAtrixMode(GL_PROJECTION);<br>glLoadIdentity();</p>
<p>事实上，投影变换的目的就是定义一个视景体，使得视景体外多余的部分裁剪掉，最终图像只是视景体内的有关部分。本指南将详细讲述投影变换的概念以及用法。</p>
<p>8.3.1 正射投影（Orthographic Projection）<br>正射投影，又叫平行投影。这种投影的视景体是一个矩形的平行管道，也就是一个长方体，如图8-9所示。正射投影的最大一个特点是无论物体距离相机多远，投影后的物体大小尺寸不变。这种投影通常用在建筑蓝图绘制和计算机辅助设计等方面，这些行业要求投影后的物体尺寸及相互间的角度不变，以便施工或制造时物体比例大小正确。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.9.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-9 正射投影视景体</strong></td><br><br><br><br>OpenGL正射投影函数共有两个，这在前面几个例子中已用过。一个函数是：</p>
<p>void glOrtho(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,<br>GLdouble near,GLdouble far)</p>
<p>它创建一个平行视景体。实际上这个函数的操作是创建一个正射投影矩阵，并且用这个矩阵乘以当前矩阵。其中近裁剪平面是一个矩形，矩形左下角点三维空间坐标是（left，bottom，-near），右上角点是（right，top，-near）；远裁剪平面也是一个矩形，左下角点空间坐标是（left，bottom，-far），右上角点是（right，top，-far）。所有的near和far值同时为正或同时为负。如果没有其他变换，正射投影的方向平行于Z轴，且视点朝向Z负轴。<br>这意味着物体在视点前面时far和near都为负值，物体在视点后面时far和near都为正值。另一个函数是：</p>
<p>void gluOrtho2D(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top)</p>
<p>它是一个特殊的正射投影函数，主要用于二维图像到二维屏幕上的投影。它的near和far缺省值分别为-1.0和1.0，所有二维物体的Z坐标都为0.0。因此它的裁剪面是一个左下角点为（left，bottom）、右上角点为（right，top）的矩形。</p>
<p>8.3.2 透视投影（Perspective Projection）<br>透视投影符合人们心理习惯，即离视点近的物体大，离视点远的物体小，远到极点即为消失，成为灭点。它的视景体类似于一个顶部和底部都被切除掉的棱椎，也就是棱台。这个投影通常用于动画、视觉仿真以及其它许多具有真实性反映的方面。<br>OpenGL透视投影函数也有两个，其中函数glFrustum()在8.1.3节中提到过，它所形成的视景体如图8-10所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.10.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-10 函数glFrustum()透视投影视景体</strong></td><br><br><br><br>这个函数原型为：</p>
<p>void glFrustum(GLdouble left,GLdouble Right,GLdouble bottom,GLdouble top,<br>GLdouble near,GLdouble far);</p>
<p>它创建一个透视视景体。其操作是创建一个透视投影矩阵，并且用这个矩阵乘以当前矩阵。这个函数的参数只定义近裁剪平面的左下角点和右上角点的三维空间坐标，即（left，bottom，-near）和（right，top，-near）；最后一个参数far是远裁剪平面的Z负值，其左下角点和右上角点空间坐标由函数根据透视投影原理自动生成。near和far表示离视点的远近，它们总为正值。<br>另一个函数是：</p>
<p>void gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear, GLdouble zFar);</p>
<p>它也创建一个对称透视视景体，但它的参数定义于前面的不同，如图8-11所示。其操作是创建一个对称的透视投影矩阵，并且用这个矩阵乘以当前矩阵。参数 fovy定义视野在X-Z平面的角度，范围是[0.0, 180.0]；参数aspect是投影平面宽度与高度的比率；参数zNear和Far分别是远近裁剪面沿Z负轴到视点的距离，它们总为正值。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.11.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-11 函数gluPerspective()透视投影视景体</strong></td><br><br><br><br>以上两个函数缺省时，视点都在原点，视线沿Z轴指向负方向。二者的应用实例将在后续章节中介绍。<br><a name="8.4"></a><br>8.4、裁剪变换<br>在OpenGL中，空间物体的三维裁剪变换包括两个部分：视景体裁剪和附加平面裁剪。视景体裁剪已经包含在投影变换里，前面已述，这里不再重复。下面简单讲一下平面裁剪函数的用法。<br>除了视景体定义的六个裁剪平面（上、下、左、右、前、后）外，用户还可自己再定义一个或多个附加裁剪平面，以去掉场景中无关的目标，如图8-12所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.12.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-12 附加裁剪平面和视景体</strong></td><br><br><br><br>附加平面裁剪函数为：</p>
<p>void glClipPlane(GLenum plane,Const GLdouble *equation);</p>
<p>函数定义一个附加的裁剪平面。其中参数equation指向一个拥有四个系数值的数组，这四个系数分别是裁剪平面Ax+By+Cz+D=0的A、B、 C、D值。因此，由这四个系数就能确定一个裁剪平面。参数plane是GL_CLIP_PLANEi(i=0,1,…)，指定裁剪面号。<br>在调用附加裁剪函数之前，必须先启动glEnable(GL_CLIP_PLANEi)，使得当前所定义的裁剪平面有效；当不再调用某个附加裁剪平面时，可用glDisable(GL_CLIP_PLANEi)关闭相应的附加裁剪功能。<br>下面这个例子不仅说明了附加裁剪函数的用法，而且调用了gluPerspective()透视投影函数，读者可以细细体会其中的用法。例程如下：</p>
<p>例8-6 裁剪变换例程（clipball.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);<br>void CALLBACK display(void);</p>
<p>void CALLBACK display(void)<br>{<br>GLdouble eqn[4] = {1.0, 0.0, 0.0, 0.0};</p>
<p>glClear(GL_COLOR_BUFFER_BIT);</p>
<p>glColor3f (1.0, 0.0, 1.0);<br>glPushMatrix();<br>glTranslatef (0.0, 0.0, -5.0);</p>
<p>/<em> clip the left part of wire_sphere : x&lt;0 </em>/<br>glClipPlane (GL_CLIP_PLANE0, eqn);<br>glEnable (GL_CLIP_PLANE0);<br>glRotatef (-90.0, 1.0, 0.0, 0.0);<br>auxWireSphere(1.0);<br>glPopMatrix();<br>glFlush();<br>}</p>
<p>void myinit (void)<br>{<br>glShadeModel (GL_FLAT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);<br>glMatrixMode(GL_MODELVIEW);<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGB);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Arbitrary Clipping Planes”);<br>myinit ();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.13.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-13 剪取后的网状半球体</strong></td><br><br><br><br><a name="8.5"></a><br>8.5、视口变换<br>在前面几节内容中已相继提到过视口变换，这一节将针对OpenGL来讲述视口变换的原理及其相关函数的用法。运用相机模拟方式，我们很容易理解视口变换就是类似于照片的放大与缩小。在计算机图形学中，它的定义是将经过几何变换、投影变换和裁剪变换后的物体显示于屏幕窗口内指定的区域内，这个区域通常为矩形，称为视口。OpenGL中相关函数是：</p>
<p>glViewport(GLint x,GLint y,GLsizei width, GLsizei height);</p>
<p>这个函数定义一个视口。函数参数(x, y)是视口在屏幕窗口坐标系中的左下角点坐标，参数width和height分别是视口的宽度和高度。缺省时，参数值即(0, 0, winWidth, winHeight) 指的是屏幕窗口的实际尺寸大小。所有这些值都是以象素为单位，全为整型数。<br>注意：在实际应用中，视口的长宽比率总是等于视景体裁剪面的长宽比率。如果两个比率不相等，那么投影后的图像显示于视口内时会发生变形，如图8-14所示。另外，屏幕窗口的改变一般不明显影响视口的大小。因此，在调用这个函数时，最好实时检测窗口尺寸，及时修正视口的大小，保证视口内的图像能随窗口的变化而变化，且不变形。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.14.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-14 视景体到视口的映射</strong></td><br><br><br><br><a name="8.6"></a><br>8.6 矩阵堆栈<br>学过计算机的人也许都知道这个使用频率极高的名词 — “堆栈”。顾名思义，堆栈指的是一个顶部打开底部封闭的柱状物体，通常用来存放常用的东西。这些东西从顶部依次放入，但取出时也只能从顶部取出，即“先进后出，后进先出”。在计算机中，它常指在内存中开辟的一块存放某些变量的连续区域。因此，OpenGL的矩阵堆栈指的就是内存中专门用来存放矩阵数据的某块特殊区域。<br>实际上，在创建、装入、相乘模型变换和投影变换矩阵时，都已用到堆栈操作。一般说来，矩阵堆栈常用于构造具有继承性的模型，即由一些简单目标构成的复杂模型。例如，一辆自行车就是由两个轮子、一个三角架及其它一些零部件构成的。它的继承性表现在当自行车往前走时，首先是前轮旋转，然后整个车身向前平移，接着是后轮旋转，然后整个车身向前平移，如此进行下去，这样自行车就往前走了。<br>矩阵堆栈对复杂模型运动过程中的多个变换操作之间的联系与独立十分有利。因为所有矩阵操作函数如glLoadMatrix()、glMultMatrix()、 glLoadIdentity()等只处理当前矩阵或堆栈顶部矩阵，这样堆栈中下面的其它矩阵就不受影响。堆栈操作函数有以下两个：</p>
<p>void glPushMatrix(void);<br>void glPopMatrix(void);</p>
<p>第一个函数表示将所有矩阵依次压入堆栈中，顶部矩阵是第二个矩阵的备份；压入的矩阵数不能太多，否则出错。第二个函数表示弹出堆栈顶部的矩阵，令原第二个矩阵成为顶部矩阵，接受当前操作，故原顶部矩阵被破坏；当堆栈中仅存一个矩阵时，不能进行弹出操作，否则出错。由此看出，矩阵堆栈操作与压入矩阵的顺序刚好相反，编程时要特别注意矩阵操作的顺序。<br>为了更好地理解这两个函数，我们可以形象地认为glPushMatrix()就是“记住自己在哪”，glPopMatrix()就是“返回自己原来所在地”。请看下面一例：</p>
<p>例8-7 堆栈操作例程（arm.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void drawPlane(void);<br>void CALLBACK elbowAdd (void);<br>void CALLBACK elbowSubtract (void);<br>void CALLBACK shoulderAdd (void);<br>void CALLBACK shoulderSubtract (void);<br>void CALLBACK display(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);</p>
<p>static int shoulder = 0, elbow = 0;</p>
<p>void CALLBACK elbowAdd (void)<br>{<br>elbow = (elbow + 5) % 360;<br>}</p>
<p>void CALLBACK elbowSubtract (void)<br>{<br>elbow = (elbow - 5) % 360;<br>}</p>
<p>void CALLBACK shoulderAdd (void)<br>{<br>shoulder = (shoulder + 5) % 360;<br>}</p>
<p>void CALLBACK shoulderSubtract (void)<br>{<br>shoulder = (shoulder - 5) % 360;<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT);<br>glColor3f(0.0, 1.0, 1.0);</p>
<p>glPushMatrix();<br>glTranslatef (-0.5, 0.0, 0.0);<br>glRotatef ((GLfloat)<br>shoulder, 0.0, 0.0, 1.0);<br>glTranslatef (1.0, 0.0, 0.0);<br>auxWireBox(2.0, 0.2, 0.5);</p>
<p>glTranslatef (1.0, 0.0, 0.0);<br>glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);<br>glTranslatef (0.8, 0.0, 0.0);<br>auxWireBox(1.6, 0.2, 0.5);</p>
<p>glPopMatrix();<br>glFlush();<br>}</p>
<p>void myinit (void)<br>{<br>glShadeModel (GL_FLAT);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity(); glTranslatef (0.0, 0.0, -5.0); /<em> viewing transform </em>/<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 400, 400);<br>auxInitWindow (“Composite Modeling Transformations”);</p>
<p>myinit ();</p>
<p>auxKeyFunc (AUX_LEFT, shoulderSubtract);<br>auxKeyFunc (AUX_RIGHT, shoulderAdd);<br>auxKeyFunc (AUX_UP, elbowAdd);<br>auxKeyFunc (AUX_DOWN, elbowSubtract);<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>从以上例程可以看出，复杂的机械手臂是由两个简单的长方体依据一定的继承关系构成的，而这个继承关系是由矩阵堆栈的顺序决定的。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/8.15.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td colspan="2"><strong>图8-15 简单机械手臂的符合运动</strong></td><br><br><br><br>九、OpenGL颜色</p>
<p>几乎所有OpenGL应用目的都是在屏幕窗口内绘制彩色图形，所以颜色在OpenGL编程中占有很重要的地位。这里的颜色与绘画中的颜色概念不一样，它属于RGB颜色空间，只在监视器屏幕上显示。另外，屏幕窗口坐标是以象素为单位，因此组成图形的每个象素都有自己的颜色，而这种颜色值是通过对一系列OpenGL函数命令的处理最终计算出来的。本章将讲述计算机颜色的概念以及OpenGL的颜色模式、颜色定义和两种模式应用场合等内容，若掌握好颜色的应用，你就能走进缤纷绚丽的色彩世界，从中享受无穷的乐趣。<br><a name="9.1"></a><br>9.1、计算机颜色</p>
<p>9.1.1 颜色生成原理<br>计算机颜色不同于绘画或印刷中的颜色，显示于计算机屏幕上每一个点的颜色都是由监视器内部的电子枪激发的三束不同颜色的光（红、绿、蓝）混合而成，因此，计算机颜色通 常用R（Red）、G（Green）、B（Blue）三个值来表示，这三个值又称为颜色分量。颜色生成原理 示意图见图9-1所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/9.1.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图9-1 计算机颜色生成原理</strong></td><br><br><br><br>9.1.2 RGB色立体（RGB Color Cube）<br>所有监视器屏幕的颜色都属于RGB颜色空间，如果用一个立方体形象地表示RGB颜色组成关系，那么就称这个立方体为RGB色立体，如图9-2所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/9.2.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图9-2 RGB色立体</strong></td><br><br><br><br>在图中，R、G、B三值的范围都是从0.0到1.0。如果某颜色分量越大，则表示对应的颜色分量越亮，也就是它在此点所贡献的颜色成分越多；反之，则越暗或越少。当R、G、B三个值都为0.0时，此点颜色为黑色（Black）；当三者都为1.0时，此点颜色为白色（White）；当三个颜色分量值相等时，表示三者贡献一样，因此呈现灰色（Grey），在图中表现为从黑色顶点到白色顶点的那条对角线；当R=1.0、G=1.0、B=0.0时，此点颜色为黄色（Yellow）；同理，R=1.0、G=0.0、B=1.0时为洋红色，也叫品色（Magenta）；R=0.0、G=1.0、B=1.0时为青色（Cyan）。<br><a name="9.2"></a><br>9.2、颜色模式<br>OpenGL颜色模式一共有两个：RGB（RGBA）模式和颜色表模式。在RGB模式下，所有的颜色定义全用R、G、B三个值来表示，有时也加上 Alpha值（与透明度有关），即RGBA模式。在颜色表模式下，每一个象素的颜色是用颜色表中的某个颜色索引值表示，而这个索引值指向了相应的R、G、 B值。这样的一个表成为颜色映射（Color Map）。</p>
<p>9.2.1 RGBA模式（RGBA Mode）<br>在RGBA模式下，可以用glColor*()来定义当前颜色。其函数形式为：</p>
<p>void glColor3{b s i f d ub us ui}(TYPE r,TYPE g,TYPE b);<br>void glColor4{b s i f d ub us ui}(TYPE r,TYPE g,TYPE b,TYPE a);<br>void glColor3{b s i f d ub us ui}v(TYPE <em>v);<br>void glColor4{b s i f d ub us ui}v(TYPE </em>v);</p>
<p>设置当前R、G、B和A值。这个函数有3和4两种方式，在前一种方式下，a值缺省为1.0，后一种Alpha值由用户自己设定，范围从0.0到1.0。同样，它也可用指针传递参数。另外，函数的第二个后缀的不同使用，其相应的参数值及范围不同，见下表9-1所示。虽然这些参数值不同，但实际上 OpenGL已自动将它们映射在0.0到1.0或-1.0或范围之内。因此，灵活使用这些后缀，会给你编程带来很大的方便。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="6%"><strong>后缀</strong></td></p>
<p><td width="23%"><strong>数据类型</strong></td></p>
<p><td width="20%"><strong>最小值</strong></td></p>
<p><td width="14%"><strong>最小值映射</strong></td></p>
<p><td width="18%"><strong>最大值</strong></td></p>
<p><td width="19%"><strong>最大值映射</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">b</td></p>
<p><td valign="top" width="23%">1字节整型数</td></p>
<p><td valign="top" width="20%">-128</td></p>
<p><td valign="top" width="14%">-1.0</td></p>
<p><td valign="top" width="18%">127</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">s</td></p>
<p><td valign="top" width="23%">2字节整型数</td></p>
<p><td valign="top" width="20%">-32,768</td></p>
<p><td valign="top" width="14%">-1.0</td></p>
<p><td valign="top" width="18%">32,767</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">i</td></p>
<p><td valign="top" width="23%">4字节整型数</td></p>
<p><td valign="top" width="20%">-2,147,483,648</td></p>
<p><td valign="top" width="14%">-1.0</td></p>
<p><td valign="top" width="18%">2,147,483,647</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">ub</td></p>
<p><td valign="top" width="23%">1字节无符号整型数</td></p>
<p><td valign="top" width="20%">0</td></p>
<p><td valign="top" width="14%">0.0</td></p>
<p><td valign="top" width="18%">255</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">us</td></p>
<p><td valign="top" width="23%">2字节无符号整型数</td></p>
<p><td valign="top" width="20%">0</td></p>
<p><td valign="top" width="14%">0.0</td></p>
<p><td valign="top" width="18%">65,535</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="6%">ui</td></p>
<p><td valign="top" width="23%">4字节无符号整型数</td></p>
<p><td valign="top" width="20%">0</td></p>
<p><td valign="top" width="14%">0.0</td></p>
<p><td valign="top" width="18%">4,294,967,295</td></p>
<p><td valign="top" width="19%">1.0</td><br></p>
<p><tr></tr></p>
<p><td colspan="6" valign="top"><strong>表9-1 整型颜色值到浮点数的转换</strong></td><br><br><br><br>9.2.2 颜色表模式（Color_Index Mode）<br>在颜色表方式下，可以调用glIndex*()函数从颜色表中选取当前颜色。其函数形式为：</p>
<p>void glIndex{sifd}(TYPE c);<br>void glIndex{sifd}v(TYPE *c);</p>
<p>设置当前颜色索引值，即调色板号。若值大于颜色位面数时则取模。</p>
<p>9.2.3 两种模式应用场合<br>在大多情况下，采用RGBA模式比颜色表模式的要多，尤其许多效果处理，如阴影、光照、雾、反走样、混合等，采用RGBA模式效果会更好些；另外，纹理映射只能在RGBA模式下进行。下面提供几种运用颜色表模式的情况（仅供参考）：<br>1）若原来应用程序采用的是颜色表模式则转到OpenGL上来时最好仍保持这种模式，便于移植。<br>2）若所用颜色不在缺省提供的颜色许可范围之内，则采用颜色表模式。<br>3）在其它许多特殊处理，如颜色动画，采用这种模式会出现奇异的效果。<br><a name="9.3"></a><br>9.3、颜色应用举例<br>颜色是一个极具吸引力的应用，在前面几章中已经逐步介绍了RGBA模式的应用方式，这里就不再多述。下面着重说一下颜色表模式的应用方法，请看例程：</p>
<p>例9-1 颜色表应用例程（cindex.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void InitPalette(void);<br>void DrawColorFans(void);<br>void CALLBACK myReshape(GLsizei w,GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>glClearColor(0.0,0.0,0.0,0.0);<br>glClear(GL_COLOR_BUFFER_BIT);<br>glShadeModel(GL_FLAT);<br>}</p>
<p>void InitPalette(void)<br>{<br>GLint j;<br>static GLfloat rgb[][3]={<br>{1.0,0.0,0.0},{1.0,0.0,0.5},{1.0,0.0,1.0},{0.0,0.0,1.0},<br>{0.0,1.0,1.0},{0.0,1.0,0.0},{1.0,1.0,0.0},{1.0,0.5,0.0}};</p>
<p>for(j=0;j&lt;8;j++)<br>auxSetOneColor(j+1,rgb[j][0],rgb[j][1],rgb[j][2]);<br>}</p>
<p>void CALLBACK myReshape(GLsizei w,GLsizei h)<br>{<br>glViewport(0,0,w,h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if(w&lt;=h)<br>glOrtho(-12.0,12.0,-12.0<em>(GLfloat)h/(GLfloat)w, 12.0</em>(GLfloat)h/(GLfloat)w,-30.0,30.0);<br>else<br>glOrtho(-12.0<em>(GLfloat)h/(GLfloat)w, 12.0</em>(GLfloat)h/(GLfloat)w,-12.0,12.0,-30.0,30.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void CALLBACK display(void)<br>{<br>InitPalette();<br>DrawColorFans();<br>glFlush();<br>}</p>
<p>void DrawColorFans(void)<br>{<br>GLint n;<br>GLfloat pp[8][2]={<br>{7.0,-7.0},{0.0,-10.0},{-7.0,-7.0},{-10.0,0.0},<br>{-7.0,7.0}, {0.0,10.0},{7.0,7.0},{10.0,0.0}};</p>
<p>/<em> draw some filled_fan_triangles </em>/<br>glBegin(GL_TRIANGLE_FAN);<br>glVertex2f(0.0,0.0);<br>glVertex2f(10.0,0.0);<br>for(n=0;n&lt;8;n++)<br>{<br>glIndexi(n+1);<br>glVertex2fv(pp[n]);<br>}<br>glEnd();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode(AUX_SINGLE|AUX_INDEX);<br>auxInitPosition(0,0,500,500);<br>auxInitWindow(“Color Index”);<br>myinit();<br>auxReshapeFunc(myReshape);<br>auxMainLoop(display);<br>}</p>
<p>这个程序运行结果是在屏幕上显示八个连成扇形的不同颜色的三角形，每个三角形的颜色定义采用颜色表模式。其中，调用了辅助库函数auxSetOneColor()来装载颜色映射表，即调色板。因为将某个颜色装载到颜色查找表（color lookup table）中的过程必须依赖窗口系统，而OpenGL函数与窗口系统无关，所以这里就调用辅助库的函数来完成这个过程，然后才调用OpenGL自己的函数glIndex()设置当前的颜色号。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/9.3.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td>**图9-3 自定义调色板</td></p>
<p>**<br><br><br><br>十、OpenGL光照</p>
<p>10.1、真实感图形基本概念<br>真实感图形绘制是计算机图形学的一个重要组成部分，它综合利用数学、物理学、计算机科学和其它科学知识在计算机图形设备上生成象彩色照片那样的具有真实感的图形。一般说来，用计算机在图形设备上生成真实感图形必须完成以下四个步骤：一是用建模，即用一定的数学方法建立所需三维场景的几何描述，场景的几何描述直接影响图形的复杂性和图形绘制的计算耗费；二是将三维几何模型经过一定变换转为二维平面透视投影图；三是确定场景中所有可见面，运用隐藏面消隐算法将视域外或被遮挡住的不可见面消去；四是计算场景中可见面的颜色，即根据基于光学物理的光照模型计算可见面投射到观察者眼中的光亮度大小和颜色分量，并将它转换成适合图形设备的颜色值，从而确定投影画面上每一象素的颜色，最终生成图形。<br>由于真实感图形是通过景物表面的颜色和明暗色调来表现景物的几何形状、空间位置以及表面材料的，而一个物体表面所呈现的颜色是由表面向视线方向辐射的光能决定的。在计算机图形学中，常采用一个既能表示光能大小又能表示其颜色组成的物理量即光亮度（luminance）或光强（intensity of light）来描述物体表面朝某方向辐射光能的颜色。采用这个物理量可以正确描述光在物体表面的反射、透射和吸收现象，因而可以正确计算处物体表面在空间给定方向上的光能颜色。<br>物体表面向空间给定方向辐射的光强可应用光照模型进行计算。简单的光照模型通常假定物体表面是光滑的且由理想材料构成，因此只考虑光源照射在物体表面产生的反射光，所生成的图形可以模拟处不透明物体表面的明暗过渡，具有一定的真实感效果。复杂的光照模型除了考虑上述因素外，还要考虑周围环境的光对物体表面的影响。如光亮平滑的物体表面会将环境中其它物体映像在表面上，而通过透明物体也可看到其后的环境景象。这类光照模型称为整体光照模型，它能模拟出镜面映像、透明等较精致的光照效果。为了更真实的绘制图形，还要考虑物体表面的细节纹理，这通常使用一种称为“纹理映射”（texture mapping）的技术把已有的平面花纹图案映射到物体表面上，并在应用光照模型时将这些花纹的颜色考虑进去，物体表面细节的模拟使绘制的图形更接近自然景物。<br>以上内容中，真实感图形绘制的四大步骤前两步在前面的章节已经详细介绍过，这里不再重复，第三步OpenGL将自动完成所有消隐过程，第四步下面几节详述。另外，部分复杂光照模型应用将在后续章节里介绍。<br><a name="10.2"></a><br>10.2、光照模型</p>
<p>10.2.1 简单光照模型<br>当光照射到一个物体表面上时，会出现三种情形。首先，光可以通过物体表面向空间反射，产生反射光。其次，对于透明体，光可以穿透该物体并从另一端射出，产生透射光。最后，部分光将被物体表面吸收而转换成热。在上述三部分光中，仅仅是透射光和反射光能够进入人眼产生视觉效果。这里介绍的简单光照模型只考虑被照明物体表面的反射光影响，假定物体表面光滑不透明且由理想材料构成，环境假设为由白光照明。<br>一般来说，反射光可以分成三个分量，即环境反射、漫反射和镜面反射。环境反射分量假定入射光均匀地从周围环境入射至景物表面并等量地向各个方向反射出去，通常物体表面还会受到从周围环境来的反射光（如来自地面、天空、墙壁等的反射光）的照射，这些光常统称为环境光（Ambient Light）；漫反射分量表示特定光源在景物表面的反射光中那些向空间各方向均匀反射出去的光，这些光常称为漫射光（Diffuse Light）；镜面反射光为朝一定方向的反射光，如一个点光源照射一个金属球时会在球面上形成一块特别亮的区域，呈现所谓“高光（Highlight）”，它是光源在金属球面上产生的镜面反射光（Specular Light）。对于较光滑物体，其镜面反射光的高光区域小而亮；相反，粗糙表面的镜面反射光呈发散状态，其高光区域大而不亮。下面先看一个简单的光照例程。</p>
<p>例10-1 简单光照例程（light0.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };</p>
<p>glLightfv(GL_LIGHT0, GL_POSITION, light_position);</p>
<p>glEnable(GL_LIGHTING);<br>glEnable(GL_LIGHT0);<br>glDepthFunc(GL_LESS);<br>glEnable(GL_DEPTH_TEST);<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>auxSolidSphere(1.0);<br>glFlush();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>glOrtho (-1.5, 1.5, -1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w, -10.0, 10.0);<br>else<br>glOrtho (-1.5<em>(GLfloat)w/(GLfloat)h, 1.5</em>(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Simple Lighting”);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果是显示一个具有灰色光影的球。其中函数myinit()中包含了关键的设定光源位置、启动光照等几句，而其它程序语言几乎与以前的没有多大区别，但效果却完全不一样。下面几个小节将详细介绍有关函数的用法。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.1.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图10-1 带光影的灰色球体</strong></td><br><br><br><br>10.2.2 OpenGL光组成<br>在OpenGL简单光照模型中的几种光分为：辐射光（Emitted Light）、环境光（Ambient Light）、漫射光（Diffuse Light）、镜面光（Specular Light）。<br>辐射光是最简单的一种光，它直接从物体发出并且不受任何光源影响。<br>环境光是由光源发出经环境多次散射而无法确定其方向的光，即似乎来自所有方向。一般说来，房间里的环境光成分要多些，户外的相反要少得多，因为大部分光按相同方向照射，而且在户外很少有其他物体反射的光。当环境光照到曲面上时，它在各个方向上均等地发散（类似于无影灯光）。<br>漫射光来自一个方向，它垂直于物体时比倾斜时更明亮。一旦它照射到物体上，则在各个方向上均匀地发散出去。于是，无论视点在哪里它都一样亮。来自特定位置和特定方向的任何光，都可能有散射成分。<br>镜面光来自特定方向并沿另一方向反射出去，一个平行激光束在高质量的镜面上产生100%的镜面反射。光亮的金属和塑料具有很高非反射成分，而象粉笔和地毯等几乎没有反射成分。因此，三某种意义上讲，物体的反射程度等同于其上的光强（或光亮度）。</p>
<p>10.2.3 创建光源（Light Source）<br>光源有许多特性，如颜色、位置、方向等。选择不同的特性值，则对应的光源作用在物体上的效果也不一样，这在以后的章节中会逐步介绍的。下面详细讲述定义光源特性的函数glLight*()：</p>
<p>void glLight{if}<a href="GLenum light , GLenum pname, TYPE param">v</a></p>
<p>创建具有某种特性的光源。其中第一个参数light指定所创建的光源号，如GL_LIGHT0、GL_LIGHT1、…、GL_LIGHT7。第二个参数pname指定光源特性，这个参数的辅助信息见表10-1所示。最后一个参数设置相应的光源特性值。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="28%"><strong>pname 参数名</strong></td></p>
<p><td width="26%"><strong>缺省值</strong></td></p>
<p><td width="46%"><strong>说明</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_AMBIENT</td></p>
<p><td valign="top" width="26%">(0.0, 0.0, 0.0, 1.0)</td></p>
<p><td valign="top" width="46%">RGBA模式下环境光</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_DIFFUSE</td></p>
<p><td valign="top" width="26%">(1.0, 1.0, 1.0, 1.0)</td></p>
<p><td valign="top" width="46%">RGBA模式下漫反射光</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_SPECULAR</td></p>
<p><td valign="top" width="26%">(1.0,1.0,1.0,1.0)</td></p>
<p><td valign="top" width="46%">RGBA模式下镜面光</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_POSITION</td></p>
<p><td valign="top" width="26%">(0.0,0.0,1.0,0.0)</td></p>
<p><td valign="top" width="46%">光源位置齐次坐标（x,y,z,w）</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_SPOT_DIRECTION</td></p>
<p><td valign="top" width="26%">(0.0,0.0,-1.0)</td></p>
<p><td valign="top" width="46%">点光源聚光方向矢量（x,y,z）</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_SPOT_EXPONENT</td></p>
<p><td valign="top" width="26%">0.0</td></p>
<p><td valign="top" width="46%">点光源聚光指数</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_SPOT_CUTOFF</td></p>
<p><td valign="top" width="26%">180.0</td></p>
<p><td valign="top" width="46%">点光源聚光截止角</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_CONSTANT_ATTENUATION</td></p>
<p><td valign="top" width="26%">1.0</td></p>
<p><td valign="top" width="46%">常数衰减因子</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_LINER_ATTENUATION</td></p>
<p><td valign="top" width="26%">0.0</td></p>
<p><td valign="top" width="46%">线性衰减因子</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="28%">GL_QUADRATIC_ATTENUATION</td></p>
<p><td valign="top" width="26%">0.0</td></p>
<p><td valign="top" width="46%">平方衰减因子</td><br></p>
<p><tr></tr></p>
<p><td colspan="3" valign="top"><strong>表10-1 函数glLight*()参数pname说明</strong></td><br><br><br><br>注意：以上列出的GL_DIFFUSE和GL_SPECULAR的缺省值只能用于GL_LIGHT0，其他几个光源的GL_DIFFUSE和GL_SPECULAR缺省值为(0.0,0.0,0.0,1.0)。另外，表中后六个参数的应用放在下一篇中介绍。在上面例程中，光源的创建为：</p>
<p>GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };<br>glLightfv(GL_LIGHT0, GL_POSITION, light_position);</p>
<p>其中light_position是一个指针，指向定义的光源位置齐次坐标数组。其它几个光源特性都为缺省值。同样，我们也可用类似的方式定义光源的其他几个特性值，例如：</p>
<p>GLfloat light_ambient [] = { 0.0, 0.0, 0.0, 1.0 };<br>GLfloat light_diffuse [] = { 1.0, 1.0, 1.0, 1.0 };<br>GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };<br>glLightfv(GL_LIGHT0, GL_AMBIENT , light_ambient );<br>glLightfv(GL_LIGHT0, GL_DIFFUSE , light_diffuse );<br>glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);</p>
<p>10.2.4 启动光照<br>在OpenGL中，必须明确指出光照是否有效或无效。如果光照无效，则只是简单地将当前颜色映射到当前顶点上去，不进行法向、光源、材质等复杂计算，那么显示的图形就没有真实感，如前几章例程运行结果显示。要使光照有效，首先得启动光照，即：</p>
<p>glEnable(GL_LIGHTING);</p>
<p>若使光照无效，则调用gDisable(GL_LIGHTING)可关闭当前光照。然后，必须使所定义的每个光源有效，例light0.c中只用了一个光源，即：</p>
<p>glEnable(GL_LIGHT0);</p>
<p>其它光源类似，只是光源号不同而已。<br><a name="10.3"></a><br>10.3、明暗处理<br>在计算机图形学中，光滑的曲面表面常用多边形予以逼近和表示，而每个小多边形轮廓（或内部）就用单一的颜色或许多不同的颜色来勾画（或填充），这种处理方式就称为明暗处理。在OpenGL中，用单一颜色处理的称为平面明暗处理（Flat Shading），用许多不同颜色处理的称为光滑明暗处理（Smooth Shading），也称为Gourand明暗处理（Gourand Shading）。设置明暗处理模式的函数为：</p>
<p>void glShadeModel(GLenum mode);</p>
<p>函数参数为GL_FLAT或GL_SMOOTH，分别表示平面明暗处理和光滑明暗处理。<br>应用平面明暗处理模式时，多边形内每个点的法向一致，且颜色也一致；应用光滑明暗处理模式时，多边形所有点的法向是由内插生成的，具有一定的连续性，因此每个点的颜色也相应内插，故呈现不同色。这种模式下，插值方法采用的是双线性插值法，如图10-2所示。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.2.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图10-2 Gouraud明暗处理</strong></td><br><br><br><br>Gouraud明暗处理通常算法为：先用多边形顶点的光强线性插值出当前扫描线与多边形边交点处的光强，然后再用交点的光强线插值处扫描线位于多边形内区段上每一象素处的光强值。图中显示出一条扫描线与多边形相交，交线的端点是A点和B点，P点是扫描线上位于多边形内的任一点，多边形三个顶点的光强分别为I1、I2和I3.取A点的光强Ia为I1和I2的线性插值，B点的光强Ib为I1和I3的线性插值，P点的光强Ip则为Ia和Ib的线性插值。采用Gouraud明暗处理不但可以使用多边形表示的曲面光强连续，而且计算量很小。这种算法还可以以增量的形式改进，且能用硬件直接实现算法，从而广泛用于计算机实时图形生成。请看下面光滑明暗处理的例程：</p>
<p>例10-2 明暗处理例程（Shading.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void object(void);<br>void CALLBACK display(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);</p>
<p>/<em> GL_SMOOTH is actually the default shading model. </em>/<br>void myinit (void)<br>{<br>glShadeModel (GL_SMOOTH);<br>}</p>
<p>void object(void)<br>{<br>glBegin (GL_POLYGON);<br>glColor3f (1.0, 0.0, 0.0);<br>glVertex2f (4.0, 4.0);<br>glColor3f(1.0,1.0,1.0);<br>glVertex2f (12.0, 4.0);<br>glColor3f(0.0,0.0,1.0);<br>glVertex2f (12.0, 12.0);<br>glColor3f(0.0,1.0,0.0);<br>glVertex2f (4.0, 12.0);<br>glEnd ();<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear (GL_COLOR_BUFFER_BIT);<br>object ();<br>glFlush ();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>gluOrtho2D (0.0, 16.0, 0.0, 16.0 <em> (GLfloat) h/(GLfloat) w);<br>else<br>gluOrtho2D (0.0, 16.0 </em> (GLfloat) w/(GLfloat) h, 0.0, 16.0);<br>glMatrixMode(GL_MODELVIEW);<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Smooth Shading”);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果是在屏幕上显示一个色彩连续变化的三角形。这个程序是用的RGBA显示模式，若改用颜色表模式，则颜色内插实际上是颜色表的内插，因此呈现的颜色可能不连续。网友不妨自己试试。<br>另外，若在light0.c程序中加上一句定义GL_FLAT明暗处理模式，则又会出现怎样的情形呢？读者可以仔细比较一下。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.3.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图10-3 高氏明暗处理的正方形</strong></td><br><br><br><br><a name="10.4"></a><br>10.4、材质</p>
<p>10.4.1 材质颜色<br>OpenGL用材料对光的红、绿、蓝三原色的反射率来近似定义材料的颜色。象光源一样，材料颜色也分成环境、漫反射和镜面反射成分，它们决定了材料对环境光、漫反射光和镜面反射光的反射程度。在进行光照计算时，材料对环境光的反射率与每个进入光源的环境光结合，对漫反射光的反射率与每个进入光源的漫反射光结合，对镜面光的反射率与每个进入光源的镜面反射光结合。对环境光与漫反射光的反射程度决定了材料的颜色，并且它们很相似。对镜面反射光的反射率通常是白色或灰色（即对镜面反射光中红、绿、蓝的反射率相同）。镜面反射高光最亮的地方将变成具有光源镜面光强度的颜色。例如一个光亮的红色塑料球，球的大部分表现为红色，光亮的高光将是白色的。</p>
<p>10.4.2 材质定义<br>材质的定义与光源的定义类似。其函数为：</p>
<p>void glMaterial{if}<a href="GLenum face,GLenum pname,TYPE param">v</a>;</p>
<p>定义光照计算中用到的当前材质。face可以是GL_FRONT、GL_BACK、GL_FRONT_AND_BACK，它表明当前材质应该应用到物体的哪一个面上；pname说明一个特定的材质；param是材质的具体数值，若函数为向量形式，则param是一组值的指针，反之为参数值本身。非向量形式仅用于设置GL_SHINESS。pname参数值具体内容见表10-1。另外，参数GL_AMBIENT_AND_DIFFUSE表示可以用相同的 RGB值设置环境光颜色和漫反射光颜色。</p>
<p><table border="0" cellspacing="1" cellpadding="2" align="center" bgcolor="#000000"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td width="27%"><strong>参数名</strong></td></p>
<p><td width="30%"><strong>缺省值</strong></td></p>
<p><td width="43%"><strong>说明</strong></td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_AMBIENT</td></p>
<p><td valign="top" width="30%">(0.2, 0.2, 0.2, 1.0)</td></p>
<p><td valign="top" width="43%">材料的环境光颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_DIFFUSE</td></p>
<p><td valign="top" width="30%">(0.8, 0.8, 0.8, 1.0)</td></p>
<p><td valign="top" width="43%">材料的漫反射光颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_AMBIENT_AND_DIFFUSE</td></p>
<p><td valign="top" width="30%"></td></p>
<p><td valign="top" width="43%">材料的环境光和漫反射光颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_SPECULAR</td></p>
<p><td valign="top" width="30%">(0.0, 0.0, 0.0, 1.0)</td></p>
<p><td valign="top" width="43%">材料的镜面反射光颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_SHINESS</td></p>
<p><td valign="top" width="30%">0.0</td></p>
<p><td valign="top" width="43%">镜面指数（光亮度）</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_EMISSION</td></p>
<p><td valign="top" width="30%">(0.0, 0.0, 0.0, 1.0)</td></p>
<p><td valign="top" width="43%">材料的辐射光颜色</td><br></p>
<p><tr></tr></p>
<p><td valign="top" width="27%">GL_COLOR_INDEXES</td></p>
<p><td valign="top" width="30%">(0, 1, 1)</td></p>
<p><td valign="top" width="43%">材料的环境光、漫反射光和镜面光颜色</td><br></p>
<p><tr></tr></p>
<p><td colspan="3" valign="top"><strong>表10-2 函数glMaterial*()参数pname的缺省值</strong></td><br><br><br><br>例10-3 材质定义例程（light1.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);</p>
<p>void CALLBACK display(void); void myinit(void)<br>{<br>/<em> 设置材质的各种光的颜色成分反射比率 </em>/<br>GLfloat mat_ambient[]={0.8,0.8,0.8,1.0};<br>GLfloat mat_diffuse[]={0.8,0.0,0.8,1.0};　　　　　/<em> 紫色 </em>/<br>GLfloat mat_specular[] = { 1.0, 0.0, 1.0, 1.0 };　/<em> 亮紫色 </em>/<br>GLfloat mat_shininess[] = { 50.0 };</p>
<p>GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };</p>
<p>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);</p>
<p>glLightfv(GL_LIGHT0, GL_POSITION, light_position);</p>
<p>glEnable(GL_LIGHTING);<br>glEnable(GL_LIGHT0);<br>glDepthFunc(GL_LESS);<br>glEnable(GL_DEPTH_TEST);<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>auxSolidSphere(1.0);<br>glFlush();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>glOrtho (-1.5, 1.5, -1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w, -10.0, 10.0);<br>else<br>glOrtho (-1.5<em>(GLfloat)w/(GLfloat)h, 1.5</em>(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH16);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Lighting_1 “);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果是一个紫色的球。在函数myinit()中定义了球的材质颜色，光源的定义仍延用light0.c中的，而light.c物体的光源定义为缺省形式。从例子中明显地看出，物体的材质颜色定义与光源颜色定义几乎一样，物体反射到眼中的颜色与二者都有关系，具体关系请看下一小节。</p>
<p>10.4.3 材质RGB值和光源RGB值的关系<br>材质的颜色与光源的颜色有些不同。对于光源，R、G、B值等于R、G、B对其最大强度的百分比。若光源颜色的R、G、B值都是1.0，则是最强的白光；若值变为0.5，颜色仍为白色，但强度为原来的一半，于是表现为灰色；若R＝G＝1.0，B＝0.0，则光源为黄色。对于材质，R、G、B值为材质对光的 R、G、B成分的反射率。比如，一种材质的R＝1.0、G＝0.5、B＝0.0，则材质反射全部的红色成分，一半的绿色成分，不反射蓝色成分。也就是说，若OpenGL的光源颜色为（LR、LG、LB），材质颜色为（MR、MG、MB），那么，在忽略所有其他反射效果的情况下，最终到达眼睛的光的颜色为（LR<em>MR、LG</em>MG、LB*MB）。<br>同样，如果有两束光，相应的值分别为（R1、G1、B1）和（R2、G2、B2），则OpenGL 将各个颜色成分相加，得到（R1+R2、G1+G2、B1+B2），若任一成分的和值大于1（超出了设备所能显示的亮度）则约简到1.0。下面一例程就说明了二者之间的关系。</p>
<p>例10-4 材质与光源的RGB关系例程（light2.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>GLfloat mat_ambient[]= { 0.8, 0.8, 0.8, 1.0 };<br>GLfloat mat_diffuse[]= { 0.8, 0.0, 0.8, 1.0 };　/<em> 紫色 </em>/<br>GLfloat mat_specular[] = { 1.0, 0.0, 1.0, 1.0 };<br>GLfloat mat_shininess[] = { 50.0 };</p>
<p>GLfloat light_diffuse[]= { 0.0, 0.0, 1.0, 1.0};　/<em> 蓝色 </em>/<br>GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };</p>
<p>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);</p>
<p>glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);<br>glLightfv(GL_LIGHT0, GL_POSITION, light_position);</p>
<p>glEnable(GL_LIGHTING);<br>glEnable(GL_LIGHT0);<br>glDepthFunc(GL_LESS);<br>glEnable(GL_DEPTH_TEST);<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>auxSolidSphere(1.0);<br>glFlush();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>glOrtho (-1.5, 1.5, -1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w, -10.0, 10.0);<br>else<br>glOrtho (-1.5<em>(GLfloat)w/(GLfloat)h, 1.5</em>(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH16);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“Lighting_2 “);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序运行结果是一个蓝色的球，其中高光部分仍为上一例的亮紫色。从上可看出，球漫反射光的结果是mat_diffuse[]与 light_diffuse[]中的三个颜色分量值相乘，即 (0.0<em>1.0,0.0</em>1.0,0.8<em>1.0,1.0</em>1.0)=(0.0,0.0,0.8,1.0)，所以球大部分呈现蓝色。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.4.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图10-4 光照蓝色球</strong>（<strong>高光为红色</strong>）</td><br><br><br><br>10.4.4 材质改变<br>在实际应用的许多情况下，不同的物体或同一物体的不同部分都有可能设置不同的材质，OpenGL函数库提供了两种方式实现这种要求。下面一例程采用的是设置矩阵堆栈来保存不同物体的材质信息：</p>
<p>例10-5 矩阵堆栈改变材质例程（chgmat1.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK display(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);</p>
<p>/<em> 初始化z-buffer、光源和光照模型，在此不具体定义材质。</em>/<br>void myinit(void)<br>{<br>GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };<br>GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };<br>GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };<br>GLfloat position[] = { 0.0, 3.0, 2.0, 0.0 };<br>GLfloat lmodel_ambient[] = { 0.4, 0.4, 0.4, 1.0 };</p>
<p>glEnable(GL_DEPTH_TEST);<br>glDepthFunc(GL_LESS);</p>
<p>glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);<br>glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);<br>glLightfv(GL_LIGHT0, GL_POSITION, position);</p>
<p>glEnable(GL_LIGHTING);<br>glEnable(GL_LIGHT0);</p>
<p>glClearColor(0.0, 0.1, 0.1, 0.0);<br>}</p>
<p>void CALLBACK display(void)<br>{<br>GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };<br>GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };<br>GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };<br>GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };<br>GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };<br>GLfloat no_shininess[] = { 0.0 };<br>GLfloat low_shininess[] = { 5.0 };<br>GLfloat high_shininess[] = { 100.0 };<br>GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};</p>
<p>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</p>
<p>/<em> 第一行第一列绘制的球仅有漫反射光而无环境光和镜面光。</em>/<br>glPushMatrix();<br>glTranslatef (-3.75, 3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第一行第二列绘制的球有漫反射光和镜面光，并有低高光，而无环境光 。</em>/<br>glPushMatrix();<br>glTranslatef (-1.25, 3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第一行第三列绘制的球有漫反射光和镜面光，并有很亮的高光，而无环境光 。</em>/<br>glPushMatrix();<br>glTranslatef (1.25, 3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第一行第四列绘制的球有漫反射光和辐射光，而无环境和镜面反射光。</em>/<br>glPushMatrix();<br>glTranslatef (3.75, 3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第二行第一列绘制的球有漫反射光和环境光，而镜面反射光。</em>/<br>glPushMatrix();<br>glTranslatef (-3.75, 0.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第二行第二列绘制的球有漫反射光、环境光和镜面光，且有低高光。</em>/<br>glPushMatrix();<br>glTranslatef (-1.25, 0.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第二行第三列绘制的球有漫反射光、环境光和镜面光，且有很亮的高光。</em>/<br>glPushMatrix();<br>glTranslatef (1.25, 0.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第二行第四列绘制的球有漫反射光、环境光和辐射光，而无镜面光。</em>/<br>glPushMatrix();<br>glTranslatef (3.75, 0.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);<br>auxSolidSphere(1.0); glPopMatrix();</p>
<p>/<em> 第三行第一列绘制的球有漫反射光和有颜色的环境光，而无镜面光。</em>/<br>glPushMatrix();<br>glTranslatef (-3.75, -3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第三行第二列绘制的球有漫反射光和有颜色的环境光以及镜面光，且有低高光。</em>/<br>glPushMatrix();<br>glTranslatef (-1.25, -3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第三行第三列绘制的球有漫反射光和有颜色的环境光以及镜面光，且有很亮的高光。</em>/<br>glPushMatrix();<br>glTranslatef (1.25, -3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>/<em> 第三行第四列绘制的球有漫反射光和有颜色的环境光以及辐射光，而无镜面光。</em>/<br>glPushMatrix();<br>glTranslatef (3.75, -3.0, 0.0);<br>glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);<br>glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);<br>auxSolidSphere(1.0);<br>glPopMatrix();</p>
<p>glFlush();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= (h <em> 2))<br>glOrtho (-6.0, 6.0, -3.0</em>((GLfloat)h<em>2)/(GLfloat)w,<br>3.0</em>((GLfloat)h<em>2)/(GLfloat)w, -10.0, 10.0);<br>else<br>glOrtho (-6.0</em>(GLfloat)w/((GLfloat)h<em>2),<br>6.0</em>(GLfloat)w/((GLfloat)h*2), -3.0, 3.0, -10.0, 10.0);<br>glMatrixMode(GL_MODELVIEW);<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);<br>auxInitPosition (0, 0, 600, 450);<br>auxInitWindow (“Material”);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.5.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td><strong>图10-5 多种光和材质的变化效果</strong></td><br><br><br><br>以上程序运行结果是绘制12个球（3行4列）。第一行的球材质都没有环境反射光，第二行的都有一定的环境反射光，第三行的都有某种颜色的环境光。而第一列的球材质仅有蓝色的漫反射光；第二列的不仅有蓝漫反射光，而且还有镜面反射光，较低的高光；第三列的不仅有蓝漫反射光，而且还有镜面反射光，很亮的高光；第四列的还包括辐射光，但无镜面光。<br>这个程序运用矩阵堆栈多次调用glMaterialfv()来设置每个球的材质，也就是改变同一场景中的不同物体的颜色。但由于这个函数的应用有个性能开销，因此建议最好尽可能少的改变材质，以减少改变材质时所带来的性能开销，可采用另一种方式即改变材质颜色，相应函数为glColorMaterial()，说明如下：</p>
<p>void glColorMaterial(GLenum face,GLenum mode);</p>
<p>函数参数face指定面，值有GL_FRONT、GL_BACK或GL_FRONT_AND_BACK（缺省值）。mode指定材质成分，值有 GL_AMBIENT、GL_DIFFUSE、GL_AMBIENT_AND_DIFFUSE（缺省值）、GL_SPECULAR或 GLEMISSION。<br>注意：这个函数说明了两个独立的值，第一个参数说明哪一个面和哪些面被修改，而第二个参数说明这些面的哪一个或哪些材质成分要被修改。OpenGL并不为每一种face保持独立的mode变量。在调用glColorMterial() 以后，首先需要用GL_COLOR_MATERIAL作为参数调用glEnable()来启动颜色材质，然后在绘图时调用glColor*()来改变当前颜色，或用glMaterial()来改变材质成分。当不用这种方式来改变材质时，可调用glDisable(GL_COLOR_MATERIAL)来关闭取消。如下面一段代码：</p>
<p>glColorMaterial(GL_FRONT,GL_DIFFUSE);<br>glEnable(GL_COLOR_MATERIAL);<br>glColor3f(0.3,0.5,0.7);<br>/<em> draw some objects here. </em>/<br>glcolor3f(0.0,1.0,0.0);<br>/<em> draw other objects here.</em>/<br>glDisable(GL_COLOR_MATERIAL);</p>
<p>当需要改变场景中大部分方面的单个材质时，最好调用glColorMaterial()；当需要修改不止一个材质参数时，最好调用glMaterial*()。注意，当不需要颜色材质时一定要关闭它，以避免相应的开销。下面来看一个颜色材质的具体应用例子：</p>
<p>例10-6 颜色定义改变材质例程（chgmat2.c）</p>
<p>#include “glos.h”</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>void myinit(void);<br>void CALLBACK myReshape(GLsizei w, GLsizei h);<br>void CALLBACK display(void);</p>
<p>void myinit(void)<br>{<br>GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };</p>
<p>glLightfv(GL_LIGHT0, GL_POSITION, light_position);</p>
<p>glEnable(GL_LIGHTING);<br>glEnable(GL_LIGHT0);<br>glDepthFunc(GL_LESS);<br>glEnable(GL_DEPTH_TEST);</p>
<p>glColorMaterial(GL_FRONT, GL_DIFFUSE);<br>glEnable(GL_COLOR_MATERIAL);<br>}</p>
<p>void CALLBACK display(void)<br>{<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</p>
<p>/<em> draw one yellow ball </em>/<br>glLoadIdentity();<br>glTranslatef(-0.7,0.0,0.0);<br>glColor3f(1.0,1.0,0.0);<br>auxSolidSphere(0.5);</p>
<p>/<em> draw one red cone </em>/<br>glLoadIdentity();<br>glRotatef(-65.0,1.0,0.0,0.0);<br>glTranslatef(0.7,0.0,0.0);<br>glColor3f(1.0,0.0,0.0);<br>auxSolidCone(0.4,0.6);</p>
<p>glFlush();<br>}</p>
<p>void CALLBACK myReshape(GLsizei w, GLsizei h)<br>{<br>glViewport(0, 0, w, h);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>if (w &lt;= h)<br>glOrtho (-1.5, 1.5, -1.5<em>(GLfloat)h/(GLfloat)w, 1.5</em>(GLfloat)h/(GLfloat)w, -10.0, 10.0);<br>else<br>glOrtho (-1.5<em>(GLfloat)w/(GLfloat)h, 1.5</em>(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);<br>glMatrixMode(GL_MODELVIEW);<br>glLoadIdentity();<br>}</p>
<p>void main(void)<br>{<br>auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);<br>auxInitPosition (0, 0, 500, 500);<br>auxInitWindow (“ColorMaterial Mode”);<br>myinit();<br>auxReshapeFunc (myReshape);<br>auxMainLoop(display);<br>}</p>
<p>以上程序改变的是漫反射颜色。场景中显示了一个黄色的球和一个红色的锥体。</p>
<p><table border="0" cellspacing="0" cellpadding="2" align="center"></table></p>
<p><tbody></tbody></p>
<p><tr align="middle"></tr></p>
<p><td><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/StFairy/10.6.JPG" alt=""></td><br></p>
<p><tr align="middle"></tr></p>
<p><td>**图10-6 漫反射材质改变</td></p>
<p>**<br><br><br><br>转自：<a href="http://blog.csdn.net/iduosi/article/details/7835624" target="_blank" rel="noopener">http://blog.csdn.net/iduosi/article/details/7835624</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info">voya</span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info">http://www.voyax.meposts/52520/</span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../tags/OPenGL/">OPenGL</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="../36051/"><i class="fa fa-chevron-left">  </i><span>我不会安慰人，只是希望你们好好的</span></a></div><div class="next-post pull-right"><a href="../22260/"><span>OPenGL函数glMatrixMode和glMatrixMode()和gluPerspective和gluLookAt用法</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2016 - 2018 By voya</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Hosted by - </span><a href="https://pages.coding.me/"><span>Coding Pages</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.3"></script><script src="/js/fancybox.js?version=1.3"></script><script src="/js/sidebar.js?version=1.3"></script><script src="/js/copy.js?version=1.3"></script><script src="/js/fireworks.js?version=1.3"></script><script src="/js/transition.js?version=1.3"></script><script src="/js/scroll.js?version=1.3"></script><script src="/js/head.js?version=1.3"></script></body></html>